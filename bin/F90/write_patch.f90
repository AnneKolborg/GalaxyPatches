subroutine output_patch(filename)
  character(LEN=80)::filename
  character(LEN=80)::fileloc
  character(LEN=30)::format
  integer::ilun

  ilun=11

  fileloc=TRIM(filename)
  format="(A)"
  open(unit=ilun,file=fileloc,form='formatted')
  write(ilun,format)"../patch/hydro/stratified_medium_fx_NSM/adaptive_loop.f90"
  write(ilun,format)"subroutine adaptive_loop"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use poisson_commons"
  write(ilun,format)"  use cooling_module"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  integer::ilevel,idim,ivar,info"
  write(ilun,format)"  real(kind=8)::tt1,tt2"
  write(ilun,format)"  real(kind=4)::real_mem,real_mem_tot"
  write(ilun,format)""
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  tt1=MPI_WTIME(info)"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  call init_amr                      ! Initialize AMR variables"
  write(ilun,format)"  call init_time                     ! Initialize time variables"
  write(ilun,format)"  if(hydro)call init_hydro           ! Initialize hydro variables"
  write(ilun,format)"  if(poisson)call init_poisson       ! Initialize poisson variables"
  write(ilun,format)"#ifdef ATON"
  write(ilun,format)"  if(aton)call init_radiation        ! Initialize radiation variables"
  write(ilun,format)"#endif"
  write(ilun,format)"  if(nrestart==0)call init_refine    ! Build initial AMR grid"
  write(ilun,format)"  if(cooling)call set_table(dble(aexp))  ! Initialize cooling look up table"
  write(ilun,format)"  if(pic)call init_part              ! Initialize particle variables"
  write(ilun,format)"  if(pic)call init_tree              ! Initialize particle tree"
  write(ilun,format)"  if(nrestart==0)call init_refine_2  ! Build initial AMR grid again"
  write(ilun,format)""
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  tt2=MPI_WTIME(info)"
  write(ilun,format)"  if(myid==1)write(*,*)'Time elapsed since startup:',tt2-tt1"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  if(myid==1)then"
  write(ilun,format)"     write(*,*)'Initial mesh structure'"
  write(ilun,format)"     do ilevel=1,nlevelmax"
  write(ilun,format)"        if(numbtot(1,ilevel)>0)write(*,999)ilevel,numbtot(1:4,ilevel)"
  write(ilun,format)"     end do"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  nstep_coarse_old=nstep_coarse"
  write(ilun,format)""
  write(ilun,format)"  if(myid==1)write(*,*)'Starting time integration' "
  write(ilun,format)""
  write(ilun,format)"  do ! Main time loop"
  write(ilun,format)""
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     tt1=MPI_WTIME(info)"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"     if(verbose)write(*,*)'Entering amr_step_coarse'"
  write(ilun,format)""
  write(ilun,format)"     epot_tot=0.0D0  ! Reset total potential energy"
  write(ilun,format)"     ekin_tot=0.0D0  ! Reset total kinetic energy"
  write(ilun,format)"     mass_tot=0.0D0  ! Reset total mass"
  write(ilun,format)"     eint_tot=0.0D0  ! Reset total internal energy"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"     emag_tot=0.0D0  ! Reset total magnetic energy"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"     ! Make new refinements"
  write(ilun,format)"     if(levelmin.lt.nlevelmax)then"
  write(ilun,format)"        call refine_coarse"
  write(ilun,format)"        do ilevel=1,levelmin"
  write(ilun,format)"           call build_comm(ilevel)"
  write(ilun,format)"           call make_virtual_fine_int(cpu_map(1),ilevel)"
  write(ilun,format)"           if(hydro)then"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"              do ivar=1,nvar+3"
  write(ilun,format)"#else"
  write(ilun,format)"              do ivar=1,nvar"
  write(ilun,format)"#endif"
  write(ilun,format)"                 call make_virtual_fine_dp(uold(1,ivar),ilevel)"
  write(ilun,format)"              end do"
  write(ilun,format)"              if(simple_boundary)call make_boundary_hydro(ilevel)"
  write(ilun,format)"              if(poisson)then"
  write(ilun,format)"                 do idim=1,ndim"
  write(ilun,format)"                    call make_virtual_fine_dp(f(1,idim),ilevel)"
  write(ilun,format)"                 end do"
  write(ilun,format)"              end if"
  write(ilun,format)"           end if"
  write(ilun,format)"           if(ilevel<levelmin)call refine_fine(ilevel)"
  write(ilun,format)"        end do"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     ! Call base level"
  write(ilun,format)"     call amr_step(levelmin,1)"
  write(ilun,format)""
  write(ilun,format)"     if(levelmin.lt.nlevelmax)then"
  write(ilun,format)"        ! Hydro book-keeping"
  write(ilun,format)"        if(hydro)then"
  write(ilun,format)"           do ilevel=levelmin-1,1,-1"
  write(ilun,format)"              call upload_fine(ilevel)"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"              do ivar=1,nvar+3"
  write(ilun,format)"#else"
  write(ilun,format)"              do ivar=1,nvar"
  write(ilun,format)"#endif"
  write(ilun,format)"                 call make_virtual_fine_dp(uold(1,ivar),ilevel)"
  write(ilun,format)"              end do"
  write(ilun,format)"              if(simple_boundary)call make_boundary_hydro(ilevel)"
  write(ilun,format)"              if(poisson)then"
  write(ilun,format)"                 do idim=1,ndim"
  write(ilun,format)"                    call make_virtual_fine_dp(f(1,idim),ilevel)"
  write(ilun,format)"                 end do"
  write(ilun,format)"              end if"
  write(ilun,format)"           end do"
  write(ilun,format)"        end if"
  write(ilun,format)"        "
  write(ilun,format)"        ! Build refinement map"
  write(ilun,format)"        do ilevel=levelmin-1,1,-1"
  write(ilun,format)"           call flag_fine(ilevel,2)"
  write(ilun,format)"        end do"
  write(ilun,format)"        call flag_coarse"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     ! New coarse time-step"
  write(ilun,format)"     nstep_coarse=nstep_coarse+1"
  write(ilun,format)""
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     tt2=MPI_WTIME(info)"
  write(ilun,format)"     if(mod(nstep_coarse,ncontrol)==0)then"
  write(ilun,format)"        call getmem(real_mem)"
  write(ilun,format)"        call MPI_ALLREDUCE(real_mem,real_mem_tot,1,MPI_REAL,MPI_MAX,MPI_COMM_WORLD,info)"
  write(ilun,format)"        if(myid==1)then"
  write(ilun,format)"           write(*,*)'Time elapsed since last coarse step:',tt2-tt1"
  write(ilun,format)"           call writemem(real_mem_tot)"
  write(ilun,format)"        endif"
  write(ilun,format)"     endif"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"999 format(' Level ',I2,' has ',I10,' grids (',3(I8,','),')')"
  write(ilun,format)""
  write(ilun,format)"end subroutine adaptive_loop"
  write(ilun,format)"../patch/hydro/stratified_medium_fx_NSM/amr_parameters.f90"
  write(ilun,format)"module amr_parameters"
  write(ilun,format)""
  write(ilun,format)"  ! Define real types"
  write(ilun,format)"  integer,parameter::sp=kind(1.0E0)"
  write(ilun,format)"#ifndef NPRE"
  write(ilun,format)"  integer,parameter::dp=kind(1.0E0) ! default"
  write(ilun,format)"#else"
  write(ilun,format)"#if NPRE==4"
  write(ilun,format)"  integer,parameter::dp=kind(1.0E0) ! real*4"
  write(ilun,format)"#else"
  write(ilun,format)"  integer,parameter::dp=kind(1.0D0) ! real*8"
  write(ilun,format)"#endif"
  write(ilun,format)"#endif"
  write(ilun,format)"#ifdef QUADHILBERT"
  write(ilun,format)"  integer,parameter::qdp=kind(1.0_16) ! real*16"
  write(ilun,format)"#else"
  write(ilun,format)"  integer,parameter::qdp=kind(1.0_8) ! real*8"
  write(ilun,format)"#endif"
  write(ilun,format)"  integer,parameter::MAXOUT=5000"
  write(ilun,format)"  integer,parameter::MAXLEVEL=100"
  write(ilun,format)"  "
  write(ilun,format)"  ! Define integer types (for particle IDs mostly)"
  write(ilun,format)"  integer,parameter::i4b=4"
  write(ilun,format)"#ifndef LONGINT"
  write(ilun,format)"  integer,parameter::i8b=4  ! default long int are short int"
  write(ilun,format)"#else"
  write(ilun,format)"  integer,parameter::i8b=8  ! long int are long int"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  ! Number of dimensions"
  write(ilun,format)"#ifndef NDIM"
  write(ilun,format)"  integer,parameter::ndim=1"
  write(ilun,format)"#else"
  write(ilun,format)"  integer,parameter::ndim=NDIM"
  write(ilun,format)"#endif"
  write(ilun,format)"  integer,parameter::twotondim=2**ndim"
  write(ilun,format)"  integer,parameter::threetondim=3**ndim"
  write(ilun,format)"  integer,parameter::twondim=2*ndim"
  write(ilun,format)""
  write(ilun,format)"  ! Vectorization parameter"
  write(ilun,format)"#ifndef NVECTOR"
  write(ilun,format)"  integer,parameter::nvector=500  ! Size of vector sweeps"
  write(ilun,format)"#else"
  write(ilun,format)"  integer,parameter::nvector=NVECTOR"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  integer, parameter :: nstride = 65536"
  write(ilun,format)""
  write(ilun,format)"  ! Run control"
  write(ilun,format)"  logical::verbose =.false.   ! Write everything"
  write(ilun,format)"  logical::hydro   =.false.   ! Hydro activated"
  write(ilun,format)"  logical::pic     =.false.   ! Particle In Cell activated"
  write(ilun,format)"  logical::poisson =.false.   ! Poisson solver activated"
  write(ilun,format)"  logical::cosmo   =.false.   ! Cosmology activated"
  write(ilun,format)"  logical::star    =.false.   ! Star formation activated"
  write(ilun,format)"  logical::sink    =.false.   ! Sink particles activated"
  write(ilun,format)"  logical::rt      =.false.   ! Radiative transfer activated"
  write(ilun,format)"  logical::debug   =.false.   ! Debug mode activated"
  write(ilun,format)"  logical::static  =.false.   ! Static mode activated"
  write(ilun,format)"  logical::static_dm=.false.  ! Static mode for dm only activated"
  write(ilun,format)"  logical::static_gas=.false. ! Static mode for gas only activated"
  write(ilun,format)"  logical::static_stars=.false.! Static mode for stars only activated"
  write(ilun,format)"  logical::tracer  =.false.   ! Tracer particles activated"
  write(ilun,format)"  logical::lightcone=.false.  ! Enable lightcone generation"
  write(ilun,format)"  logical::clumpfind=.false.  ! Enable clump finder"
  write(ilun,format)"  logical::aton=.false.       ! Enable ATON coarse grid radiation transfer"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh parameters"
  write(ilun,format)"  integer::geom=1             ! 1: cartesian, 2: cylindrical, 3: spherical"
  write(ilun,format)"  integer::nx=1,ny=1,nz=1     ! Number of coarse cells in each dimension"
  write(ilun,format)"  integer::levelmin=1         ! Full refinement up to levelmin"
  write(ilun,format)"  integer::nlevelmax=1        ! Maximum number of level"
  write(ilun,format)"  integer::ngridmax=0         ! Maximum number of grids"
  write(ilun,format)"  integer,dimension(1:MAXLEVEL)::nexpand=1 ! Number of mesh expansion"
  write(ilun,format)"  integer::nexpand_bound=1    ! Number of mesh expansion for virtual boundaries"
  write(ilun,format)"  real(dp)::boxlen=1.0D0      ! Box length along x direction"
  write(ilun,format)"  character(len=128)::ordering='hilbert'"
  write(ilun,format)"  logical::cost_weighting=.true. ! Activate load balancing according to cpu time"
  write(ilun,format)"  ! Recursive bisection tree parameters"
  write(ilun,format)"  integer::nbilevelmax=1      ! Max steps of bisection partitioning"
  write(ilun,format)"  integer::nbinodes=3         ! Max number of internal nodes"
  write(ilun,format)"  integer::nbileafnodes=2     ! Max number of leaf (terminal) nodes"
  write(ilun,format)"  real(dp)::bisec_tol=0.05d0  ! Tolerance for bisection load balancing"
  write(ilun,format)""
  write(ilun,format)"  ! Step parameters"
  write(ilun,format)"  integer::nrestart=0         ! New run or backup file number"
  write(ilun,format)"  integer::nrestart_quad=0    ! Restart with double precision Hilbert keys"
  write(ilun,format)"  real(dp)::trestart=0.0      ! Restart time"
  write(ilun,format)"  logical::restart_remap=.false. ! Force load balance on restart"
  write(ilun,format)"  integer::nstepmax=1000000   ! Maximum number of time steps"
  write(ilun,format)"  integer::ncontrol=1         ! Write control variables"
  write(ilun,format)"  integer::nremap=0           ! Load balancing frequency (0: never)"
  write(ilun,format)"  integer,allocatable,dimension(:)::remap_pscalar"
  write(ilun,format)"  "
  write(ilun,format)"  ! Output parameters"
  write(ilun,format)"  integer::iout=1             ! Increment for output times"
  write(ilun,format)"  integer::ifout=1            ! Increment for output files"
  write(ilun,format)"  integer::iback=1            ! Increment for backup files"
  write(ilun,format)"  integer::noutput=1          ! Total number of outputs"
  write(ilun,format)"  integer::foutput=1000000    ! Frequency of outputs"
  write(ilun,format)"  integer::output_mode=0      ! Output mode (for hires runs)"
  write(ilun,format)"  logical::gadget_output=.false. ! Output in gadget format"
  write(ilun,format)"  logical::output_now=.false. ! write output next step"
  write(ilun,format)""
  write(ilun,format)"  ! Lightcone parameters"
  write(ilun,format)"  real(dp)::thetay_cone=12.5"
  write(ilun,format)"  real(dp)::thetaz_cone=12.5"
  write(ilun,format)"  real(dp)::zmax_cone=2.0"
  write(ilun,format)""
  write(ilun,format)"  ! Cosmology and physical parameters"
  write(ilun,format)"  real(dp)::boxlen_ini        ! Box size in h-1 Mpc"
  write(ilun,format)"  real(dp)::omega_b=0.0D0     ! Omega Baryon"
  write(ilun,format)"  real(dp)::omega_m=1.0D0     ! Omega Matter"
  write(ilun,format)"  real(dp)::omega_l=0.0D0     ! Omega Lambda"
  write(ilun,format)"  real(dp)::omega_k=0.0D0     ! Omega Curvature"
  write(ilun,format)"  real(dp)::h0     =1.0D0     ! Hubble constant in km/s/Mpc"
  write(ilun,format)"  real(dp)::aexp   =1.0D0     ! Current expansion factor"
  write(ilun,format)"  real(dp)::hexp   =0.0D0     ! Current Hubble parameter"
  write(ilun,format)"  real(dp)::texp   =0.0D0     ! Current proper time"
  write(ilun,format)"  real(dp)::n_sink = -1.d0    ! Sink particle density threshold in H/cc"
  write(ilun,format)"  real(dp)::rho_sink = -1.D0  ! Sink particle density threshold in g/cc"
  write(ilun,format)"  real(dp)::d_sink = -1.D0    ! Sink particle density threshold in user units"
  write(ilun,format)"  real(dp)::m_star =-1.0      ! Star particle mass in units of mass_sph"
  write(ilun,format)"  real(dp)::n_star =0.1D0     ! Star formation density threshold in H/cc"
  write(ilun,format)"  real(dp)::t_star =0.0D0     ! Star formation time scale in Gyr"
  write(ilun,format)"  real(dp)::eps_star=0.0D0    ! Star formation efficiency (0.02 at n_star=0.1 gives t_star=8 Gyr)"
  write(ilun,format)"  real(dp)::T2_star=0.0D0     ! Typical ISM polytropic temperature"
  write(ilun,format)"  real(dp)::g_star =1.6D0     ! Typical ISM polytropic index"
  write(ilun,format)"  real(dp)::jeans_ncells=-1   ! Jeans polytropic EOS"
  write(ilun,format)"  real(dp)::del_star=2.D2     ! Minimum overdensity to define ISM"
  write(ilun,format)"  real(dp)::eta_sn =0.0D0     ! Supernova mass fraction"
  write(ilun,format)"  real(dp)::yield=0.0D0 !yield used for star formation processes"
  write(ilun,format)"  real(dp)::yield_Ia_Fe  =0.0D0     ! SNe Ia Iron yield"
  write(ilun,format)"  real(dp)::yield_cc_Fe = 0.0D0 ! SNe CC Iron yeild "
  write(ilun,format)"  real(dp)::yield_NSM_Fe = 0.0D0  ! NSM yeild Iron yeild"
  write(ilun,format)"  real(dp)::yield_Ia_alpha = 0.0D0"
  write(ilun,format)"  real(dp)::yield_cc_alpha = 0.0D0"
  write(ilun,format)"  real(dp)::yield_NSM_alpha = 0.0D0"
  write(ilun,format)"  real(dp)::yield_Ia_rp = 0.0D0"
  write(ilun,format)"  real(dp)::yield_cc_rp = 0.0D0"
  write(ilun,format)"  real(dp)::yield_NSM_rp = 0.0D0"
  write(ilun,format)"  real(dp)::f_ek   =1.0D0     ! Supernovae kinetic energy fraction (only between 0 and 1)"
  write(ilun,format)"  real(dp)::rbubble=0.0D0     ! Supernovae superbubble radius in pc"
  write(ilun,format)"  real(dp)::f_w    =0.0D0     ! Supernovae mass loading factor"
  write(ilun,format)"  integer ::ndebris=1         ! Supernovae debris particle number"
  write(ilun,format)"  real(dp)::mass_gmc=-1.0     ! Stochastic exploding GMC mass"
  write(ilun,format)"  real(dp)::z_ave  =0.0D0     ! Average metal abundance of iron peak elements"
  write(ilun,format)"  real(dp)::z_ave_alpha = 0.0D0 !Average metal abundance of alpha elements"
  write(ilun,format)"  real(dp)::z_ave_rp =0.0D0   ! Average metalicity of r-process elements"
  write(ilun,format)"  real(dp)::B_ave  =0.0D0     ! Average magnetic field"
  write(ilun,format)"  real(dp)::z_reion=8.5D0     ! Reionization redshift"
  write(ilun,format)"  real(dp)::T2_start          ! Starting gas temperature"
  write(ilun,format)"  real(dp)::t_delay=1.0D1     ! Feedback time delay in Myr"
  write(ilun,format)"  real(dp)::t_diss =20.0D0    ! Dissipation timescale for feedback"
  write(ilun,format)"  real(dp)::t_sne =10.0D0     ! Supernova blast time"
  write(ilun,format)"  real(dp)::J21    =0.0D0     ! UV flux at threshold in 10^21 units"
  write(ilun,format)"  real(dp)::a_spec =1.0D0     ! Slope of the UV spectrum"
  write(ilun,format)"  real(dp)::beta_fix=0.0D0    ! Pressure fix parameter"
  write(ilun,format)"  real(dp)::kappa_IR=0d0      ! IR dust opacity"
  write(ilun,format)"  real(dp)::ind_rsink=4.0d0   ! Number of cells defining the radius of the sphere where AGN feedback is active"
  write(ilun,format)"  real(dp)::ir_eff=0.75       ! efficiency of the IR feedback (only when ir_feedback=.true.)"
  write(ilun,format)"  real(dp)::sf_trelax=0.0D0   ! Relaxation time for star formation (cosmo=.false. only)"
  write(ilun,format)"  real(dp)::sf_tdiss=0.0D0    ! Dissipation timescale for subgrid turbulence in units of turbulent crossing time"
  write(ilun,format)"  integer::sf_model=3         ! Virial star formation model"
  write(ilun,format)"  integer::nlevel_collapse=3  ! Number of levels to follow initial dark matter collapse (cosmo=.true. only)"
  write(ilun,format)"  real(dp)::mass_star_max=120.0D0 ! Maximum mass of a star in solar mass"
  write(ilun,format)"  real(dp)::mass_sne_min=10.0D0   ! Minimum mass of a single supernova in solar mass"
  write(ilun,format)"  logical::momentum_feedback=.false. ! Use supernovae momentum feedback if cooling radius not resolved"
  write(ilun,format)""
  write(ilun,format)"  logical ::self_shielding=.false."
  write(ilun,format)"  logical ::pressure_fix=.false."
  write(ilun,format)"  logical ::nordlund_fix=.true."
  write(ilun,format)"  logical ::cooling=.false."
  write(ilun,format)"  logical ::neq_chem=.false.  ! Non-equilbrium chemistry activated"
  write(ilun,format)"  logical ::isothermal=.false."
  write(ilun,format)"  logical ::metal=.false."
  write(ilun,format)"  logical ::haardt_madau=.false."
  write(ilun,format)"  logical ::delayed_cooling=.false."
  write(ilun,format)"  logical ::smbh=.false."
  write(ilun,format)"  logical ::agn=.false."
  write(ilun,format)"  logical ::use_proper_time=.false."
  write(ilun,format)"  logical ::convert_birth_times=.false. ! Convert stellar birthtimes: conformal -> proper"
  write(ilun,format)"  logical ::ir_feedback=.false. ! Activate ir feedback from accreting sinks"
  write(ilun,format)"  logical ::sf_virial=.false.   ! Activate SF Virial criterion"
  write(ilun,format)"  logical ::sf_log_properties=.false. ! Log in ascii files birth properties of stars and supernovae"
  write(ilun,format)"  logical ::sf_imf=.false.      ! Activate IMF sampling for SN feedback when resolution allows it"
  write(ilun,format)"  logical ::sf_compressive=.false. ! Advect compressive and solenoidal turbulence terms separately"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! Output times"
  write(ilun,format)"  real(dp),dimension(1:MAXOUT)::aout=1.1       ! Output expansion factors"
  write(ilun,format)"  real(dp),dimension(1:MAXOUT)::tout=0.0       ! Output times"
  write(ilun,format)""
  write(ilun,format)"  ! Movie"
  write(ilun,format)"  integer,parameter::NMOV=5"
  write(ilun,format)"  integer::imovout=0             ! Increment for output times"
  write(ilun,format)"  integer::imov=1                ! Initialize"
  write(ilun,format)"  real(kind=8)::tstartmov=0.,astartmov=0."
  write(ilun,format)"  real(kind=8)::tendmov=0.,aendmov=0."
  write(ilun,format)"  real(kind=8),allocatable,dimension(:)::amovout,tmovout"
  write(ilun,format)"  logical::movie=.false."
  write(ilun,format)"  integer::nw_frame=512 ! prev: nx_frame, width of frame in pixels"
  write(ilun,format)"  integer::nh_frame=512 ! prev: ny_frame, height of frame in pixels"
  write(ilun,format)"  integer::levelmax_frame=0"
  write(ilun,format)"  real(kind=8),dimension(1:4*NMOV)::xcentre_frame=0d0"
  write(ilun,format)"  real(kind=8),dimension(1:4*NMOV)::ycentre_frame=0d0"
  write(ilun,format)"  real(kind=8),dimension(1:4*NMOV)::zcentre_frame=0d0"
  write(ilun,format)"  real(kind=8),dimension(1:2*NMOV)::deltax_frame=0d0"
  write(ilun,format)"  real(kind=8),dimension(1:2*NMOV)::deltay_frame=0d0"
  write(ilun,format)"  real(kind=8),dimension(1:2*NMOV)::deltaz_frame=0d0"
  write(ilun,format)"  real(kind=8),dimension(1:NMOV)::dtheta_camera=0d0"
  write(ilun,format)"  real(kind=8),dimension(1:NMOV)::dphi_camera=0d0"
  write(ilun,format)"  real(kind=8),dimension(1:NMOV)::theta_camera=0d0"
  write(ilun,format)"  real(kind=8),dimension(1:NMOV)::phi_camera=0d0"
  write(ilun,format)"  real(kind=8),dimension(1:NMOV)::tstart_theta_camera=0d0"
  write(ilun,format)"  real(kind=8),dimension(1:NMOV)::tstart_phi_camera=0d0"
  write(ilun,format)"  real(kind=8),dimension(1:NMOV)::tend_theta_camera=0d0"
  write(ilun,format)"  real(kind=8),dimension(1:NMOV)::tend_phi_camera=0d0"
  write(ilun,format)"  real(kind=8),dimension(1:NMOV)::focal_camera=0d0"
  write(ilun,format)"  real(kind=8),dimension(1:NMOV)::dist_camera=0d0"
  write(ilun,format)"  real(kind=8),dimension(1:NMOV)::ddist_camera=0d0"
  write(ilun,format)"  real(kind=8),dimension(1:NMOV)::smooth_frame=1d0"
  write(ilun,format)"  real(kind=8),dimension(1:NMOV)::varmin_frame=-1d60"
  write(ilun,format)"  real(kind=8),dimension(1:NMOV)::varmax_frame=1d60"
  write(ilun,format)"  integer,dimension(1:NMOV)::ivar_frame=0"
  write(ilun,format)"  logical,dimension(1:NMOV)::perspective_camera=.false."
  write(ilun,format)"  logical,dimension(1:NMOV)::zoom_only_frame=.false."
  write(ilun,format)"  character(LEN=NMOV)::proj_axis='z' ! x->x, y->y, projection along z"
  write(ilun,format)"  character(LEN=6),dimension(1:NMOV)::shader_frame='square'"
  write(ilun,format)"  character(LEN=10),dimension(1:NMOV)::method_frame='mean_mass'"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"  integer,dimension(0:NVAR+7)::movie_vars=0"
  write(ilun,format)"  character(len=5),dimension(0:NVAR+7)::movie_vars_txt=''"
  write(ilun,format)"#else"
  write(ilun,format)"  integer,dimension(0:NVAR+3)::movie_vars=0"
  write(ilun,format)"  character(len=5),dimension(0:NVAR+3)::movie_vars_txt=''"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  ! Refinement parameters for each level"
  write(ilun,format)"  real(dp),dimension(1:MAXLEVEL)::m_refine =-1.0 ! Lagrangian threshold"
  write(ilun,format)"  real(dp),dimension(1:MAXLEVEL)::r_refine =-1.0 ! Radius of refinement region"
  write(ilun,format)"  real(dp),dimension(1:MAXLEVEL)::x_refine = 0.0 ! Center of refinement region"
  write(ilun,format)"  real(dp),dimension(1:MAXLEVEL)::y_refine = 0.0 ! Center of refinement region"
  write(ilun,format)"  real(dp),dimension(1:MAXLEVEL)::z_refine = 0.0 ! Center of refinement region"
  write(ilun,format)"  real(dp),dimension(1:MAXLEVEL)::exp_refine = 2.0 ! Exponent for distance"
  write(ilun,format)"  real(dp),dimension(1:MAXLEVEL)::a_refine = 1.0 ! Ellipticity (Y/X)"
  write(ilun,format)"  real(dp),dimension(1:MAXLEVEL)::b_refine = 1.0 ! Ellipticity (Z/X)"
  write(ilun,format)"  real(dp)::var_cut_refine=-1.0 ! Threshold for variable-based refinement"
  write(ilun,format)"  real(dp)::mass_cut_refine=-1.0 ! Mass threshold for particle-based refinement"
  write(ilun,format)"  integer::ivar_refine=-1 ! Variable index for refinement"
  write(ilun,format)"  logical::sink_refine=.false. ! Fully refine on sink particles"
  write(ilun,format)""
  write(ilun,format)"  ! Initial condition files for each level"
  write(ilun,format)"  logical::multiple=.false."
  write(ilun,format)"  character(LEN=80),dimension(1:MAXLEVEL)::initfile=' '"
  write(ilun,format)"  character(LEN=20)::filetype='ascii'"
  write(ilun,format)""
  write(ilun,format)"  ! Initial condition regions parameters"
  write(ilun,format)"  integer,parameter::MAXREGION=100"
  write(ilun,format)"  integer                           ::nregion=0"
  write(ilun,format)"  character(LEN=10),dimension(1:MAXREGION)::region_type='square'"
  write(ilun,format)"  real(dp),dimension(1:MAXREGION)   ::x_center=0."
  write(ilun,format)"  real(dp),dimension(1:MAXREGION)   ::y_center=0."
  write(ilun,format)"  real(dp),dimension(1:MAXREGION)   ::z_center=0."
  write(ilun,format)"  real(dp),dimension(1:MAXREGION)   ::length_x=1.E10"
  write(ilun,format)"  real(dp),dimension(1:MAXREGION)   ::length_y=1.E10"
  write(ilun,format)"  real(dp),dimension(1:MAXREGION)   ::length_z=1.E10"
  write(ilun,format)"  real(dp),dimension(1:MAXREGION)   ::exp_region=2.0"
  write(ilun,format)""
  write(ilun,format)"  ! Boundary conditions parameters"
  write(ilun,format)"  integer,parameter::MAXBOUND=100"
  write(ilun,format)"  logical                           ::simple_boundary=.false."
  write(ilun,format)"  integer                           ::nboundary=0"
  write(ilun,format)"  integer                           ::icoarse_min=0"
  write(ilun,format)"  integer                           ::icoarse_max=0"
  write(ilun,format)"  integer                           ::jcoarse_min=0"
  write(ilun,format)"  integer                           ::jcoarse_max=0"
  write(ilun,format)"  integer                           ::kcoarse_min=0"
  write(ilun,format)"  integer                           ::kcoarse_max=0"
  write(ilun,format)"  integer ,dimension(1:MAXBOUND)    ::boundary_type=0"
  write(ilun,format)"  integer ,dimension(1:MAXBOUND)    ::ibound_min=0"
  write(ilun,format)"  integer ,dimension(1:MAXBOUND)    ::ibound_max=0"
  write(ilun,format)"  integer ,dimension(1:MAXBOUND)    ::jbound_min=0"
  write(ilun,format)"  integer ,dimension(1:MAXBOUND)    ::jbound_max=0"
  write(ilun,format)"  integer ,dimension(1:MAXBOUND)    ::kbound_min=0"
  write(ilun,format)"  integer ,dimension(1:MAXBOUND)    ::kbound_max=0"
  write(ilun,format)"  logical                           ::no_inflow=.false."
  write(ilun,format)""
  write(ilun,format)"  !Number of processes sharing one token"
  write(ilun,format)"  !Only one process can write at a time in an I/O group"
  write(ilun,format)"  integer::IOGROUPSIZE=0           ! Main snapshot"
  write(ilun,format)"  integer::IOGROUPSIZECONE=0       ! Lightcone"
  write(ilun,format)"  integer::IOGROUPSIZEREP=0        ! Subfolder size"
  write(ilun,format)"  logical::withoutmkdir=.false.    !If true mkdir should be done before the run"
  write(ilun,format)"  logical::print_when_io=.false.   !If true print when IO"
  write(ilun,format)"  logical::synchro_when_io=.false. !If true synchronize when IO"
  write(ilun,format)""
  write(ilun,format)"  ! CC parameters"
  write(ilun,format)"  real(dp)::RandEXP=0.5"
  write(ilun,format)"  real(dp)::rhocool, Pc, rc, xwind, ywind, zwind"
  write(ilun,format)"  real(dp)::vin,Mdot_in,Tin_K,logLAGN,alph,r0,h,gam"
  write(ilun,format)"  real(dp)::E_SN_th, P_SN_rad, E_SN_kin, sn_rate, Ia_vs_NSM,conversion_NSM, conversion_Ia, t_delay_NSM, H_NSM, t_delay_Ia, H_Ia"
  write(ilun,format)"  character(LEN=160)::medium_type, grid_file, random_file"
  write(ilun,format)"  integer::nblast_current=1,nblast_current_internal,nsnr"
  write(ilun,format)"  integer,allocatable,dimension(:)::marker"
  write(ilun,format)"  logical, save:: init_marker=.false.  "
  write(ilun,format)"  integer::nrandom=500000"
  write(ilun,format)"  real(dp),dimension(1:500000)::random_expl,x_expl,y_expl,z_expl,random_NSM, random_Ia, dice"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"end module amr_parameters"
  write(ilun,format)"../patch/hydro/stratified_medium_fx_NSM/amr_step.f90"
  write(ilun,format)"recursive subroutine amr_step(ilevel,icount)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use poisson_commons"
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"  use rt_hydro_commons"
  write(ilun,format)"  use SED_module"
  write(ilun,format)"  use UV_module"
  write(ilun,format)"  use coolrates_module, only: update_coolrates_tables"
  write(ilun,format)"  use rt_cooling_module, only: update_UVrates"
  write(ilun,format)"#endif"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"  integer::mpi_err"
  write(ilun,format)"#endif"
  write(ilun,format)"  integer::ilevel,icount"
  write(ilun,format)"  !-------------------------------------------------------------------!"
  write(ilun,format)"  ! This routine is the adaptive-mesh/adaptive-time-step main driver. !"
  write(ilun,format)"  ! Each routine is called using a specific order, don't change it,   !"
  write(ilun,format)"  ! unless you check all consequences first                           !"
  write(ilun,format)"  !-------------------------------------------------------------------!"
  write(ilun,format)"  integer::i,idim,ivar"
  write(ilun,format)"  logical::ok_defrag,output_now_all"
  write(ilun,format)"  logical,save::first_step=.true."
  write(ilun,format)""
  write(ilun,format)"  if(numbtot(1,ilevel)==0)return"
  write(ilun,format)""
  write(ilun,format)"  if(verbose)write(*,999)icount,ilevel"
  write(ilun,format)""
  write(ilun,format)"  !-------------------------------------------"
  write(ilun,format)"  ! Make new refinements and update boundaries"
  write(ilun,format)"  !-------------------------------------------"
  write(ilun,format)"                               call timer('refine','start')"
  write(ilun,format)"  if(levelmin.lt.nlevelmax .and.(.not.static.or.(nstep_coarse_old.eq.nstep_coarse.and.restart_remap)))then"
  write(ilun,format)"     if(ilevel==levelmin.or.icount>1)then"
  write(ilun,format)"        do i=ilevel,nlevelmax"
  write(ilun,format)"           if(i>levelmin)then"
  write(ilun,format)""
  write(ilun,format)"              !--------------------------"
  write(ilun,format)"              ! Build communicators"
  write(ilun,format)"              !--------------------------"
  write(ilun,format)"              call build_comm(i)"
  write(ilun,format)""
  write(ilun,format)"              !--------------------------"
  write(ilun,format)"              ! Update boundaries"
  write(ilun,format)"              !--------------------------"
  write(ilun,format)"              call make_virtual_fine_int(cpu_map(1),i)"
  write(ilun,format)"              if(hydro)then"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"                 do ivar=1,nvar+3"
  write(ilun,format)"#else"
  write(ilun,format)"                 do ivar=1,nvar"
  write(ilun,format)"#endif"
  write(ilun,format)"                    call make_virtual_fine_dp(uold(1,ivar),i)"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"                 end do"
  write(ilun,format)"#else"
  write(ilun,format)"                 end do"
  write(ilun,format)"#endif"
  write(ilun,format)"                 if(momentum_feedback)call make_virtual_fine_dp(pstarold(1),i)"
  write(ilun,format)"                 if(simple_boundary)call make_boundary_hydro(i)"
  write(ilun,format)"              end if"
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"              if(rt)then"
  write(ilun,format)"                 do ivar=1,nrtvar"
  write(ilun,format)"                    call make_virtual_fine_dp(rtuold(1,ivar),i)"
  write(ilun,format)"                 end do"
  write(ilun,format)"                 if(simple_boundary)call rt_make_boundary_hydro(i)"
  write(ilun,format)"              end if"
  write(ilun,format)"#endif"
  write(ilun,format)"              if(poisson)then"
  write(ilun,format)"                 call make_virtual_fine_dp(phi(1),i)"
  write(ilun,format)"                 do idim=1,ndim"
  write(ilun,format)"                    call make_virtual_fine_dp(f(1,idim),i)"
  write(ilun,format)"                 end do"
  write(ilun,format)"                 if(simple_boundary)call make_boundary_force(i)"
  write(ilun,format)"              end if"
  write(ilun,format)"           end if"
  write(ilun,format)""
  write(ilun,format)"           !--------------------------"
  write(ilun,format)"           ! Refine grids"
  write(ilun,format)"           !--------------------------"
  write(ilun,format)"           call refine_fine(i)"
  write(ilun,format)"        end do"
  write(ilun,format)"     end if"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  !--------------------------"
  write(ilun,format)"  ! Load balance"
  write(ilun,format)"  !--------------------------"
  write(ilun,format)"                               call timer('load balance','start')"
  write(ilun,format)"  ok_defrag=.false."
  write(ilun,format)"  if(levelmin.lt.nlevelmax)then"
  write(ilun,format)"     if(ilevel==levelmin)then"
  write(ilun,format)"        if(nremap>0)then"
  write(ilun,format)"           ! Skip first load balance because it has been performed before file dump"
  write(ilun,format)"           if(nrestart>0.and.first_step)then"
  write(ilun,format)"              if(nrestart.eq.nrestart_quad) restart_remap=.true."
  write(ilun,format)"              if(restart_remap) then"
  write(ilun,format)"                 call load_balance"
  write(ilun,format)"                 call defrag"
  write(ilun,format)"                 ok_defrag=.true."
  write(ilun,format)"              endif"
  write(ilun,format)"              first_step=.false."
  write(ilun,format)"           else"
  write(ilun,format)"              if(MOD(nstep_coarse,nremap)==0)then"
  write(ilun,format)"                 call load_balance"
  write(ilun,format)"                 call defrag"
  write(ilun,format)"                 ok_defrag=.true."
  write(ilun,format)"              endif"
  write(ilun,format)"           end if"
  write(ilun,format)"        end if"
  write(ilun,format)"     endif"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  !-----------------"
  write(ilun,format)"  ! Update sink cloud particle properties"
  write(ilun,format)"  !-----------------"
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)"                               call timer('sinks','start')"
  write(ilun,format)"  if(sink)call update_cloud(ilevel)"
  write(ilun,format)"#endif"
  write(ilun,format)"  !-----------------"
  write(ilun,format)"  ! Particle leakage"
  write(ilun,format)"  !-----------------"
  write(ilun,format)"                               call timer('particles','start')"
  write(ilun,format)"  if(pic)call make_tree_fine(ilevel)"
  write(ilun,format)""
  write(ilun,format)"  !------------------------"
  write(ilun,format)"  ! Output results to files"
  write(ilun,format)"  !------------------------"
  write(ilun,format)"  if(ilevel==levelmin)then"
  write(ilun,format)""
  write(ilun,format)"#ifdef WITHOUTMPI"
  write(ilun,format)"     output_now_all = output_now"
  write(ilun,format)"#else"
  write(ilun,format)"     ! check if any of the processes received a signal for output"
  write(ilun,format)"     call MPI_BARRIER(MPI_COMM_WORLD,mpi_err)"
  write(ilun,format)"     call MPI_ALLREDUCE(output_now,output_now_all,1,MPI_LOGICAL,MPI_LOR,MPI_COMM_WORLD,mpi_err)"
  write(ilun,format)"#endif"
  write(ilun,format)"     if(mod(nstep_coarse,foutput)==0.or.aexp>=aout(iout).or.t>=tout(iout).or.output_now_all.EQV..true.)then"
  write(ilun,format)"                               call timer('io','start')"
  write(ilun,format)"        if(.not.ok_defrag)then"
  write(ilun,format)"           call defrag"
  write(ilun,format)"        endif"
  write(ilun,format)""
  write(ilun,format)"        ! Run the clumpfinder, (produce output, don't keep arrays alive on output)"
  write(ilun,format)"        ! CAREFUL: create_output is used to destinguish between the case where"
  write(ilun,format)"        ! the clumpfinder is called from create_sink or directly from amr_step."
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)"        if(clumpfind .and. ndim==3) call clump_finder(.true.,.false.)"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"        call dump_all"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"        ! Dump lightcone"
  write(ilun,format)"        if(lightcone .and. ndim==3) call output_cone()"
  write(ilun,format)""
  write(ilun,format)"        if (output_now_all.EQV..true.) then"
  write(ilun,format)"          output_now=.false."
  write(ilun,format)"        endif"
  write(ilun,format)""
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  !----------------------------"
  write(ilun,format)"  ! Output frame to movie dump (without synced levels)"
  write(ilun,format)"  !----------------------------"
  write(ilun,format)"  if(movie) then"
  write(ilun,format)"     if(imov.le.imovout)then"
  write(ilun,format)"        if(aexp>=amovout(imov).or.t>=tmovout(imov))then"
  write(ilun,format)"                               call timer('movie','start')"
  write(ilun,format)"           call output_frame()"
  write(ilun,format)"        endif"
  write(ilun,format)"     endif"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  !-----------------------------------------------------------"
  write(ilun,format)"  ! Put here all stuffs that are done only at coarse time step"
  write(ilun,format)"  !-----------------------------------------------------------"
  write(ilun,format)"  if(ilevel==levelmin)then"
  write(ilun,format)"     !----------------------------------------------------"
  write(ilun,format)"     ! Kinetic feedback from giant molecular clouds"
  write(ilun,format)"     !----------------------------------------------------"
  write(ilun,format)"                               call timer('feedback','start')"
  write(ilun,format)"     if(hydro.and.star.and.eta_sn>0.and.f_w>0)call kinetic_feedback"
  write(ilun,format)""
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  !--------------------"
  write(ilun,format)"  ! Poisson source term"
  write(ilun,format)"  !--------------------"
  write(ilun,format)"  if(poisson)then"
  write(ilun,format)"                               call timer('poisson','start')"
  write(ilun,format)"     !save old potential for time-extrapolation at level boundaries"
  write(ilun,format)"     call save_phi_old(ilevel)"
  write(ilun,format)"                               call timer('rho','start')"
  write(ilun,format)"     call rho_fine(ilevel,icount)"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  !-------------------------------------------"
  write(ilun,format)"  ! Sort particles between ilevel and ilevel+1"
  write(ilun,format)"  !-------------------------------------------"
  write(ilun,format)"  if(pic)then"
  write(ilun,format)"     ! Remove particles to finer levels"
  write(ilun,format)"                               call timer('particles','start')"
  write(ilun,format)"     call kill_tree_fine(ilevel)"
  write(ilun,format)"     ! Update boundary conditions for remaining particles"
  write(ilun,format)"     call virtual_tree_fine(ilevel)"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  !---------------"
  write(ilun,format)"  ! Gravity update"
  write(ilun,format)"  !---------------"
  write(ilun,format)"  if(poisson)then"
  write(ilun,format)"                               call timer('poisson','start')"
  write(ilun,format)""
  write(ilun,format)"     ! Remove gravity source term with half time step and old force"
  write(ilun,format)"     if(hydro)then"
  write(ilun,format)"        call synchro_hydro_fine(ilevel,-0.5*dtnew(ilevel))"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     ! Compute gravitational potential"
  write(ilun,format)"     if(ilevel>levelmin)then"
  write(ilun,format)"        if(ilevel .ge. cg_levelmin) then"
  write(ilun,format)"           call phi_fine_cg(ilevel,icount)"
  write(ilun,format)"        else"
  write(ilun,format)"           call multigrid_fine(ilevel,icount)"
  write(ilun,format)"        end if"
  write(ilun,format)"     else"
  write(ilun,format)"        call multigrid_fine(levelmin,icount)"
  write(ilun,format)"     end if"
  write(ilun,format)"     !when there is no old potential..."
  write(ilun,format)"     if (nstep==0)call save_phi_old(ilevel)"
  write(ilun,format)""
  write(ilun,format)"     ! Compute gravitational acceleration"
  write(ilun,format)"     call force_fine(ilevel,icount)"
  write(ilun,format)""
  write(ilun,format)"     ! Synchronize remaining particles for gravity"
  write(ilun,format)"     if(pic)then"
  write(ilun,format)"                               call timer('particles','start')"
  write(ilun,format)"        if(static_dm.or.static_stars)then"
  write(ilun,format)"           call synchro_fine_static(ilevel)"
  write(ilun,format)"        else"
  write(ilun,format)"           call synchro_fine(ilevel)"
  write(ilun,format)"        end if"
  write(ilun,format)"     end if"
  write(ilun,format)""
  write(ilun,format)"     if(hydro)then"
  write(ilun,format)"                               call timer('poisson','start')"
  write(ilun,format)""
  write(ilun,format)"        ! Add gravity source term with half time step and new force"
  write(ilun,format)"        call synchro_hydro_fine(ilevel,+0.5*dtnew(ilevel))"
  write(ilun,format)""
  write(ilun,format)"        ! Update boundaries"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"        do ivar=1,nvar+3"
  write(ilun,format)"#else"
  write(ilun,format)"        do ivar=1,nvar"
  write(ilun,format)"#endif"
  write(ilun,format)"           call make_virtual_fine_dp(uold(1,ivar),ilevel)"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"        end do"
  write(ilun,format)"#else"
  write(ilun,format)"        end do"
  write(ilun,format)"#endif"
  write(ilun,format)"        if(simple_boundary)call make_boundary_hydro(ilevel)"
  write(ilun,format)""
  write(ilun,format)"        ! Compute Bondi-Hoyle accretion parameters"
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)"                               call timer('sinks','start')"
  write(ilun,format)"        if(sink)call collect_acczone_avg(ilevel)"
  write(ilun,format)"#endif"
  write(ilun,format)"     end if"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"  ! Turn on RT in case of rt_stars and first stars just created:"
  write(ilun,format)"  ! Update photon packages according to star particles"
  write(ilun,format)"                               call timer('radiative transfer','start')"
  write(ilun,format)"  if(rt .and. rt_star) call update_star_RT_feedback(ilevel)"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  ! This routine checks if a SNR is exploding and then"
  write(ilun,format)"  ! injects the amount of thermal+kinetic energy specified by the user."
  write(ilun,format)"  if(hydro)call blast_wave_feedback(ilevel,icount)"
  write(ilun,format)"  "
  write(ilun,format)"  !----------------------"
  write(ilun,format)"  ! Compute new time step"
  write(ilun,format)"  !----------------------"
  write(ilun,format)"                               call timer('courant','start')"
  write(ilun,format)"  call newdt_fine(ilevel)"
  write(ilun,format)"  if(ilevel>levelmin)then"
  write(ilun,format)"     dtnew(ilevel)=MIN(dtnew(ilevel-1)/real(nsubcycle(ilevel-1)),dtnew(ilevel))"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  ! Set unew equal to uold"
  write(ilun,format)"                               call timer('hydro - set unew','start')"
  write(ilun,format)"  if(hydro)call set_unew(ilevel)"
  write(ilun,format)""
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"  ! Set rtunew equal to rtuold"
  write(ilun,format)"                               call timer('radiative transfer','start')"
  write(ilun,format)"  if(rt)call rt_set_unew(ilevel)"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  !---------------------------"
  write(ilun,format)"  ! Recursive call to amr_step"
  write(ilun,format)"  !---------------------------"
  write(ilun,format)"  if(ilevel<nlevelmax)then"
  write(ilun,format)"     if(numbtot(1,ilevel+1)>0)then"
  write(ilun,format)"        if(nsubcycle(ilevel)==2)then"
  write(ilun,format)"           call amr_step(ilevel+1,1)"
  write(ilun,format)"           call amr_step(ilevel+1,2)"
  write(ilun,format)"        else"
  write(ilun,format)"           call amr_step(ilevel+1,1)"
  write(ilun,format)"        endif"
  write(ilun,format)"     else"
  write(ilun,format)"        ! Otherwise, update time and finer level time-step"
  write(ilun,format)"        dtold(ilevel+1)=dtnew(ilevel)/dble(nsubcycle(ilevel))"
  write(ilun,format)"        dtnew(ilevel+1)=dtnew(ilevel)/dble(nsubcycle(ilevel))"
  write(ilun,format)"        call update_time(ilevel)"
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)"        if(sink)call update_sink(ilevel)"
  write(ilun,format)"#endif"
  write(ilun,format)"     end if"
  write(ilun,format)"  else"
  write(ilun,format)"     call update_time(ilevel)"
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)"     if(sink)call update_sink(ilevel)"
  write(ilun,format)"#endif"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  ! Thermal feedback from stars"
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)"                               call timer('feedback','start')"
  write(ilun,format)"  if(hydro.and.star.and.eta_sn>0)call thermal_feedback(ilevel)"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  ! Density threshold or Bondi accretion onto sink particle"
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)"  if(sink)then"
  write(ilun,format)"                               call timer('sinks','start')"
  write(ilun,format)"     call grow_sink(ilevel,.false.)"
  write(ilun,format)"  end if"
  write(ilun,format)"#endif"
  write(ilun,format)"  !-----------"
  write(ilun,format)"  ! Hydro step"
  write(ilun,format)"  !-----------"
  write(ilun,format)"  if((hydro).and.(.not.static_gas))then"
  write(ilun,format)""
  write(ilun,format)"     ! Hyperbolic solver"
  write(ilun,format)"                               call timer('hydro - godunov','start')"
  write(ilun,format)"     call godunov_fine(ilevel)"
  write(ilun,format)""
  write(ilun,format)"     ! Reverse update boundaries"
  write(ilun,format)"                               call timer('hydro - rev ghostzones','start')"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"     do ivar=1,nvar+3"
  write(ilun,format)"#else"
  write(ilun,format)"     do ivar=1,nvar"
  write(ilun,format)"#endif"
  write(ilun,format)"        call make_virtual_reverse_dp(unew(1,ivar),ilevel)"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"     end do"
  write(ilun,format)"#else"
  write(ilun,format)"     end do"
  write(ilun,format)"#endif"
  write(ilun,format)"     if(momentum_feedback)then"
  write(ilun,format)"        call make_virtual_reverse_dp(pstarnew(1),ilevel)"
  write(ilun,format)"     endif"
  write(ilun,format)"     if(pressure_fix)then"
  write(ilun,format)"        call make_virtual_reverse_dp(enew(1),ilevel)"
  write(ilun,format)"        call make_virtual_reverse_dp(divu(1),ilevel)"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     ! Set uold equal to unew"
  write(ilun,format)"                               call timer('hydro - set uold','start')"
  write(ilun,format)"     call set_uold(ilevel)"
  write(ilun,format)""
  write(ilun,format)"     ! Add gravity source term with half time step and old force"
  write(ilun,format)"     ! in order to complete the time step"
  write(ilun,format)"                               call timer('poisson','start')"
  write(ilun,format)"     if(poisson)call synchro_hydro_fine(ilevel,+0.5*dtnew(ilevel))"
  write(ilun,format)""
  write(ilun,format)"     ! Restriction operator"
  write(ilun,format)"                               call timer('hydro upload fine','start')"
  write(ilun,format)"     call upload_fine(ilevel)"
  write(ilun,format)""
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  !---------------------"
  write(ilun,format)"  ! Do RT/Chemistry step"
  write(ilun,format)"  !---------------------"
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"  if(rt .and. rt_advect) then"
  write(ilun,format)"                               call timer('radiative transfer','start')"
  write(ilun,format)"     call rt_step(ilevel)"
  write(ilun,format)"  else"
  write(ilun,format)"     ! Still need a chemistry call if RT is defined but not"
  write(ilun,format)"     ! actually doing radiative transfer (i.e. rt==false):"
  write(ilun,format)"                               call timer('cooling','start')"
  write(ilun,format)"     if(neq_chem.or.cooling.or.T2_star>0.0)call cooling_fine(ilevel)"
  write(ilun,format)"  endif"
  write(ilun,format)"  ! Regular updates and book-keeping:"
  write(ilun,format)"  if(ilevel==levelmin) then"
  write(ilun,format)"                               call timer('radiative transfer','start')"
  write(ilun,format)"     if(cosmo) call update_rt_c"
  write(ilun,format)"     if(cosmo .and. haardt_madau) call update_UVrates(aexp)"
  write(ilun,format)"     if(cosmo .and. rt_isDiffuseUVsrc) call update_UVsrc"
  write(ilun,format)"                               call timer('cooling','start')"
  write(ilun,format)"     if(cosmo) call update_coolrates_tables(dble(aexp))"
  write(ilun,format)"                               call timer('radiative transfer','start')"
  write(ilun,format)"     if(ilevel==levelmin) call output_rt_stats"
  write(ilun,format)"  endif"
  write(ilun,format)"#else"
  write(ilun,format)"                               call timer('cooling','start')"
  write(ilun,format)"  if((hydro).and.(.not.static_gas)) then"
  write(ilun,format)"    if(neq_chem.or.cooling.or.T2_star>0.0)call cooling_fine(ilevel)"
  write(ilun,format)"  endif"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  !---------------"
  write(ilun,format)"  ! Move particles"
  write(ilun,format)"  !---------------"
  write(ilun,format)"  if(pic)then"
  write(ilun,format)"                               call timer('particles','start')"
  write(ilun,format)"     if(static_dm.or.static_stars)then"
  write(ilun,format)"        call move_fine_static(ilevel) ! Only remaining particles"
  write(ilun,format)"     else"
  write(ilun,format)"        call move_fine(ilevel) ! Only remaining particles"
  write(ilun,format)"     end if"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  !----------------------------------"
  write(ilun,format)"  ! Star formation in leaf cells only"
  write(ilun,format)"  !----------------------------------"
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)"                               call timer('feedback','start')"
  write(ilun,format)"  if(hydro.and.star.and.(.not.static_gas))call star_formation(ilevel)"
  write(ilun,format)"#endif"
  write(ilun,format)"  !---------------------------------------"
  write(ilun,format)"  ! Update physical and virtual boundaries"
  write(ilun,format)"  !---------------------------------------"
  write(ilun,format)"  if((hydro).and.(.not.static_gas))then"
  write(ilun,format)"                               call timer('hydro - ghostzones','start')"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"     do ivar=1,nvar+3"
  write(ilun,format)"#else"
  write(ilun,format)"     do ivar=1,nvar"
  write(ilun,format)"#endif"
  write(ilun,format)"        call make_virtual_fine_dp(uold(1,ivar),ilevel)"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"     end do"
  write(ilun,format)"#else"
  write(ilun,format)"     end do"
  write(ilun,format)"#endif"
  write(ilun,format)"     if(momentum_feedback)call make_virtual_fine_dp(pstarold(1),ilevel)"
  write(ilun,format)"     if(simple_boundary)call make_boundary_hydro(ilevel)"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"  ! Magnetic diffusion step"
  write(ilun,format)"  if((hydro).and.(.not.static_gas))then"
  write(ilun,format)"     if(eta_mag>0d0.and.ilevel==levelmin)then"
  write(ilun,format)"                               call timer('hydro - diffusion','start')"
  write(ilun,format)"        call diffusion"
  write(ilun,format)"     endif"
  write(ilun,format)"  end if"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  !-----------------------"
  write(ilun,format)"  ! Compute refinement map"
  write(ilun,format)"  !-----------------------"
  write(ilun,format)"                               call timer('flag','start')"
  write(ilun,format)"  if(.not.static.or.(nstep_coarse_old.eq.nstep_coarse.and.restart_remap)) call flag_fine(ilevel,icount)"
  write(ilun,format)""
  write(ilun,format)"  !----------------------------"
  write(ilun,format)"  ! Merge finer level particles"
  write(ilun,format)"  !----------------------------"
  write(ilun,format)"                               call timer('particles','start')"
  write(ilun,format)"  if(pic)call merge_tree_fine(ilevel)"
  write(ilun,format)""
  write(ilun,format)"  !---------------"
  write(ilun,format)"  ! Radiation step"
  write(ilun,format)"  !---------------"
  write(ilun,format)"#ifdef ATON"
  write(ilun,format)"  if(aton.and.ilevel==levelmin)then"
  write(ilun,format)"                               call timer('aton','start')"
  write(ilun,format)"     call rad_step(dtnew(ilevel))"
  write(ilun,format)"  endif"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  if(sink)then"
  write(ilun,format)"                               call timer('sinks','start')"
  write(ilun,format)"     !-------------------------------"
  write(ilun,format)"     ! Update coarser level sink velocity"
  write(ilun,format)"     !-------------------------------"
  write(ilun,format)"     if(ilevel>levelmin)then"
  write(ilun,format)"        vsold(1:nsink,1:ndim,ilevel-1)=vsnew(1:nsink,1:ndim,ilevel-1)"
  write(ilun,format)"        if(nsubcycle(ilevel-1)==1)vsnew(1:nsink,1:ndim,ilevel-1)=vsnew(1:nsink,1:ndim,ilevel)"
  write(ilun,format)"        if(icount==2)vsnew(1:nsink,1:ndim,ilevel-1)= &"
  write(ilun,format)"             (vsold(1:nsink,1:ndim,ilevel)*dtold(ilevel)+vsnew(1:nsink,1:ndim,ilevel)*dtnew(ilevel))/ &"
  write(ilun,format)"             (dtold(ilevel)+dtnew(ilevel))"
  write(ilun,format)"     end if"
  write(ilun,format)"     !---------------"
  write(ilun,format)"     ! Sink production"
  write(ilun,format)"     !---------------"
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)"     if(ilevel==levelmin)call create_sink"
  write(ilun,format)"#endif"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  !-------------------------------"
  write(ilun,format)"  ! Update coarser level time-step"
  write(ilun,format)"  !-------------------------------"
  write(ilun,format)"  if(ilevel>levelmin)then"
  write(ilun,format)"     if(nsubcycle(ilevel-1)==1)dtnew(ilevel-1)=dtnew(ilevel)"
  write(ilun,format)"     if(icount==2)dtnew(ilevel-1)=dtold(ilevel)+dtnew(ilevel)"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"999 format(' Entering amr_step',i1,' for level',i2)"
  write(ilun,format)""
  write(ilun,format)"end subroutine amr_step"
  write(ilun,format)""
  write(ilun,format)"!##########################################################################"
  write(ilun,format)"!##########################################################################"
  write(ilun,format)"!##########################################################################"
  write(ilun,format)"!##########################################################################"
  write(ilun,format)""
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"subroutine rt_step(ilevel)"
  write(ilun,format)"  use amr_parameters, only: dp"
  write(ilun,format)"  use amr_commons,    only: levelmin, t, dtnew, myid"
  write(ilun,format)"  use rt_cooling_module, only: update_UVrates"
  write(ilun,format)"  use rt_hydro_commons"
  write(ilun,format)"  use UV_module"
  write(ilun,format)"  use SED_module,     only: star_RT_feedback"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  integer, intent(in) :: ilevel"
  write(ilun,format)""
  write(ilun,format)"!--------------------------------------------------------------------------"
  write(ilun,format)"!  Radiative transfer and chemistry step. Either do one step on ilevel,"
  write(ilun,format)"!  with radiation field updates in coarser level neighbours, or, if"
  write(ilun,format)"!  rt_nsubsteps>1, do many substeps in ilevel only, using Dirichlet"
  write(ilun,format)"!  boundary conditions for the level boundaries."
  write(ilun,format)"!--------------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  real(dp) :: dt_hydro, t_left, dt_rt, t_save"
  write(ilun,format)"  integer  :: i_substep, ivar"
  write(ilun,format)""
  write(ilun,format)"  dt_hydro = dtnew(ilevel)                   ! Store hydro timestep length"
  write(ilun,format)"  t_left = dt_hydro"
  write(ilun,format)"  ! We shift the time backwards one hydro-dt, to get evolution of stellar"
  write(ilun,format)"  ! ages within the hydro timestep, in the case of rt subcycling:"
  write(ilun,format)"  t_save=t ; t=t-t_left"
  write(ilun,format)""
  write(ilun,format)"  i_substep = 0"
  write(ilun,format)"  do while (t_left > 0)                      !                RT sub-cycle"
  write(ilun,format)"     i_substep = i_substep + 1"
  write(ilun,format)"     call get_rt_courant_coarse(dt_rt)"
  write(ilun,format)"     ! Temporarily change timestep length to rt step:"
  write(ilun,format)"     dtnew(ilevel) = MIN(t_left, dt_rt/2.0**(ilevel-levelmin))"
  write(ilun,format)"     t = t + dtnew(ilevel) ! Shift the time forwards one dt_rt"
  write(ilun,format)""
  write(ilun,format)"     ! If (myid==1) write(*,900) dt_hydro, dtnew(ilevel), i_substep, ilevel"
  write(ilun,format)"     if (i_substep > 1) call rt_set_unew(ilevel)"
  write(ilun,format)""
  write(ilun,format)"     if(rt_star) call star_RT_feedback(ilevel,dtnew(ilevel))"
  write(ilun,format)""
  write(ilun,format)"     ! Hyperbolic solver"
  write(ilun,format)"     if(rt_advect) call rt_godunov_fine(ilevel,dtnew(ilevel))"
  write(ilun,format)""
  write(ilun,format)"     call add_rt_sources(ilevel,dtnew(ilevel))"
  write(ilun,format)""
  write(ilun,format)"     ! Reverse update boundaries"
  write(ilun,format)"     do ivar=1,nrtvar"
  write(ilun,format)"        call make_virtual_reverse_dp(rtunew(1,ivar),ilevel)"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     ! Set rtuold equal to rtunew"
  write(ilun,format)"     call rt_set_uold(ilevel)"
  write(ilun,format)""
  write(ilun,format)"                               call timer('cooling','start')"
  write(ilun,format)"     if(neq_chem.or.cooling.or.T2_star>0.0)call cooling_fine(ilevel)"
  write(ilun,format)"                               call timer('radiative transfer','start')"
  write(ilun,format)""
  write(ilun,format)"     do ivar=1,nrtvar"
  write(ilun,format)"        call make_virtual_fine_dp(rtuold(1,ivar),ilevel)"
  write(ilun,format)"     end do"
  write(ilun,format)"     if(simple_boundary)call rt_make_boundary_hydro(ilevel)"
  write(ilun,format)""
  write(ilun,format)"     t_left = t_left - dtnew(ilevel)"
  write(ilun,format)"  end do                                   !          End RT subcycle loop"
  write(ilun,format)"  dtnew(ilevel) = dt_hydro                 ! Restore hydro timestep length"
  write(ilun,format)"  t = t_save       ! Restore original time (otherwise tiny roundoff error)"
  write(ilun,format)""
  write(ilun,format)"  ! Restriction operator to update coarser level split cells"
  write(ilun,format)"  call rt_upload_fine(ilevel)"
  write(ilun,format)""
  write(ilun,format)"  if (myid==1 .and. rt_nsubcycle .gt. 1) write(*,901) ilevel, i_substep"
  write(ilun,format)""
  write(ilun,format)"  !900 format (' dt_hydro=', 1pe12.3, ' dt_rt=', 1pe12.3, ' i_sub=', I5, ' level=', I5)"
  write(ilun,format)"901 format (' Performed level', I3, ' RT-step with ', I5, ' subcycles')"
  write(ilun,format)""
  write(ilun,format)"end subroutine rt_step"
  write(ilun,format)"#endif"
  write(ilun,format)"../patch/hydro/stratified_medium_fx_NSM/boundana.f90"
  write(ilun,format)"!############################################################"
  write(ilun,format)"!############################################################"
  write(ilun,format)"!############################################################"
  write(ilun,format)"!############################################################"
  write(ilun,format)"subroutine boundana(x,u,ind_cell,x_ref,ind_cell_ref,dx,ibound,ncell)"
  write(ilun,format)"  use amr_parameters, ONLY: dp,ndim,nvector,boxlen,levelmin"
  write(ilun,format)"  use hydro_parameters, ONLY: nvar,boundary_var"
  write(ilun,format)"  use hydro_commons, ONLY: uold,gamma"
  write(ilun,format)"  use poisson_commons, ONLY: f"
  write(ilun,format)"  use poisson_parameters, ONLY: gravity_params"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer ::ibound                        ! Index of boundary region"
  write(ilun,format)"  integer ::ncell                         ! Number of active cells"
  write(ilun,format)"  real(dp)::dx                            ! Cell size"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:nvar)::u ! Conservative variables"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim)::x ! Cell center position."
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim)::x_ref ! Neighboring cell center position."
  write(ilun,format)"  integer,dimension(1:nvector)::ind_cell  ! Cell index"
  write(ilun,format)"  integer,dimension(1:nvector)::ind_cell_ref  ! Neighboring cell index   "
  write(ilun,format)"  !================================================================"
  write(ilun,format)"  ! This routine generates boundary conditions for RAMSES."
  write(ilun,format)"  ! Positions are in user units:"
  write(ilun,format)"  ! x(i,1:3) are in [0,boxlen]**ndim."
  write(ilun,format)"  ! U is the conservative variable vector. Conventions are here:"
  write(ilun,format)"  ! U(i,1): d, U(i,2:ndim+1): d.u,d.v,d.w and U(i,ndim+2): E."
  write(ilun,format)"  ! U is in user units."
  write(ilun,format)"  ! ibound is the index of the boundary region defined in the namelist."
  write(ilun,format)"  !================================================================"
  write(ilun,format)"  integer::ivar,i"
  write(ilun,format)"  real(dp)::switch"
  write(ilun,format)"  real(dp)::mu,XH,a1,a2,z0,T0,rho0,fp"
  write(ilun,format)"  real(dp)::scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2"
  write(ilun,format)"  real(dp)::dz,rhoprime,fprime,dz_,smoothing,smoothing_l,grav"
  write(ilun,format)""
  write(ilun,format)"  ! Conversion factor from user units to cgs units"
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)""
  write(ilun,format)"  ! As in courant_file.f90. "
  write(ilun,format)"  mu = 0.6"
  write(ilun,format)"  XH=0.76"
  write(ilun,format)""
  write(ilun,format)"  ! Parameters of the stratified medium model - set gravity_type=2 too - convert to cgs"
  write(ilun,format)"  a1=gravity_params(1) ! disc component factor"
  write(ilun,format)"  a2=gravity_params(2) ! halo component factor"
  write(ilun,format)"  z0=gravity_params(3) ! scale height of the disc "
  write(ilun,format)"  T0=gravity_params(4) ! temperature in the mid-plane"
  write(ilun,format)"  rho0=gravity_params(5) ! density in the mid-plane g/cm3"
  write(ilun,format)"  a1=a1*3.08d21/(1d6*365.*24.*3600.)**2 ! cm/s2"
  write(ilun,format)"  a2=a2/(1d6*365.*24.*3600.)**2 ! s-2 "
  write(ilun,format)"  z0=z0*3.08d21 ! cm"
  write(ilun,format)"  T0=T0 ! K"
  write(ilun,format)"  fp=0.6*1.66d-24/1.38d-16/T0 ! s2/cm2"
  write(ilun,format)""
  write(ilun,format)"  do i=1,ncell"
  write(ilun,format)"     do ivar=1,nvar"
  write(ilun,format)"        switch=(x(i,3)-boxlen/2.)/abs(x(i,3)-boxlen/2.)"
  write(ilun,format)"        if(ivar.eq.1)then"
  write(ilun,format)"           u(i,ivar)=uold(ind_cell_ref(i),ivar)"
  write(ilun,format)"        end if"
  write(ilun,format)"        if(ivar.gt.1.and.ivar.lt.ndim+1)then"
  write(ilun,format)"           u(i,ivar)=uold(ind_cell_ref(i),ivar)"
  write(ilun,format)"        end if"
  write(ilun,format)"        if(ivar.eq.ndim+1)then"
  write(ilun,format)"           !u(i,ivar)=0.0 ! z velocity at the boundary set to 0"
  write(ilun,format)"           !u(i,ivar)=uold(ind_cell_ref(i),ivar)"
  write(ilun,format)"           if(switch*uold(ind_cell_ref(i),ivar)>0)then"
  write(ilun,format)"              u(i,ivar)=uold(ind_cell_ref(i),ivar)"
  write(ilun,format)"           else"
  write(ilun,format)"              u(i,ivar)=0.0"
  write(ilun,format)"           end if"
  write(ilun,format)"        end if"
  write(ilun,format)"        if(ivar.eq.ndim+2)then"
  write(ilun,format)"           !u(i,ivar)=uold(ind_cell_ref(i),ivar) ! zero pressure gradient"
  write(ilun,format)"           dz=x(i,3)-x_ref(i,3)"
  write(ilun,format)"           fprime=(f(ind_cell(i),3)-f(ind_cell_ref(i),3))/dz ! force gradient"
  write(ilun,format)"           rhoprime=(u(i,1)-uold(ind_cell_ref(i),1))/dz"
  write(ilun,format)"           u(i,ivar)=uold(ind_cell_ref(i),ivar) !+ &"
  write(ilun,format)"                !& dz*uold(ind_cell_ref(i),1)*f(ind_cell_ref(i),3)/(gamma-1.0d0)+ & "
  write(ilun,format)"                !& dz**2/2*uold(ind_cell_ref(i),1)*fprime/(gamma-1.0d0)+ &"
  write(ilun,format)"                !& dz**2/2*rhoprime*f(ind_cell_ref(i),3)/(gamma-1.0d0)+ &"
  write(ilun,format)"                !& dz**3/3*fprime*rhoprime/(gamma-1.0d0)"
  write(ilun,format)"        end if"
  write(ilun,format)"        if(ivar.gt.ndim+2)then"
  write(ilun,format)"           u(i,ivar)=uold(ind_cell_ref(i),ivar)"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"end subroutine boundana"
  write(ilun,format)"../patch/hydro/stratified_medium_fx_NSM/condinit.f90"
  write(ilun,format)"! set NX_LN as preprocessor variable: need to also set in init_flow_fine.f90"
  write(ilun,format)"#define NX_LN 512"
  write(ilun,format)""
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"subroutine condinit(x,u,dx,nn,ln_d)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use poisson_parameters"
  write(ilun,format)"  use random"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  integer ::nn                            ! Number of cells"
  write(ilun,format)"  real(dp)::dx                            ! Cell size"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:nvar)::u ! Conservative variables"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim)::x ! Cell center position."
  write(ilun,format)"  "
  write(ilun,format)"  real*4,dimension(1:NX_LN**3)::ln_d ! hard coding nx_ln"
  write(ilun,format)"  "
  write(ilun,format)""
  write(ilun,format)"  !================================================================"
  write(ilun,format)"  ! This routine generates initial conditions for RAMSES."
  write(ilun,format)"  ! Positions are in user units:"
  write(ilun,format)"  ! x(i,1:3) are in [0,boxlen]**ndim."
  write(ilun,format)"  ! U is the conservative variable vector. Conventions are here:"
  write(ilun,format)"  ! U(i,1): d, U(i,2:ndim+1): d.u,d.v,d.w and U(i,ndim+2): E."
  write(ilun,format)"  ! Q is the primitive variable vector. Conventions are here:"
  write(ilun,format)"  ! Q(i,1): d, Q(i,2:ndim+1):u,v,w and Q(i,ndim+2): P."
  write(ilun,format)"  ! If nvar >= ndim+3, remaining variables are treated as passive"
  write(ilun,format)"  ! scalars in the hydro solver."
  write(ilun,format)"  ! U(:,:) and Q(:,:) are in user units."
  write(ilun,format)"  !================================================================"
  write(ilun,format)"  integer::info"
  write(ilun,format)"  real(dp)::dctr, cs_h, dx_ln"
  write(ilun,format)"  real(dp)::xcell, ycell, zcell, dx_, dy_, dz_, dr, sin_theta"
  write(ilun,format)"  real(dp)::vx_BC, vy_BC, vz_BC, rho_BC, P_BC, disk_fact, lognorm_fact"
  write(ilun,format)"  real(dp)::vri,vxi,vyi,vzi,mu,XH"
  write(ilun,format)"  real(dp)::Ei,Vi,Pi_, M_ej, rho_ej"
  write(ilun,format)"  real(dp)::a1,a2,z0,f,T0,rho0,sigma0"
  write(ilun,format)"  real(dp)::z_lim,rho_lim,smoothing_l,smoothing,reference_disk_fact"
  write(ilun,format)"  real(dp)::grav,potential_true,potential_lim,potential"
  write(ilun,format)""
  write(ilun,format)"  real(dp),parameter:: pi = 3.14159265"
  write(ilun,format)"  real(dp),parameter:: kB = 1.3806200e-16 ! Boltzmann constant, cgs "
  write(ilun,format)""
  write(ilun,format)"  real(dp)::scale, scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v"
  write(ilun,format)""
  write(ilun,format)"  real*4:: tmpvar"
  write(ilun,format)"  character(LEN=160)::infile, inj_type"
  write(ilun,format)"  integer::i,j,k,id,iu,iv,iw,ip, i_ln, j_ln, k_ln, n_ln"
  write(ilun,format)"  !integer,parameter::nx_ln = NX_LN"
  write(ilun,format)"  integer::ivar"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:nvar),save::q   ! Primitive variables"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  dx_ln = 1.0/real(NX_LN,dp)"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! Conversion factor from user units to cgs units"
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)""
  write(ilun,format)"  "
  write(ilun,format)"  if(.not.init_marker)then"
  write(ilun,format)"     nsnr=int(sn_rate*tout(noutput))"
  write(ilun,format)"     allocate(marker(1:nsnr))"
  write(ilun,format)"     marker=0"
  write(ilun,format)"     !marker(1)=1"
  write(ilun,format)"     init_marker=.true. "
  write(ilun,format)"     if (nblast_current==0.and.myid==1)call ranf(localseed,RandEXP)"
  write(ilun,format)"     nblast_current_internal=nblast_current"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"        call MPI_BARRIER(MPI_COMM_WORLD,info)"
  write(ilun,format)"        call MPI_BCAST (RandEXP,1,MPI_DOUBLE_PRECISION,0,MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! Convert SN thermal and kinetic energies from cgs to code units."
  write(ilun,format)"  E_SN_th = E_SN_th/(scale_v**2.0*scale_d*scale_l**3.0) "
  write(ilun,format)"  E_SN_kin = E_SN_kin/(scale_v**2.0*scale_d*scale_l**3.0) "
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! Initial pressure in the injection radius, in code units."
  write(ilun,format)"  !"
  write(ilun,format)"  ! Use for injection in thermal form."
  write(ilun,format)"  Vi = (4.0*pi*rc**3.0)/3.0 ! code units"
  write(ilun,format)""
  write(ilun,format)"  Pi_ = (2.0/3.0)*(E_SN_th/Vi)"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! Density of SN ejecta, assuming uniformly distributed within rc, as"
  write(ilun,format)"  ! in Thornton et al. (1998)."
  write(ilun,format)"  M_ej = 5.97*1E33 ! 3 Msun, cgs"
  write(ilun,format)""
  write(ilun,format)"  ! Mass from cgs to code units."
  write(ilun,format)"  M_ej = M_ej/(scale_d*scale_l**3.0)"
  write(ilun,format)""
  write(ilun,format)"  rho_ej = M_ej/Vi"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! Radial velocity of the gas within rc, so that total kinetic energy"
  write(ilun,format)"  ! is E_SN_kin. To be used for energy injection in kinetic form."
  write(ilun,format)"  vri = (3.0*E_SN_kin/(2.0*pi*(rhocool + rho_ej)*rc**3.0))**0.5"
  write(ilun,format)""
  write(ilun,format)"  ! As in courant_file.f90."
  write(ilun,format)"  mu = 0.6"
  write(ilun,format)"  XH=0.76"
  write(ilun,format)""
  write(ilun,format)"  ! Parameters of the stratified medium model - set gravity_type=2 too - convert to cgs                                                                              "
  write(ilun,format)"  a1=gravity_params(1) ! disc component factor                                                                                                                       "
  write(ilun,format)"  a2=gravity_params(2) ! halo component factor                                                                                                                       "
  write(ilun,format)"  z0=gravity_params(3) ! scale height of the disc                                                                                                                    "
  write(ilun,format)"  T0=gravity_params(4) ! temperature in the mid-plane                                                                                                                "
  write(ilun,format)"  rho0=gravity_params(5) ! density in the mid-plane g/cm3                                                                                                            "
  write(ilun,format)"  a1=a1*3.08d21/(1d6*365.*24.*3600.)**2 ! cm/s2                                                                                                                      "
  write(ilun,format)"  a2=a2/(1d6*365.*24.*3600.)**2 ! s-2                                                                                                                                "
  write(ilun,format)"  z0=z0*3.08d21 ! cm                                                                                                                                                 "
  write(ilun,format)"  T0=T0 ! K                                                                                                                                                          "
  write(ilun,format)"  f=0.6*1.66d-24/1.38d-16/T0 ! s2/cm2                                                                                                                                "
  write(ilun,format)""
  write(ilun,format)"  ! Rescaling factor "
  write(ilun,format)"  scale=dble(icoarse_max-icoarse_min+1)/boxlen"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! Indexes of physical quantities."
  write(ilun,format)"  id = 1"
  write(ilun,format)"  iu = 2"
  write(ilun,format)"  iv = 3"
  write(ilun,format)"  iw = 4"
  write(ilun,format)"  ip = 5"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! Call built-in initial conditions generator: this is for simple"
  write(ilun,format)"  ! 'square' and 'point' regions."
  write(ilun,format)"  call region_condinit(x,q,dx,nn)"
  write(ilun,format)""
  write(ilun,format)"  "
  write(ilun,format)"  ! Dimensionless lognormal field is read in init_flow_fine.f90,"
  write(ilun,format)"  ! which calls this function."
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! Loop through positions for the current sub-grid."
  write(ilun,format)"  do i=1,nn"
  write(ilun,format)""
  write(ilun,format)"    ! Distance from wind source."
  write(ilun,format)"    xcell = x(i,1) "
  write(ilun,format)"    ycell = x(i,2)"
  write(ilun,format)"    zcell = x(i,3)"
  write(ilun,format)""
  write(ilun,format)"    dctr = 1d20!((xcell-xwind)**2.0 + (ycell-ywind)**2.0 + (zcell-zwind)**2.0)**0.5"
  write(ilun,format)""
  write(ilun,format)"    ! This is a code to seed a SN at the center of the box at t=0"
  write(ilun,format)"    ! Uncomment and re-introduce the if-else structure here if you wish to use it"
  write(ilun,format)"    if (dctr<rc) then"
  write(ilun,format)"      ! Within r_c, inject energy of the supernova remmant in thermal"
  write(ilun,format)"      ! form. Must make sure that r_c is well within Sedov radius, to"
  write(ilun,format)"      ! avoid initial energy losses."
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"      ! Velocity components for radial kinetic energy injection."
  write(ilun,format)"      vxi = (xcell - xwind)*vri/dctr"
  write(ilun,format)"      vyi = (ycell - ywind)*vri/dctr"
  write(ilun,format)"      vzi = (zcell - zwind)*vri/dctr"
  write(ilun,format)""
  write(ilun,format)"      q(i,id) = rhocool + rho_ej"
  write(ilun,format)"      q(i,iu) = vxi"
  write(ilun,format)"      q(i,iv) = vyi"
  write(ilun,format)"      q(i,iw) = vzi"
  write(ilun,format)"      q(i,ip) = Pi_"
  write(ilun,format)"      if(metal) then "
  write(ilun,format)"         q(i,6)=z_ave*rhocool/(rhocool + rho_ej)+yield_cc_Fe*rho_ej/(rhocool + rho_ej) ! customized metallicity value."
  write(ilun,format)"         q(i,7)=z_ave_alpha*rhocool/(rhocool + rho_ej)+yield_cc_alpha*rho_ej/(rhocool + rho_ej)"
  write(ilun,format)"         q(i,8)=z_ave_rp*rhocool/(rhocool + rho_ej)+yield_cc_rp*rho_ej/(rhocool + rho_ej)"
  write(ilun,format)"      end if"
  write(ilun,format)"    else "
  write(ilun,format)""
  write(ilun,format)"    "
  write(ilun,format)"       ! Smooth or fractal ambient medium?"
  write(ilun,format)"       if (medium_type=='uni' .or. medium_type=='disk' .or. medium_type=='strat') then"
  write(ilun,format)"          lognorm_fact = 1.0"
  write(ilun,format)"          "
  write(ilun,format)"       else "
  write(ilun,format)"          if (medium_type=='fractal' .or. medium_type=='disk_fractal' .or. medium_type=='strat_fractal') then"
  write(ilun,format)"             "
  write(ilun,format)"             ! Given (x, y, z), find nearest grid point in pre-computed"
  write(ilun,format)"             ! lognormal field."
  write(ilun,format)"             "
  write(ilun,format)"             ! Assume coordinates are from 0 to 1 along each direction."
  write(ilun,format)"             i_ln = int(x(i,1)*scale/dx_ln)+1"
  write(ilun,format)"             j_ln = int(x(i,2)*scale/dx_ln)+1"
  write(ilun,format)"             k_ln = int(x(i,3)*scale/dx_ln)+1"
  write(ilun,format)"             "
  write(ilun,format)"             n_ln = (i_ln-1)*int(NX_LN)**2.0 + (j_ln-1)*int(NX_LN) + k_ln"
  write(ilun,format)"             "
  write(ilun,format)"             lognorm_fact = real(ln_d(n_ln),dp)"
  write(ilun,format)"          end if"
  write(ilun,format)"       end if"
  write(ilun,format)"       "
  write(ilun,format)"       "
  write(ilun,format)"       ! Uniform or disk-like ambient medium?"
  write(ilun,format)"       if (medium_type=='uni' .or. medium_type=='fractal') then"
  write(ilun,format)"          disk_fact = 1.0"
  write(ilun,format)"          "
  write(ilun,format)"       else if (medium_type=='disk' .or. medium_type=='disk_fractal') then"
  write(ilun,format)"          ! r0, h from namelist "
  write(ilun,format)"          "
  write(ilun,format)"          ! calculate theta here."
  write(ilun,format)"          dx_ = xcell - xwind"
  write(ilun,format)"          dy_ = ycell - ywind"
  write(ilun,format)"          dz_ = zcell - zwind"
  write(ilun,format)"          dr = sqrt(dx_**2.0 + dy_**2.0)"
  write(ilun,format)"          sin_theta = dr/dctr"
  write(ilun,format)"          "
  write(ilun,format)"          "
  write(ilun,format)"          ! h is really h/r ratio."
  write(ilun,format)"          "
  write(ilun,format)"          ! As in Nathan's paper."
  write(ilun,format)"          !disk_fact = ((dctr/r0)**(-gam))*exp((h**(-2.0))*(sin_theta-1.0))"
  write(ilun,format)"          "
  write(ilun,format)"          ! Self-gravitating (fg=1), isothermal sheet. Assume nHc is"
  write(ilun,format)"          ! define as rho(100 pc). h is h/r ratio."
  write(ilun,format)"          disk_fact = 0.5*((dr/0.1)**(-2.0))"
  write(ilun,format)"          disk_fact = disk_fact*4.0/((exp(abs(dz_)/(2.0*h*dr)) + exp(-abs(dz_)/(2.0*h*dr)))**2.0)"
  write(ilun,format)"          "
  write(ilun,format)"          ! Impose a minimum value on disk_fact, to avoid errors due to"
  write(ilun,format)"          ! very small numbers."
  write(ilun,format)"          !"
  write(ilun,format)"          ! Be careful: 10^-6 of number density of ULIRG disk is not"
  write(ilun,format)"          ! that small, so may over estimate halo gas density."
  write(ilun,format)"          disk_fact = max(disk_fact, 10.0**(-6.0))"
  write(ilun,format)"          "
  write(ilun,format)"       else if (medium_type=='strat'.or.medium_type=='strat_fractal') then"
  write(ilun,format)"          ! to use this set gravity_type=2 too"
  write(ilun,format)"          dz_ = (zcell-zwind)*scale_l"
  write(ilun,format)"          smoothing_l=0.5*boxlen/2*scale_l"
  write(ilun,format)"          potential_true=(a1*(sqrt(dz_**2+z0**2)-z0)+a2*(dz_**2)/2)"
  write(ilun,format)"          if (dz_>=0)then"
  write(ilun,format)"             dz_=min(dz_,boxlen/2*scale_l-smoothing_l)"
  write(ilun,format)"          else"
  write(ilun,format)"             dz_=max(dz_,-boxlen/2*scale_l+smoothing_l)"
  write(ilun,format)"          end if"
  write(ilun,format)"          potential_lim=(a1*(sqrt(dz_**2+z0**2)-z0)+a2*(dz_**2)/2)"
  write(ilun,format)"          potential=(potential_lim**(-15.)+potential_true**(-15.))**(-1./15.)"
  write(ilun,format)"          disk_fact=rho0*exp(-f*potential)/scale_d/rhocool"
  write(ilun,format)"          Pc=rhocool*disk_fact*T0/mu/scale_T2 ! hydrostatic equilibrium in the disk"
  write(ilun,format)"       end if"
  write(ilun,format)"       "
  write(ilun,format)"    end if"
  write(ilun,format)"    "
  write(ilun,format)"    ! Density."
  write(ilun,format)"    q(i,id) = lognorm_fact*disk_fact*rhocool"
  write(ilun,format)"    "
  write(ilun,format)"    ! Constant pressure."
  write(ilun,format)"    q(i,ip) = Pc"
  write(ilun,format)"    "
  write(ilun,format)"    ! Static."
  write(ilun,format)"    q(i,iu) = 0.0"
  write(ilun,format)"    q(i,iv) = 0.0"
  write(ilun,format)"    q(i,iw) = 0.0"
  write(ilun,format)"    "
  write(ilun,format)"    if(metal) then"
  write(ilun,format)"       q(i,6)=z_ave ! customized metallicity value."
  write(ilun,format)"       q(i,7)=z_ave_alpha"
  write(ilun,format)"       q(i,8)=z_ave_rp"
  write(ilun,format)"    end if"
  write(ilun,format)" end do ! loop over cells"
  write(ilun,format)""
  write(ilun,format)"! Convert primitive to conservative variables"
  write(ilun,format)"! density -> density"
  write(ilun,format)" u(1:nn,1)=q(1:nn,1)"
  write(ilun,format)"! velocity -> momentum"
  write(ilun,format)" u(1:nn,2)=q(1:nn,1)*q(1:nn,2)"
  write(ilun,format)"#if NDIM>1"
  write(ilun,format)" u(1:nn,3)=q(1:nn,1)*q(1:nn,3)"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM>2"
  write(ilun,format)" u(1:nn,4)=q(1:nn,1)*q(1:nn,4)"
  write(ilun,format)"#endif"
  write(ilun,format)"! kinetic energy"
  write(ilun,format)" u(1:nn,ndim+2)=0.0d0"
  write(ilun,format)" u(1:nn,ndim+2)=u(1:nn,ndim+2)+0.5*q(1:nn,1)*q(1:nn,2)**2"
  write(ilun,format)"#if NDIM>1"
  write(ilun,format)" u(1:nn,ndim+2)=u(1:nn,ndim+2)+0.5*q(1:nn,1)*q(1:nn,3)**2"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM>2"
  write(ilun,format)" u(1:nn,ndim+2)=u(1:nn,ndim+2)+0.5*q(1:nn,1)*q(1:nn,4)**2"
  write(ilun,format)"#endif"
  write(ilun,format)"! pressure -> total fluid energy"
  write(ilun,format)" u(1:nn,ndim+2)=u(1:nn,ndim+2)+q(1:nn,ndim+2)/(gamma-1.0d0)"
  write(ilun,format)"! passive scalars"
  write(ilun,format)" do ivar=ndim+3,nvar"
  write(ilun,format)"    u(1:nn,ivar)=q(1:nn,1)*q(1:nn,ivar)"
  write(ilun,format)" end do"
  write(ilun,format)""
  write(ilun,format)"end subroutine condinit"
  write(ilun,format)"../patch/hydro/stratified_medium_fx_NSM/cooling_fine.f90"
  write(ilun,format)"subroutine cooling_fine(ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use cooling_module"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)"  !-------------------------------------------------------------------"
  write(ilun,format)"  ! Compute cooling for fine levels"
  write(ilun,format)"  !-------------------------------------------------------------------"
  write(ilun,format)"  integer::ncache,i,igrid,ngrid,info"
  write(ilun,format)"  integer,dimension(1:nvector),save::ind_grid"
  write(ilun,format)""
  write(ilun,format)"  if(numbtot(1,ilevel)==0)return"
  write(ilun,format)"  if(verbose)write(*,111)ilevel"
  write(ilun,format)""
  write(ilun,format)"  ! Compute sink accretion rates"
  write(ilun,format)"  if(sink)call compute_accretion_rate(0)"
  write(ilun,format)""
  write(ilun,format)"  ! Operator splitting step for cooling source term"
  write(ilun,format)"  ! by vector sweeps"
  write(ilun,format)"  ncache=active(ilevel)%ngrid"
  write(ilun,format)"  do igrid=1,ncache,nvector"
  write(ilun,format)"     ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"     do i=1,ngrid"
  write(ilun,format)"        ind_grid(i)=active(ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"     end do"
  write(ilun,format)"     call coolfine1(ind_grid,ngrid,ilevel)"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  if(cooling.and.ilevel==levelmin.and.cosmo)then"
  write(ilun,format)"     if(myid==1)write(*,*)'Computing new cooling table'"
  write(ilun,format)"     call set_table(dble(aexp))"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"111 format('   Entering cooling_fine for level',i2)"
  write(ilun,format)""
  write(ilun,format)"end subroutine cooling_fine"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"subroutine coolfine1(ind_grid,ngrid,ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"#ifdef ATON"
  write(ilun,format)"  use radiation_commons, ONLY: Erad"
  write(ilun,format)"#endif"
  write(ilun,format)"  use cooling_module"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ilevel,ngrid"
  write(ilun,format)"  integer,dimension(1:nvector)::ind_grid"
  write(ilun,format)"  !-------------------------------------------------------------------"
  write(ilun,format)"  !-------------------------------------------------------------------"
  write(ilun,format)"  integer::i,ind,iskip,idim,nleaf,nx_loc,ix,iy,iz"
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v"
  write(ilun,format)"  real(kind=8)::dtcool,nISM,nCOM,damp_factor,cooling_switch,t_blast"
  write(ilun,format)"  real(dp)::polytropic_constant,xcell,ycell,zcell,LAGN,mu"
  write(ilun,format)"  integer,dimension(1:nvector),save::ind_cell,ind_leaf"
  write(ilun,format)"  real(kind=8),dimension(1:nvector),save::nH,T2,delta_T2,ekk,r"
  write(ilun,format)"  real(kind=8),dimension(1:nvector),save::T2min,Zsolar,boost,x_leaf,y_leaf,z_leaf"
  write(ilun,format)"  real(dp),dimension(1:3)::skip_loc"
  write(ilun,format)"  real(kind=8)::dx,dx_loc,scale,vol_loc"
  write(ilun,format)"  real(dp)::xwinds,ywinds,zwinds"
  write(ilun,format)"  real(dp),dimension(1:twotondim,1:ndim)::xc"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! Variables needed for namelist read in."
  write(ilun,format)"  character(LEN=160)::infile"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! Mesh spacing in that level"
  write(ilun,format)"  dx=0.5D0**ilevel "
  write(ilun,format)"  "
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  skip_loc=(/0.0d0,0.0d0,0.0d0/)"
  write(ilun,format)"  if(ndim>0)skip_loc(1)=dble(icoarse_min)"
  write(ilun,format)"  if(ndim>1)skip_loc(2)=dble(jcoarse_min)"
  write(ilun,format)"  if(ndim>2)skip_loc(3)=dble(kcoarse_min)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc) ! inverse of 'scale' in wind_fine,"
  write(ilun,format)"                            !       so will divide insead of multiply"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)"  vol_loc=dx_loc**ndim"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! Conversion factor from user units to cgs units"
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! Location of the point source (grid or code units?)"
  write(ilun,format)"  !"
  write(ilun,format)"  ! Need this correction here, even though not in condinit and"
  write(ilun,format)"  ! courant_fine. Distinction b/w user and code units? "
  write(ilun,format)"  xwinds = xwind/scale+dble(icoarse_min)"
  write(ilun,format)"  ywinds = ywind/scale+dble(jcoarse_min)"
  write(ilun,format)"  zwinds = zwind/scale+dble(kcoarse_min)"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! Set position of cell centers relative to grid center"
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     iz=(ind-1)/4"
  write(ilun,format)"     iy=(ind-1-4*iz)/2"
  write(ilun,format)"     ix=(ind-1-2*iy-4*iz)"
  write(ilun,format)"     if(ndim>0)xc(ind,1)=(dble(ix)-0.5D0)*dx"
  write(ilun,format)"     if(ndim>1)xc(ind,2)=(dble(iy)-0.5D0)*dx"
  write(ilun,format)"     if(ndim>2)xc(ind,3)=(dble(iz)-0.5D0)*dx"
  write(ilun,format)"  end do "
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! AGN bolometric luminosity in erg/s."
  write(ilun,format)"  LAGN = 10d0**logLAGN"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! Typical ISM density in H/cc"
  write(ilun,format)"  nISM = n_star; nCOM=0d0"
  write(ilun,format)"  if(cosmo)then"
  write(ilun,format)"     nCOM = del_star*omega_b*rhoc*(h0/100.)**2/aexp**3*X/mH"
  write(ilun,format)"  endif"
  write(ilun,format)"  nISM = MAX(nCOM,nISM)"
  write(ilun,format)""
  write(ilun,format)"  ! Polytropic constant for Jeans length related polytropic EOS"
  write(ilun,format)"  if(jeans_ncells>0)then"
  write(ilun,format)"     polytropic_constant=2d0*(boxlen*jeans_ncells*0.5d0**dble(nlevelmax)*scale_l/aexp)**2/ &"
  write(ilun,format)"          & (twopi)*6.67e-8*scale_d*(scale_t/scale_l)**2"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  ! Loop over cells"
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"     do i=1,ngrid"
  write(ilun,format)"        ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     ! Gather leaf cells"
  write(ilun,format)"     nleaf=0"
  write(ilun,format)"     do i=1,ngrid"
  write(ilun,format)"        if(son(ind_cell(i))==0)then"
  write(ilun,format)"           nleaf=nleaf+1"
  write(ilun,format)"           ind_leaf(nleaf)=ind_cell(i)"
  write(ilun,format)""
  write(ilun,format)"           ! Follow procedure in wind_fine() to extract cell"
  write(ilun,format)"	   ! coordinates. "
  write(ilun,format)"           x_leaf(nleaf) = xg(ind_grid(i),1)+xc(ind,1)"
  write(ilun,format)"           y_leaf(nleaf) = xg(ind_grid(i),2)+xc(ind,2)"
  write(ilun,format)"           z_leaf(nleaf) = xg(ind_grid(i),3)+xc(ind,3)"
  write(ilun,format)""
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     ! Compute rho"
  write(ilun,format)"     do i=1,nleaf"
  write(ilun,format)"        nH(i)=MAX(uold(ind_leaf(i),1),smallr)"
  write(ilun,format)"     end do"
  write(ilun,format)"     "
  write(ilun,format)"     ! Compute metallicity in solar units"
  write(ilun,format)"     if(metal)then"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           Zsolar(i)=(uold(ind_leaf(i),imetal)+uold(ind_leaf(i),imetal+1)+uold(ind_leaf(i),imetal+2))/nH(i)/0.02"
  write(ilun,format)"        end do"
  write(ilun,format)"     else"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           Zsolar(i)=z_ave"
  write(ilun,format)"        end do"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     ! Compute pressure"
  write(ilun,format)"     do i=1,nleaf"
  write(ilun,format)"        T2(i)=uold(ind_leaf(i),ndim+2)"
  write(ilun,format)"     end do"
  write(ilun,format)"     do i=1,nleaf"
  write(ilun,format)"        ekk(i)=0.0d0"
  write(ilun,format)"     end do"
  write(ilun,format)"     do idim=1,ndim"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           ekk(i)=ekk(i)+0.5*uold(ind_leaf(i),idim+1)**2/nH(i)"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     do i=1,nleaf"
  write(ilun,format)"        T2(i)=(gamma-1.0)*(T2(i)-ekk(i))"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     ! Compute T2=T/mu in Kelvin"
  write(ilun,format)"     do i=1,nleaf"
  write(ilun,format)"        T2(i)=T2(i)/nH(i)*scale_T2"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     "
  write(ilun,format)"     ! Compute nH in H/cc"
  write(ilun,format)"     do i=1,nleaf"
  write(ilun,format)"        nH(i)=nH(i)*scale_nH"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     ! Compute distance from central AGN in cm."
  write(ilun,format)"     do i=1,nleaf"
  write(ilun,format)"        xcell = x_leaf(i)"
  write(ilun,format)"	ycell = y_leaf(i)"
  write(ilun,format)"	zcell = z_leaf(i)"
  write(ilun,format)""
  write(ilun,format)"        "
  write(ilun,format)"	! DEBUG"
  write(ilun,format)"	!write(*,*) '---------------------------------'"
  write(ilun,format)"	!write(*,*) 'xcell='"
  write(ilun,format)"	!write(*,*) xcell"
  write(ilun,format)"	!write(*,*) 'ycell='"
  write(ilun,format)"	!write(*,*) ycell"
  write(ilun,format)"	!write(*,*) 'zcell='"
  write(ilun,format)"	!write(*,*) zcell"
  write(ilun,format)"	!write(*,*) 'xwind='"
  write(ilun,format)"	!write(*,*) xwind"
  write(ilun,format)"	!write(*,*) 'ywind='"
  write(ilun,format)"	!write(*,*) ywind"
  write(ilun,format)"	!write(*,*) 'zwind='"
  write(ilun,format)"	!write(*,*) zwind"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"        r(i) = ((xcell-xwinds)**2.0 + (ycell-ywinds)**2.0 + (zcell-zwinds)**2.0)**0.5"
  write(ilun,format)""
  write(ilun,format)"	!Convert from code units to cgs."
  write(ilun,format)"	r(i) = r(i)*scale_l"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"     ! Compute radiation boost factor"
  write(ilun,format)"     if(self_shielding)then"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           boost(i)=exp(-nH(i)/0.01)"
  write(ilun,format)"        end do"
  write(ilun,format)"#ifdef ATON"
  write(ilun,format)"     else if (aton) then"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           boost(i)=MAX(Erad(ind_leaf(i))/J0simple(aexp), &"
  write(ilun,format)"                &                   J0min/J0simple(aexp) )"
  write(ilun,format)"        end do"
  write(ilun,format)"#endif"
  write(ilun,format)"     else"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           boost(i)=1.0"
  write(ilun,format)"        end do"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     !=========================================="
  write(ilun,format)"     ! Compute temperature from polytrope EOS"
  write(ilun,format)"     !=========================================="
  write(ilun,format)"     if(jeans_ncells>0)then"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           T2min(i) = nH(i)*polytropic_constant*scale_T2"
  write(ilun,format)"        end do"
  write(ilun,format)"     else"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           T2min(i) = T2_star*(nH(i)/nISM)**(g_star-1.0)"
  write(ilun,format)"        end do"
  write(ilun,format)"     endif"
  write(ilun,format)"     !=========================================="
  write(ilun,format)"     ! You can put your own polytrope EOS here"
  write(ilun,format)"     !=========================================="
  write(ilun,format)""
  write(ilun,format)"     ! Compute cooling time step in second"
  write(ilun,format)"     dtcool = dtnew(ilevel)*scale_t"
  write(ilun,format)""
  write(ilun,format)"     ! Compute net cooling at constant nH"
  write(ilun,format)"     if(cooling)then"
  write(ilun,format)"        ! Compute 'thermal' temperature by substracting polytrope"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           T2(i) = max(T2(i)-T2min(i),T2_min_fix)"
  write(ilun,format)"        end do"
  write(ilun,format)"        "
  write(ilun,format)"	! nH and T2 are cgs here."
  write(ilun,format)""
  write(ilun,format)"	! provide r and LAGN in cgs units here."
  write(ilun,format)"	call solve_cooling(nH,T2,Zsolar,boost,dtcool,delta_T2,nleaf,LAGN,r)"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     ! Compute rho"
  write(ilun,format)"     do i=1,nleaf"
  write(ilun,format)"        nH(i) = nH(i)/scale_nH"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     ! Compute net energy sink"
  write(ilun,format)"     if(cooling)then"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           delta_T2(i) = delta_T2(i)*nH(i)/scale_T2/(gamma-1.0)"
  write(ilun,format)"        end do"
  write(ilun,format)"        ! Turn off cooling in blast wave regions"
  write(ilun,format)"        if(delayed_cooling)then"
  write(ilun,format)"           do i=1,nleaf"
  write(ilun,format)"              cooling_switch=uold(ind_leaf(i),idelay)/uold(ind_leaf(i),1)"
  write(ilun,format)"              if(cooling_switch>1d-3)then"
  write(ilun,format)"                 delta_T2(i)=0"
  write(ilun,format)"              endif"
  write(ilun,format)"           end do"
  write(ilun,format)"        endif"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     ! Compute minimal total energy from polytrope"
  write(ilun,format)"     do i=1,nleaf"
  write(ilun,format)"        T2min(i) = T2min(i)*nH(i)/scale_T2/(gamma-1.0) + ekk(i)"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     ! Update total fluid energy"
  write(ilun,format)"     do i=1,nleaf"
  write(ilun,format)"        T2(i) = uold(ind_leaf(i),ndim+2)"
  write(ilun,format)"     end do"
  write(ilun,format)"     if(cooling)then"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           T2(i) = T2(i)+delta_T2(i)"
  write(ilun,format)"        end do"
  write(ilun,format)"     endif"
  write(ilun,format)"     if(isothermal)then"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           uold(ind_leaf(i),ndim+2) = T2min(i)"
  write(ilun,format)"        end do"
  write(ilun,format)"     else"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           uold(ind_leaf(i),ndim+2) = max(T2(i),T2min(i))"
  write(ilun,format)"        end do"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     ! Update delayed cooling switch"
  write(ilun,format)"     if(delayed_cooling)then"
  write(ilun,format)"        t_blast=20d0*1d6*(365.*24.*3600.)"
  write(ilun,format)"        damp_factor=exp(-dtcool/t_blast)"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           uold(ind_leaf(i),idelay)=uold(ind_leaf(i),idelay)*damp_factor"
  write(ilun,format)"        end do"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"  end do"
  write(ilun,format)"  ! End loop over cells"
  write(ilun,format)""
  write(ilun,format)"end subroutine coolfine1"
  write(ilun,format)"../patch/hydro/stratified_medium_fx_NSM/cooling_module.f90"
  write(ilun,format)"!============================================================================="
  write(ilun,format)"!                   SUPERMEGAGIGAMODULECOOLINGQUIDEPOTE"
  write(ilun,format)"!============================================================================="
  write(ilun,format)"! Les subroutines et fonctions d'interet general sont :"
  write(ilun,format)"!"
  write(ilun,format)"! ROUTINES A APPELER PAR LE CODE HYDRO"
  write(ilun,format)"!"
  write(ilun,format)"!    subroutine set_model(...) : "
  write(ilun,format)"!          pour choisir le modele de cooling et ses parametres"
  write(ilun,format)"!"
  write(ilun,format)"!    subroutine set_table(aexp) : "
  write(ilun,format)"!          pour creer la table avec les parametres par defaut "
  write(ilun,format)"!          Plus pratique a appeler que "
  write(ilun,format)"!          cmp_table(nH_min,nH_max,T2_min,T2_max,nbin_n,nbin_T,aexp)"
  write(ilun,format)"!"
  write(ilun,format)"!    subroutine solve_cooling(...) : "
  write(ilun,format)"!          pour calculer le cooling"
  write(ilun,format)"!"
  write(ilun,format)"! ROUTINE A MODIFIER SI NECESSAIRE"
  write(ilun,format)"!"
  write(ilun,format)"!    function J0simple(aexp) : "
  write(ilun,format)"!          donne le J0 en fonction du redshift dans les modeles Teyssier "
  write(ilun,format)"!          ou Theuns"
  write(ilun,format)"!"
  write(ilun,format)"!============================================================================="
  write(ilun,format)"module cooling_module"
  write(ilun,format)"  use amr_parameters"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  logical :: verbose_cooling=.false."
  write(ilun,format)""
  write(ilun,format)"  ! we have cgs units here."
  write(ilun,format)"  real(kind=8),parameter ::smallnum_cooling= 1d-30"
  write(ilun,format)"  real(kind=8),parameter ::twopi   = 6.2831853d0"
  write(ilun,format)"  real(kind=8),parameter ::pi      = 3.14159265d0"
  write(ilun,format)"  real(kind=8),parameter ::hplanck = 6.6262000d-27"
  write(ilun,format)"  real(kind=8),parameter ::eV      = 1.6022000d-12"
  write(ilun,format)"  real(kind=8),parameter ::kB      = 1.3806200d-16"
  write(ilun,format)"  real(kind=8),parameter ::sigmaT  = 6.6524d-25"
  write(ilun,format)"  real(kind=8),parameter ::clight  = 2.9979250d+10"
  write(ilun,format)"  real(kind=8),parameter ::Gyr     = 3.1536000d+16"
  write(ilun,format)"  real(kind=8),parameter ::X       = 0.76"
  write(ilun,format)"  real(kind=8),parameter ::Y       = 0.24 "
  write(ilun,format)"  real(kind=8),parameter ::rhoc    = 1.8800000d-29"
  write(ilun,format)"  real(kind=8),parameter ::mH      = 1.6600000d-24"
  write(ilun,format)"  real(kind=8),parameter ::me      = 9.10938215d-27"
  write(ilun,format)"  real(kind=8),parameter ::mu_mol  = 1.2195D0 ! neutral"
  write(ilun,format)"  integer,parameter::HI      = 1"
  write(ilun,format)"  integer,parameter::HEI     = 2"
  write(ilun,format)"  integer,parameter::HEII    = 3"
  write(ilun,format)""
  write(ilun,format)"  ! Les parametres de la table par defaut"
  write(ilun,format)"  integer,parameter     :: nbin_T_fix=101"
  write(ilun,format)"  integer,parameter     :: nbin_n_fix=161"
  write(ilun,format)"  real(kind=8),parameter:: nH_min_fix=1.d-10"
  write(ilun,format)"  real(kind=8),parameter:: nH_max_fix=1.d+6"
  write(ilun,format)"  real(kind=8),parameter:: T2_min_fix=1.d-2"
  write(ilun,format)"  real(kind=8),parameter:: T2_max_fix=1.d+11 !  increased this"
  write(ilun,format)"  "
  write(ilun,format)"  type cooling_table"
  write(ilun,format)"     integer::n1"
  write(ilun,format)"     integer::n2"
  write(ilun,format)"     real(kind=8),dimension(:)    ,pointer::nH"
  write(ilun,format)"     real(kind=8),dimension(:)    ,pointer::T2"
  write(ilun,format)"     real(kind=8),dimension(:,:)  ,pointer::cool"
  write(ilun,format)"     real(kind=8),dimension(:,:)  ,pointer::heat"
  write(ilun,format)"     real(kind=8),dimension(:,:)  ,pointer::cool_com"
  write(ilun,format)"     real(kind=8),dimension(:,:)  ,pointer::heat_com"
  write(ilun,format)"     real(kind=8),dimension(:,:)  ,pointer::metal"
  write(ilun,format)"     real(kind=8),dimension(:,:)  ,pointer::cool_prime"
  write(ilun,format)"     real(kind=8),dimension(:,:)  ,pointer::heat_prime"
  write(ilun,format)"     real(kind=8),dimension(:,:)  ,pointer::cool_com_prime"
  write(ilun,format)"     real(kind=8),dimension(:,:)  ,pointer::heat_com_prime"
  write(ilun,format)"     real(kind=8),dimension(:,:)  ,pointer::metal_prime"
  write(ilun,format)"     real(kind=8),dimension(:,:)  ,pointer::mu"
  write(ilun,format)"     real(kind=8),dimension(:,:,:),pointer::n_spec"
  write(ilun,format)"  end type cooling_table"
  write(ilun,format)""
  write(ilun,format)"  type(cooling_table)::table,table2"
  write(ilun,format)"  ! Utilisation de table%n_spec si necessaire"
  write(ilun,format)"  logical, parameter :: if_species_abundances=.true. "
  write(ilun,format)"  ! Facteur correctif de Theuns et al."
  write(ilun,format)"  real(kind=8),parameter :: dumfac_ion_theuns=2.d0 "
  write(ilun,format)"  real(kind=8),parameter :: dumfac_rec_theuns=0.75D0  ! idem"
  write(ilun,format)"  real(kind=8) :: dumfac_ion=dumfac_ion_theuns"
  write(ilun,format)"  real(kind=8) :: dumfac_rec=dumfac_rec_theuns"
  write(ilun,format)""
  write(ilun,format)"  ! On DOIT AVOIR OU teyssier OU theuns OU madau "
  write(ilun,format)"  ! OU weinbergint OU courty avec un OU exclusif"
  write(ilun,format)"  logical :: teyssier=.false.         "
  write(ilun,format)"  logical :: theuns=.false.           "
  write(ilun,format)"  logical :: madau=.false.           "
  write(ilun,format)"  logical :: weinberg=.false. "
  write(ilun,format)"  logical :: weinbergint=.false. "
  write(ilun,format)"  logical :: courty=.true."
  write(ilun,format)""
  write(ilun,format)"  ! Si teyssier ou theuns :"
  write(ilun,format)"  real(kind=8) :: J0in=1.d-22  ! J0 default "
  write(ilun,format)"  real(kind=8) :: J0min=1.d-29 ! Valeur minimale du J0 "
  write(ilun,format)"  logical :: force_j0_one=.false. ! Force constant UV bkg"
  write(ilun,format)"  ! (saturation a grand redshift)"
  write(ilun,format)"  real(kind=8) :: aexp_ref=0.0001        "
  write(ilun,format)"  real(kind=8) :: J0min_ref=2.77168510365299962D-25 ! J0min_ref precalcule pour"
  write(ilun,format)"  ! H0=70, omegab=0.04, omega0=0.3, omegaL=0.7"
  write(ilun,format)"  logical :: high_z_realistic_ne=.true. ! Calcul du J0min de telle sorte "
  write(ilun,format)"  ! que le n_e soit realiste a grand z. J0min=J0min_ref/(aexp/aexp_ref)^2"
  write(ilun,format)"  real(kind=8) :: alpha=1.d0   ! J(nu) \propto nu^{-alpha} "
  write(ilun,format)"  ! Si madau ou weinbergint :"
  write(ilun,format)"  real(kind=8) :: normfacJ0=0.74627   ! Facteur de normalisation pour J0 "
  write(ilun,format)"  ! pour un J(nu,z) de type haardt et Madau"
  write(ilun,format)"  ! Ce facteur la est celui utilise par Dave et al. pour LCDM"
  write(ilun,format)"  ! Sauvegarde des termes de cooling/heating dans les"
  write(ilun,format)"  logical, parameter :: if_cooling_functions=.true. "
  write(ilun,format)"  ! variables en dessous"
  write(ilun,format)"  real(kind=8)::cb1s,cb2s,cb3s,ci1s,ci2s,ci3s,cr1s,cr2s,cr3s,cds"
  write(ilun,format)"  real(kind=8)::ce1s,ce3s,ch1s,ch2s,ch3s,cocs,cohs"
  write(ilun,format)"  real(kind=8)::cool_out, heat_out"
  write(ilun,format)""
  write(ilun,format)"  ! Les heating et photoionization rates de Dave et al. "
  write(ilun,format)"  ! pour le J0 derniere version de HM (weinberg ou weinbergint si"
  write(ilun,format)"  ! if_read_weinberg=.true. (voir plus bas) dans ce dernier cas)"
  write(ilun,format)"  real(kind=8),allocatable, dimension(:,:)::table_weinberg "
  write(ilun,format)"  ! Table d'interpolation en input"
  write(ilun,format)"  character(len=128), parameter :: table_weinberg_name='TREECOOL' "
  write(ilun,format)"  ! Nom du fichier avec les donnees"
  write(ilun,format)"  integer,parameter :: luweinberg=21                        "
  write(ilun,format)"  ! unit pour lire le fichier"
  write(ilun,format)"  integer :: Nweinberg                                    "
  write(ilun,format)"  ! Nombre de bins en redshift"
  write(ilun,format)""
  write(ilun,format)"  ! Les coefficients d'interpolation des heating rates de Dave et al."
  write(ilun,format)"  ! (weinbergint)"
  write(ilun,format)"  logical,parameter :: if_read_weinberg=.false. "
  write(ilun,format)"  ! .true. pour lire le fichier table_weinberg_name"
  write(ilun,format)"  ! puis interpoler par un polynome"
  write(ilun,format)"  ! .false. pour utiliser les valeurs des coefficients"
  write(ilun,format)"  ! precalcules listes plus bas"
  write(ilun,format)"  integer,parameter :: Norderweinberg=7       "
  write(ilun,format)"  ! Ordre+1 du polynome d'interpolation (NE PAS CHANGER)"
  write(ilun,format)"  real(kind=8) :: coefweinberg(Norderweinberg,6)= reshape( &"
  write(ilun,format)" &                    (/ -0.31086729929951613D+002, 0.34803667059463761D+001,-0.15145716066316397D+001, &"
  write(ilun,format)" &                        0.54649951450632972D+000,-0.16395924120387340D+000, 0.25197466148524143D-001, &"
  write(ilun,format)" &                       -0.15352763785487806D-002, &"
  write(ilun,format)" &                       -0.31887274113252204D+002, 0.44178493140927095D+001,-0.20158132553082293D+001, &  "
  write(ilun,format)" &                        0.64080497292269134D+000,-0.15981267091909040D+000, 0.22056900050237707D-001, &"
  write(ilun,format)" &                       -0.12837570029562849D-002, &"
  write(ilun,format)" &                       -0.35693331167978656D+002, 0.20207245722165794D+001,-0.76856976101363744D-001, &"
  write(ilun,format)" &                       -0.75691470654320359D-001,-0.54502220282734729D-001, 0.20633345104660583D-001, & "
  write(ilun,format)" &                       -0.18410307456285177D-002, &"
  write(ilun,format)" &                       -0.56967559787460921D+002, 0.38601174525546353D+001,-0.18318926655684415D+001, &"
  write(ilun,format)" &                        0.67360594266440688D+000,-0.18983466813215341D+000, 0.27768907786915147D-001, &"
  write(ilun,format)" &                       -0.16330066969315893D-002, &"
  write(ilun,format)" &                       -0.56977907250821026D+002, 0.38686249565302266D+001,-0.13330942368518774D+001, &  "
  write(ilun,format)" &                        0.33988839029092172D+000,-0.98997915675929332D-001, 0.16781612113050747D-001, &"
  write(ilun,format)" &                       -0.11514328893746039D-002, &"
  write(ilun,format)" &                       -0.59825233828609278D+002, 0.21898162706563347D+001,-0.42982055888598525D+000, &"
  write(ilun,format)" &                        0.50312144291614215D-001,-0.61550639239553132D-001, 0.18017109270959387D-001, & "
  write(ilun,format)" &                       -0.15438891584271634D-002 /), (/Norderweinberg,6/) )"
  write(ilun,format)""
  write(ilun,format)"  real(kind=8) :: zreioniz=8.5d0"
  write(ilun,format)"  integer,parameter :: Nordercourty=7       "
  write(ilun,format)"  ! Ordre+1 du polynome d'interpolation (NE PAS CHANGER)"
  write(ilun,format)"  real(kind=8) :: coefcourty(0:Nordercourty,6)= reshape( &"
  write(ilun,format)"                      (/ -13.5857,  1.24475,    0.187739, &"
  write(ilun,format)"                        -0.430409, 0.152544,  -0.0246448, &"
  write(ilun,format)"                         0.00192622, -5.89772e-05, &"
  write(ilun,format)"                        -14.0242,  1.99211,   -0.490766, &"
  write(ilun,format)"                        -0.122646, 0.0776501, -0.0146310, &"
  write(ilun,format)"                         0.00123335, -3.96066e-05, &"
  write(ilun,format)"                        -15.6627,  0.128240,   1.65633, &"
  write(ilun,format)"                        -1.23799,  0.372157,  -0.0561687, &"
  write(ilun,format)"                         0.00422696, -0.000126344, &"
  write(ilun,format)"                        -24.8422,  1.50750,   -0.0699428, &"
  write(ilun,format)"                        -0.308682, 0.122196,  -0.0205179, &"
  write(ilun,format)"                         0.00163695, -5.08050e-05, &"
  write(ilun,format)"                        -25.0252,  1.79577,   -0.159054, &"
  write(ilun,format)"                        -0.300924, 0.125343,  -0.0214598, &"
  write(ilun,format)"                         0.00173377, -5.43576e-05, &"
  write(ilun,format)"                        -26.4168,  0.0479454,  1.70948, &"
  write(ilun,format)"                        -1.26395,  0.378922,  -0.0570957, &"
  write(ilun,format)"                         0.00428897, -0.000127909 /),(/Nordercourty+1,6/) )"
  write(ilun,format)"  real(kind=8),dimension(6)    :: coef_fit= (/ 20., 20., 20., 20., 20., 20. /) "
  write(ilun,format)"  integer,dimension(6) :: beta_fit= (/  6,   6,   8,   6,   6,  8  /)"
  write(ilun,format)""
  write(ilun,format)"contains "
  write(ilun,format)"!======================================================================="
  write(ilun,format)"subroutine set_model(Nmodel,J0in_in,J0min_in,alpha_in,normfacJ0_in,zreioniz_in, &"
  write(ilun,format)" &                   correct_cooling,realistic_ne, &"
  write(ilun,format)" &                   h,omegab,omega0,omegaL,astart_sim,T2_sim)"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"! Nmodel(integer) =1 : Teyssier : ancien choix de l'evolution et de la forme du J(nu,z)"
  write(ilun,format)"!                  2 : Theuns   : pareil mais avec les fonctions interpolees de Theuns (+ rapide)"
  write(ilun,format)"!                  3 : Madau    : J(nu,z) de Theuns et al. 1998 avec les anciennes mesures de "
  write(ilun,format)"!                                 Haardt et Madau (HM)"
  write(ilun,format)"!                  4 : Weinberg : J(nu,z) de Dave et al. 1999 avec les nouvelles mesure de HM "
  write(ilun,format)"!                                 lues dans le fichier table_weinberg_name (inactive)"
  write(ilun,format)"!                  5 : idem 4 mais interpole interpole de maniere polynomiale : RECOMMANDE"
  write(ilun,format)"!                  6 : Courty"
  write(ilun,format)"!                 -1 : defaut defini dans le module "
  write(ilun,format)"! J0in_in (dble) : valeur du J0 utilisee pour Teyssier et Theuns"
  write(ilun,format)"!            Exemple : J0in_in=1.d-22"
  write(ilun,format)"!            J0in_in <= 0 utilise le defaut defini dans le module"
  write(ilun,format)"! J0min_in (dble) : valeur du J0min ou J0min_ref (voir option realistic_ne) "
  write(ilun,format)"!            utilisee dans tous les modeles a grand redshift "
  write(ilun,format)"!            Exemple : J0min_in=1.d-29"
  write(ilun,format)"!            J0min_in <= 0 utilise le defaut defini dans le module"
  write(ilun,format)"! alpha_in (dble) : valeur de l'indice spectral du J(nu) \propto nu^{-alpha}"
  write(ilun,format)"!            Exemple : alpha=1."
  write(ilun,format)"!            alpha_in < 0 utilise le defaut defini dans le module"
  write(ilun,format)"! zreioniz_in (dble) : valeur du redshift de reionisation"
  write(ilun,format)"!            Exemple : zerion=10."
  write(ilun,format)"!            zreioniz_in < 0 utilise le defaut defini dans le module"
  write(ilun,format)"! normfacJ0_in (dble) : valeur du facteur de normalisation dans le cas des"
  write(ilun,format)"!            spectres de Haardt et Madau. C'est un nombre de l'ordre de"
  write(ilun,format)"!            l'unite en general plus petit que 1."
  write(ilun,format)"!            Exemple : normfacJ0_in=0.74627"
  write(ilun,format)"!            normfacJ0_in prend le defaut defini dans le module"
  write(ilun,format)"! correct_cooling (integer) : 0 : pas de correction"
  write(ilun,format)"!                             1 : correction de Theuns et al 98"
  write(ilun,format)"!                            -1 : defaut defini dans le module"
  write(ilun,format)"! realistic_ne (integer) : 0 : pas de n_e realiste a grand redshift :"
  write(ilun,format)"!                              Le J0min reste le meme quel que soit le redshift"
  write(ilun,format)"!                              (J0min=J0min_in si celui-ci est > 0)"
  write(ilun,format)"!                          1 : n_e realiste a grand redshift : J0min proportionnel a 1/a^2 "
  write(ilun,format)"!                              egal initialement a J0min_ref pour a=aexp_ref=0.0001"
  write(ilun,format)"!                              (J0min_ref=J0min_in si celui-ci est > 0)"
  write(ilun,format)"!                          2 : RECOMMANDE : pareil que 1, mais J0min_ref est calcule de "
  write(ilun,format)"!                              maniere iterative pour avoir le bon n_e a z=19. "
  write(ilun,format)"!                              Le J0min_in n'est pas relevant dans ce cas la. "
  write(ilun,format)"! h (dble)          : H0/100"
  write(ilun,format)"! omegab (dble)     : omega baryons"
  write(ilun,format)"! omega0 (dble)     : omega matiere total"
  write(ilun,format)"! omegaL (dble)     : omega Lambda"
  write(ilun,format)"! astart_sim (dble) : redshift auquel on veut commencer la simulation"
  write(ilun,format)"! T2_sim     (dble) : ce sera en output, le T/mu en K a ce redshift pour des regions de contraste"
  write(ilun,format)"!                     de densite nul. "
  write(ilun,format)"!"
  write(ilun,format)"! NOTE :"
  write(ilun,format)"! Dans les cas madau, ou weinberg ou weinbergint, le J0 a grand redshift est calcule comme "
  write(ilun,format)"! dans l'option theuns :"
  write(ilun,format)"!   madau :       pour z >= 15 ou quand le taux trouve est plus petit que celui donne par "
  write(ilun,format)"!                 l'option theuns=.true."
  write(ilun,format)"!   weinberg :    quand on sort de la table des taux"
  write(ilun,format)"!   weinbergint : pour z >= 8.5 ou quand le taux trouve est plus petit que celui donne "
  write(ilun,format)"!                 par l'option theuns=.true."
  write(ilun,format)"!   courty : "
  write(ilun,format)"!======================================================================="
  write(ilun,format)"  implicit none"
  write(ilun,format)"  real(kind=8) :: J0in_in,zreioniz_in,J0min_in,alpha_in,normfacJ0_in,astart_sim,T2_sim"
  write(ilun,format)"  real(kind=8) :: J0min_ref_calc,h,omegab,omega0,omegaL"
  write(ilun,format)"  integer :: Nmodel,correct_cooling,realistic_ne"
  write(ilun,format)"  real(kind=8) :: astart,aend,dasura,T2end,mu,ne,minus1"
  write(ilun,format)"  if (Nmodel /= -1) then"
  write(ilun,format)"     teyssier=.false."
  write(ilun,format)"     theuns=.false."
  write(ilun,format)"     madau=.false."
  write(ilun,format)"     weinberg=.false."
  write(ilun,format)"     weinbergint=.false."
  write(ilun,format)"     courty=.false."
  write(ilun,format)"     if (Nmodel==1) then"
  write(ilun,format)"        teyssier=.true."
  write(ilun,format)"     elseif (Nmodel==2) then"
  write(ilun,format)"        theuns=.true."
  write(ilun,format)"     elseif (Nmodel==3) then"
  write(ilun,format)"        madau=.true."
  write(ilun,format)"     elseif (Nmodel==4) then"
  write(ilun,format)"        weinberg=.true."
  write(ilun,format)"     elseif (Nmodel==5) then"
  write(ilun,format)"        weinbergint=.true."
  write(ilun,format)"     elseif (Nmodel==6) then"
  write(ilun,format)"        courty=.true."
  write(ilun,format)"     else"
  write(ilun,format)"        write(*,*) 'ERROR in set_model : wrong value of Nmodel'"
  write(ilun,format)"        write(*,*) 'Nmodel =',Nmodel"
  write(ilun,format)"        STOP"
  write(ilun,format)"     endif"
  write(ilun,format)"  endif"
  write(ilun,format)"  if (J0in_in >= 0.0) J0in=J0in_in"
  write(ilun,format)"  if (zreioniz_in >= 0.0) zreioniz=zreioniz_in"
  write(ilun,format)"  if (alpha_in > 0.0) alpha=alpha_in"
  write(ilun,format)"  if (normfacJ0_in > 0.0) normfacJ0=normfacJ0_in"
  write(ilun,format)"  if (correct_cooling == 0) then"
  write(ilun,format)"     dumfac_ion=1.d0"
  write(ilun,format)"     dumfac_rec=1.d0"
  write(ilun,format)"  elseif (correct_cooling == 1) then"
  write(ilun,format)"     dumfac_ion=dumfac_ion_theuns"
  write(ilun,format)"     dumfac_rec=dumfac_rec_theuns"
  write(ilun,format)"  elseif (correct_cooling /= -1) then"
  write(ilun,format)"     write(*,*) 'ERROR in set_model : wrong value of correct_cooling'"
  write(ilun,format)"     write(*,*) 'correct_cooling =',correct_cooling"
  write(ilun,format)"     STOP"
  write(ilun,format)"  endif"
  write(ilun,format)"  if (realistic_ne == 0) then"
  write(ilun,format)"     astart=5.d-4"
  write(ilun,format)"     high_z_realistic_ne=.false."
  write(ilun,format)"     if (J0min_in > 0.d0) J0min=J0min_in"
  write(ilun,format)"  elseif (realistic_ne == 1) then"
  write(ilun,format)"     astart=aexp_ref"
  write(ilun,format)"     high_z_realistic_ne=.true."
  write(ilun,format)"     if (J0min_in > 0.d0) J0min_ref=J0min_in"
  write(ilun,format)"  elseif (realistic_ne == 2) then"
  write(ilun,format)"     astart=aexp_ref"
  write(ilun,format)"     high_z_realistic_ne=.true."
  write(ilun,format)"     call compute_J0min(h,omegab,omega0,omegaL,J0min_ref_calc)"
  write(ilun,format)"     J0min_ref=J0min_ref_calc"
  write(ilun,format)"  else"
  write(ilun,format)"     write(*,*) 'ERROR in set_model : wrong value of realistic_ne'"
  write(ilun,format)"     write(*,*) 'realistic_ne =',realistic_ne"
  write(ilun,format)"     STOP"
  write(ilun,format)"  endif"
  write(ilun,format)"  if (astart_sim < astart) then"
  write(ilun,format)"     write(*,*) 'ERROR in set_model : astart_sim is too small.'"
  write(ilun,format)"     write(*,*) 'astart     =',astart"
  write(ilun,format)"     write(*,*) 'astart_sim =',astart_sim"
  write(ilun,format)"     STOP"
  write(ilun,format)"  endif"
  write(ilun,format)"  ! Calcul de la temperature initiale"
  write(ilun,format)"  aend=astart_sim"
  write(ilun,format)"  dasura=0.02d0"
  write(ilun,format)"  minus1=-1.0"
  write(ilun,format)"  call evol_single_cell(astart,aend,dasura,h,omegab,omega0,omegaL,minus1,T2end,mu,ne,.false.)"
  write(ilun,format)"  if (verbose_cooling) write(*,*) 'Starting temperature in K :',T2end*mu"
  write(ilun,format)"  T2_sim=T2end "
  write(ilun,format)"end subroutine set_model"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"subroutine set_table(aexp)"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"  implicit none"
  write(ilun,format)"  real(kind=8) :: aexp"
  write(ilun,format)"  integer :: nbin_n,nbin_T"
  write(ilun,format)"  real(kind=8) :: nH_min,nH_max,T2_min,T2_max"
  write(ilun,format)"  nH_min=nH_min_fix"
  write(ilun,format)"  nH_max=nH_max_fix"
  write(ilun,format)"  T2_min=T2_min_fix"
  write(ilun,format)"  T2_max=T2_max_fix"
  write(ilun,format)"  nbin_n=nbin_n_fix"
  write(ilun,format)"  nbin_T=nbin_T_fix"
  write(ilun,format)"  call cmp_table(nH_min,nH_max,T2_min,T2_max,nbin_n,nbin_T,aexp)"
  write(ilun,format)"end subroutine set_table"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"subroutine output_cool(filename)"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"  implicit none"
  write(ilun,format)"  character(LEN=80)::filename"
  write(ilun,format)"  open(unit=10,file=filename,form='unformatted')"
  write(ilun,format)"  write(10)table%n1,table%n2"
  write(ilun,format)"  write(10)table%nH"
  write(ilun,format)"  write(10)table%T2"
  write(ilun,format)"  write(10)table%cool"
  write(ilun,format)"  write(10)table%heat"
  write(ilun,format)"  write(10)table%cool_com"
  write(ilun,format)"  write(10)table%heat_com"
  write(ilun,format)"  write(10)table%metal"
  write(ilun,format)"  write(10)table%cool_prime"
  write(ilun,format)"  write(10)table%heat_prime"
  write(ilun,format)"  write(10)table%cool_com_prime"
  write(ilun,format)"  write(10)table%heat_com_prime"
  write(ilun,format)"  write(10)table%metal_prime"
  write(ilun,format)"  write(10)table%mu"
  write(ilun,format)"  if (if_species_abundances) write(10)table%n_spec"
  write(ilun,format)"  close(10)"
  write(ilun,format)"end subroutine output_cool"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"subroutine evol_single_cell(astart,aend,dasura,h,omegab,omega0,omegaL, &"
  write(ilun,format)" &                          J0min_in,T2end,mu,ne,if_write_result)"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"! astart : valeur du facteur d'expansion au debut du calcul"
  write(ilun,format)"! aend   : valeur du facteur d'expansion a la fin du calcul"
  write(ilun,format)"! dasura : la valeur de da/a entre 2 pas de temps"
  write(ilun,format)"! h      : la valeur de H0/100 "
  write(ilun,format)"! omegab : la valeur de Omega baryons"
  write(ilun,format)"! omega0 : la valeur de Omega matiere (total)"
  write(ilun,format)"! omegaL : la valeur de Omega Lambda"
  write(ilun,format)"! J0min_in : la valeur du J0min a injecter :"
  write(ilun,format)"!          Si high_z_realistic_ne alors c'est J0min a a=astart qui"
  write(ilun,format)"!          est considere"
  write(ilun,format)"!          Sinon, c'est le J0min habituel."
  write(ilun,format)"!          Si J0min_in <=0, les parametres par defaut ou predefinis"
  write(ilun,format)"!          auparavant sont pris pour le J0min."
  write(ilun,format)"! T2end  : Le T/mu en output"
  write(ilun,format)"! mu     : le poids moleculaire en output"
  write(ilun,format)"! ne     : le ne en output"
  write(ilun,format)"! if_write_result : .true. pour ecrire l'evolution de la temperature"
  write(ilun,format)"!          et de n_e sur l'ecran."
  write(ilun,format)"!======================================================================="
  write(ilun,format)"  implicit none"
  write(ilun,format)"  real(kind=8)::astart,aend,T2end,h,omegab,omega0,omegaL,J0min_in,ne,dasura"
  write(ilun,format)"  logical :: if_write_result"
  write(ilun,format)"  real(kind=8)::aexp,daexp,dt_cool,coeff,coeff2"
  write(ilun,format)"  real(kind=8)::T2_com,T2_old,T2,T2_left,T2_right,err_T2"
  write(ilun,format)"  real(kind=8)::nH_com,nH  "
  write(ilun,format)"  real(kind=8),dimension(1:3)::t_rad_spec,h_rad_spec"
  write(ilun,format)"  real(kind=8) ::mu"
  write(ilun,format)"  real(kind=8) ::cool_tot,heat_tot,cool_com,heat_com"
  write(ilun,format)"  real(kind=8) ::diff"
  write(ilun,format)"  integer::niter"
  write(ilun,format)"  real(kind=8) :: n_spec(1:6)"
  write(ilun,format)"  if (J0min_in > 0.0) then"
  write(ilun,format)"     if (high_z_realistic_ne) then"
  write(ilun,format)"        J0min_ref = J0min_in"
  write(ilun,format)"        aexp_ref = astart"
  write(ilun,format)"     else"
  write(ilun,format)"        J0min = J0min_in"
  write(ilun,format)"     endif"
  write(ilun,format)"  endif"
  write(ilun,format)"  aexp = astart"
  write(ilun,format)"  T2_com = 2.726d0 / aexp * aexp**2 / mu_mol"
  write(ilun,format)"  nH_com = omegab*rhoc*h**2*X/mH"
  write(ilun,format)"  do while (aexp < aend)"
  write(ilun,format)"     daexp = dasura*aexp"
  write(ilun,format)"     dt_cool=daexp/(aexp*100.*h*3.2408608e-20*HsurH0(1.0/aexp-1.,omega0,omegaL,1.-omega0-omegaL))"
  write(ilun,format)"     "
  write(ilun,format)"     nH = nH_com/aexp**3"
  write(ilun,format)"     T2_old = T2_com/aexp**2"
  write(ilun,format)""
  write(ilun,format)"     ! Compute radiative ionization and heating rates"
  write(ilun,format)"     call set_rates(t_rad_spec,h_rad_spec,aexp)"
  write(ilun,format)"     "
  write(ilun,format)"     ! Iteration to find new T2"
  write(ilun,format)"     err_T2=1."
  write(ilun,format)"     T2_left=1.d-2"
  write(ilun,format)"     T2_right=1.d8"
  write(ilun,format)"     niter=0"
  write(ilun,format)"     coeff = 2.*nH*X/3./kB"
  write(ilun,format)"     coeff2 = 2.*X/3./kB"
  write(ilun,format)"     do while (err_T2 > 1.d-10.and.niter <= 100)"
  write(ilun,format)"        T2=0.5*(T2_left+T2_right)        "
  write(ilun,format)"        call cmp_cooling(T2,nH,t_rad_spec,h_rad_spec,cool_tot,heat_tot,cool_com,heat_com,mu,aexp,n_spec)"
  write(ilun,format)"        diff = coeff*(heat_tot-cool_tot) + coeff2*(heat_com-cool_com) + (T2_old-T2)/dt_cool"
  write(ilun,format)"        if(diff>0.)then "
  write(ilun,format)"           T2_left =0.5*(T2_left+T2_right)"
  write(ilun,format)"           T2_right=T2_right"
  write(ilun,format)"        else"
  write(ilun,format)"           T2_left =T2_left"
  write(ilun,format)"           T2_right=0.5*(T2_left+T2_right)"
  write(ilun,format)"        end if"
  write(ilun,format)"        err_T2=abs(T2_right-T2_left)/T2_left"
  write(ilun,format)"        niter=niter+1"
  write(ilun,format)"     end do"
  write(ilun,format)"     if (niter > 100) then"
  write(ilun,format)"        write(*,*) 'ERROR in evol_single_cell : too many iterations'"
  write(ilun,format)"        STOP"
  write(ilun,format)"     endif"
  write(ilun,format)"     T2_com=T2*aexp**2"
  write(ilun,format)"     aexp = aexp + daexp"
  write(ilun,format)"     if (if_write_result) write(*,'(4(1pe10.3))')aexp,nH,T2_com*mu/aexp**2,n_spec(1)/nH"
  write(ilun,format)"  end do"
  write(ilun,format)"  T2end=T2"
  write(ilun,format)"  ne=n_spec(1)/nH"
  write(ilun,format)"end subroutine evol_single_cell"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"subroutine compute_J0min(h,omegab,omega0,omegaL,J0min_in)"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"  implicit none"
  write(ilun,format)"  real(kind=8) :: omega0,omegaL,h,omegab,ne_to_find,mu"
  write(ilun,format)"  real(kind=8) :: h0,astart,aend,J0min_in,T2end,ne"
  write(ilun,format)"  real(kind=8) :: J0min_left,J0min_right,err_J0min,diff,xval,dasura"
  write(ilun,format)"  integer :: niter"
  write(ilun,format)"  logical :: if_write_result=.false."
  write(ilun,format)""
  write(ilun,format)"  xval=sqrt(omega0)/(h*omegab)"
  write(ilun,format)"  ne_to_find=1.2d-5*xval ! From the book of Peebles p. 173"
  write(ilun,format)"  astart=aexp_ref"
  write(ilun,format)"  aend=MIN(0.05d0,0.5d0/(1d0+zreioniz)) ! Always end before reionization"
  write(ilun,format)"  dasura=0.05"
  write(ilun,format)"  err_J0min=1."
  write(ilun,format)"  J0min_left=1d-20"
  write(ilun,format)"  J0min_right=1d-30"
  write(ilun,format)"  niter=0"
  write(ilun,format)"  do while (err_J0min > 1.d-3 .and. niter <= 100)"
  write(ilun,format)"     J0min_in=0.5*(J0min_left+J0min_right)     "
  write(ilun,format)"     call evol_single_cell(astart,aend,dasura,h,omegab,omega0,omegaL,J0min_in,T2end,mu,ne,if_write_result)"
  write(ilun,format)"     diff=ne-ne_to_find"
  write(ilun,format)"     if (diff>0.d0) then"
  write(ilun,format)"        J0min_left=0.5*(J0min_left+J0min_right)"
  write(ilun,format)"        J0min_right=J0min_right"
  write(ilun,format)"     else"
  write(ilun,format)"        J0min_left=J0min_left"
  write(ilun,format)"        J0min_right=0.5*(J0min_left+J0min_right)"
  write(ilun,format)"     endif"
  write(ilun,format)"     err_J0min=abs(J0min_right-J0min_left)/J0min_left"
  write(ilun,format)"     niter=niter+1"
  write(ilun,format)"  enddo"
  write(ilun,format)"  if (niter > 100) then"
  write(ilun,format)"     write(*,*) 'ERROR in compute_J0min : too many iterations'"
  write(ilun,format)"     STOP"
  write(ilun,format)"  endif"
  write(ilun,format)"  if (verbose_cooling)  write(*,*) 'J0min found ',J0min_in"
  write(ilun,format)"end subroutine compute_J0min"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"subroutine solve_cooling(nH,T2,zsolar,boost,dt,deltaT2,ncell,LAGN,r)"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"  implicit none  "
  write(ilun,format)"  integer::ncell"
  write(ilun,format)"  real(kind=8)::dt"
  write(ilun,format)"  real(kind=8),dimension(1:ncell)::nH,T2,deltaT2,zsolar,boost,T,r"
  write(ilun,format)"    "
  write(ilun,format)"  real(kind=8)::facT,dlog_nH,dlog_T2,coeff,precoeff,h,h2,h3,mu,T_eps"
  write(ilun,format)"  real(kind=8)::metal,cool,heat,cool_com,heat_com,w1T,w2T,w11,w12,w21,w22,err,yy,yy2,yy3"
  write(ilun,format)"  real(kind=8)::metal_prime,cool_prime,heat_prime,cool_com_prime,heat_com_prime,wcool"
  write(ilun,format)"  real(kind=8)::lambda,lambda_prime,logT2max"
  write(ilun,format)"  real(kind=8)::fa,fb,fprimea,fprimeb,alpha,beta,gamma,LAGN,cool_com_eps"
  write(ilun,format)"  real(kind=8),dimension(1:ncell)::rgt,lft,tau,tau_old"
  write(ilun,format)"  real(kind=8),dimension(1:ncell)::time,time_old,facH,zzz,tau_ini"
  write(ilun,format)"  real(kind=8),dimension(1:ncell)::w1H,w2H,wmax,time_max"
  write(ilun,format)"  real(kind=8)::varmax=4d0"
  write(ilun,format)"  integer::i,i_T2,iter,n,n_active"
  write(ilun,format)"  integer,dimension(1:ncell)::ind,iii,i_nH"
  write(ilun,format)"  logical::tau_negative"
  write(ilun,format)"  "
  write(ilun,format)"  ! Initializations"
  write(ilun,format)"  logT2max=log10(T2_max_fix)"
  write(ilun,format)""
  write(ilun,format)"  ! nH and T2 are cgs here."
  write(ilun,format)"  dlog_nH=dble(table%n1-1)/(table%nH(table%n1)-table%nH(1))"
  write(ilun,format)"  dlog_T2=dble(table%n2-1)/(table%T2(table%n2)-table%T2(1))"
  write(ilun,format)"  "
  write(ilun,format)"  h=1d0/dlog_T2"
  write(ilun,format)"  h2=h*h"
  write(ilun,format)"  h3=h2*h"
  write(ilun,format)"  precoeff=2d0*X/(3d0*kB)"
  write(ilun,format)"  do i=1,ncell"
  write(ilun,format)"     zzz(i)=zsolar(i)"
  write(ilun,format)"     facH(i)=MIN(MAX(log10(nH(i)/boost(i)),table%nH(1)),table%nH(table%n1))"
  write(ilun,format)"     i_nH(i)=MIN(MAX(int((facH(i)-table%nH(1))*dlog_nH)+1,1),table%n1-1)"
  write(ilun,format)"     w1H(i)=(table%nH(i_nH(i)+1)-facH(i))*dlog_nH"
  write(ilun,format)"     w2H(i)=(facH(i)-table%nH(i_nH(i)  ))*dlog_nH"
  write(ilun,format)"     tau(i)=T2(i)"
  write(ilun,format)"     tau_ini(i)=T2(i)"
  write(ilun,format)"     time_max(i)=dt*precoeff*nH(i)"
  write(ilun,format)"     time(i)=0d0"
  write(ilun,format)"     wmax(i)=1d0/time_max(i)"
  write(ilun,format)"     ind(i)=i"
  write(ilun,format)"  end do"
  write(ilun,format)"  "
  write(ilun,format)"  ! Check positivity "
  write(ilun,format)"  tau_negative=.false."
  write(ilun,format)"  do i=1,ncell"
  write(ilun,format)"     if(tau(i)<=0.)tau_negative=.true."
  write(ilun,format)"  end do  "
  write(ilun,format)"  if (tau_negative) then"
  write(ilun,format)"     write(*,*)'ERROR in solve_cooling :'"
  write(ilun,format)"     write(*,*)'Initial temperature is negative'"
  write(ilun,format)"     STOP"
  write(ilun,format)"  endif"
  write(ilun,format)"  "
  write(ilun,format)"  ! Loop over active cells"
  write(ilun,format)"  iter=0"
  write(ilun,format)"  n=ncell"
  write(ilun,format)"  do while(n>0)"
  write(ilun,format)"     "
  write(ilun,format)"     iter=iter+1"
  write(ilun,format)"     if (iter > 500) then"
  write(ilun,format)"        write(*,*) 'Too many iterations in solve_cooling',iter,n"
  write(ilun,format)"        do i=1,n"
  write(ilun,format)"           write(*,*)i,tau(ind(i)),T2(ind(i)),nH(ind(i)),i_nH(ind(i))"
  write(ilun,format)"        end do"
  write(ilun,format)"        STOP"
  write(ilun,format)"     endif"
  write(ilun,format)"     "
  write(ilun,format)"     n_active=0"
  write(ilun,format)"     do i=1,n"
  write(ilun,format)"        facT=log10(tau(ind(i)))"
  write(ilun,format)""
  write(ilun,format)"        if(facT.le.logT2max)then"
  write(ilun,format)""
  write(ilun,format)"           i_T2=MIN(MAX(int((facT-table%T2(1))*dlog_T2)+1,1),table%n2-1)"
  write(ilun,format)"           yy=facT-table%T2(i_T2)"
  write(ilun,format)"           yy2=yy*yy"
  write(ilun,format)"           yy3=yy2*yy"
  write(ilun,format)""
  write(ilun,format)"           ! Cooling"
  write(ilun,format)"           fa=table%cool(i_nH(ind(i)),i_T2  )*w1H(ind(i))+table%cool(i_nH(ind(i))+1,i_T2  )*w2H(ind(i))"
  write(ilun,format)"           fb=table%cool(i_nH(ind(i)),i_T2+1)*w1H(ind(i))+table%cool(i_nH(ind(i))+1,i_T2+1)*w2H(ind(i))"
  write(ilun,format)"           fprimea=table%cool_prime(i_nH(ind(i)),i_T2  )*w1H(ind(i))+table%cool_prime(i_nH(ind(i))+1,i_T2  )*w2H(ind(i))"
  write(ilun,format)"           fprimeb=table%cool_prime(i_nH(ind(i)),i_T2+1)*w1H(ind(i))+table%cool_prime(i_nH(ind(i))+1,i_T2+1)*w2H(ind(i))"
  write(ilun,format)"           alpha=fprimea"
  write(ilun,format)"           beta=3d0*(fb-fa)/h2-(2d0*fprimea+fprimeb)/h"
  write(ilun,format)"           gamma=(fprimea+fprimeb)/h2-2d0*(fb-fa)/h3"
  write(ilun,format)"           cool=10d0**(fa+alpha*yy+beta*yy2+gamma*yy3)"
  write(ilun,format)"           cool_prime=cool/tau(ind(i))*(alpha+2d0*beta*yy+3d0*gamma*yy2)"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"           ! Heating"
  write(ilun,format)"           fa=table%heat(i_nH(ind(i)),i_T2  )*w1H(ind(i))+table%heat(i_nH(ind(i))+1,i_T2  )*w2H(ind(i))"
  write(ilun,format)"           fb=table%heat(i_nH(ind(i)),i_T2+1)*w1H(ind(i))+table%heat(i_nH(ind(i))+1,i_T2+1)*w2H(ind(i))"
  write(ilun,format)"           fprimea=table%heat_prime(i_nH(ind(i)),i_T2  )*w1H(ind(i))+table%heat_prime(i_nH(ind(i))+1,i_T2  )*w2H(ind(i))"
  write(ilun,format)"           fprimeb=table%heat_prime(i_nH(ind(i)),i_T2+1)*w1H(ind(i))+table%heat_prime(i_nH(ind(i))+1,i_T2+1)*w2H(ind(i))"
  write(ilun,format)"           alpha=fprimea"
  write(ilun,format)"           beta=3d0*(fb-fa)/h2-(2d0*fprimea+fprimeb)/h"
  write(ilun,format)"           gamma=(fprimea+fprimeb)/h2-2d0*(fb-fa)/h3"
  write(ilun,format)"           heat=10d0**(fa+alpha*yy+beta*yy2+gamma*yy3)"
  write(ilun,format)"           heat_prime=heat/tau(ind(i))*(alpha+2d0*beta*yy+3d0*gamma*yy2)"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"           !  replace Compton heating and cooling terms"
  write(ilun,format)"	   ! interpolated from table to terms directly calculated"
  write(ilun,format)"	   ! given LAGN, r."
  write(ilun,format)""
  write(ilun,format)"           ! Compton cooling"
  write(ilun,format)"           !fa=table%cool_com(i_nH(ind(i)),i_T2  )*w1H(ind(i))+table%cool_com(i_nH(ind(i))+1,i_T2  )*w2H(ind(i))"
  write(ilun,format)"           !fb=table%cool_com(i_nH(ind(i)),i_T2+1)*w1H(ind(i))+table%cool_com(i_nH(ind(i))+1,i_T2+1)*w2H(ind(i))"
  write(ilun,format)"           !fprimea=table%cool_com_prime(i_nH(ind(i)),i_T2  )*w1H(ind(i))+table%cool_com_prime(i_nH(ind(i))+1,i_T2  )*w2H(ind(i))"
  write(ilun,format)"           !fprimeb=table%cool_com_prime(i_nH(ind(i)),i_T2+1)*w1H(ind(i))+table%cool_com_prime(i_nH(ind(i))+1,i_T2+1)*w2H(ind(i))"
  write(ilun,format)"           !alpha=fprimea"
  write(ilun,format)"           !beta=3d0*(fb-fa)/h2-(2d0*fprimea+fprimeb)/h"
  write(ilun,format)"           !gamma=(fprimea+fprimeb)/h2-2d0*(fb-fa)/h3"
  write(ilun,format)"           !cool_com=10d0**(fa+alpha*yy+beta*yy2+gamma*yy3)"
  write(ilun,format)"           !cool_com_prime=cool_com/tau(ind(i))*(alpha+2d0*beta*yy+3d0*gamma*yy2)"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"	   ! T is in K"
  write(ilun,format)"	   ! Define LAGN and r to be cgs"
  write(ilun,format)"	   ! "
  write(ilun,format)"	   ! cool_com must be cgs, too, before taking the log."
  write(ilun,format)"	   T(i) = T2(i)*0.61 ! assume mean molecular weight for fully ionized gas"
  write(ilun,format)"	                     ! not nec. always appropriate, so should"
  write(ilun,format)"			     ! use self-consistent value given"
  write(ilun,format)"			     ! ionization state by calling cmp_chem_eq()"
  write(ilun,format)"	   "
  write(ilun,format)""
  write(ilun,format)"	   ! Turn off Compton cooling for SNR simulations. "
  write(ilun,format)"	   !cool_com = cool_compton(T(i),LAGN,r(i))"
  write(ilun,format)"           cool_com = 0.0"
  write(ilun,format)""
  write(ilun,format)"	   T_eps = 10d0**(log10(T(i)) + 0.01)"
  write(ilun,format)"	   cool_com_eps = cool_compton(T_eps,LAGN,r(i))"
  write(ilun,format)""
  write(ilun,format)"	   !cool_com_prime = (cool_com_eps-cool_com)/(T_eps - T(i))"
  write(ilun,format)"           cool_com_prime = 0.0"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"           !write(*,*) 'cool_com='"
  write(ilun,format)"	   !write(*,*) cool_com"
  write(ilun,format)"	   !write(*,*) 'cool_com_prime='"
  write(ilun,format)"	   !write(*,*) cool_com_prime"
  write(ilun,format)""
  write(ilun,format)"	   !call exit()"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"           ! Compton heating"
  write(ilun,format)"           !fa=table%heat_com(i_nH(ind(i)),i_T2  )*w1H(ind(i))+table%heat_com(i_nH(ind(i))+1,i_T2  )*w2H(ind(i))"
  write(ilun,format)"           !fb=table%heat_com(i_nH(ind(i)),i_T2+1)*w1H(ind(i))+table%heat_com(i_nH(ind(i))+1,i_T2+1)*w2H(ind(i))"
  write(ilun,format)"           !fprimea=table%heat_com_prime(i_nH(ind(i)),i_T2  )*w1H(ind(i))+table%heat_com_prime(i_nH(ind(i))+1,i_T2  )*w2H(ind(i))"
  write(ilun,format)"           !fprimeb=table%heat_com_prime(i_nH(ind(i)),i_T2+1)*w1H(ind(i))+table%heat_com_prime(i_nH(ind(i))+1,i_T2+1)*w2H(ind(i))"
  write(ilun,format)"           !alpha=fprimea"
  write(ilun,format)"           !beta=3d0*(fb-fa)/h2-(2d0*fprimea+fprimeb)/h"
  write(ilun,format)"           !gamma=(fprimea+fprimeb)/h2-2d0*(fb-fa)/h3"
  write(ilun,format)"           !heat_com=10d0**(fa+alpha*yy+beta*yy2+gamma*yy3)"
  write(ilun,format)"           !heat_com_prime=heat_com/tau(ind(i))*(alpha+2d0*beta*yy+3d0*gamma*yy2)"
  write(ilun,format)""
  write(ilun,format)"	   !  neglect Compton heating, for now."
  write(ilun,format)"	   heat_com = 0.0"
  write(ilun,format)"	   heat_com_prime = 0.0"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"           ! Metal cooling"
  write(ilun,format)"           fa=table%metal(i_nH(ind(i)),i_T2  )*w1H(ind(i))+table%metal(i_nH(ind(i))+1,i_T2  )*w2H(ind(i))"
  write(ilun,format)"           fb=table%metal(i_nH(ind(i)),i_T2+1)*w1H(ind(i))+table%metal(i_nH(ind(i))+1,i_T2+1)*w2H(ind(i))"
  write(ilun,format)"           fprimea=table%metal_prime(i_nH(ind(i)),i_T2  )*w1H(ind(i))+table%metal_prime(i_nH(ind(i))+1,i_T2  )*w2H(ind(i))"
  write(ilun,format)"           fprimeb=table%metal_prime(i_nH(ind(i)),i_T2+1)*w1H(ind(i))+table%metal_prime(i_nH(ind(i))+1,i_T2+1)*w2H(ind(i))"
  write(ilun,format)"           alpha=fprimea"
  write(ilun,format)"           beta=3d0*(fb-fa)/h2-(2d0*fprimea+fprimeb)/h"
  write(ilun,format)"           gamma=(fprimea+fprimeb)/h2-2d0*(fb-fa)/h3"
  write(ilun,format)"           metal=10d0**(fa+alpha*yy+beta*yy2+gamma*yy3)"
  write(ilun,format)"           metal_prime=metal/tau(ind(i))*(alpha+2d0*beta*yy+3d0*gamma*yy2)"
  write(ilun,format)""
  write(ilun,format)"           ! Total net cooling"
  write(ilun,format)"           lambda=cool+zzz(ind(i))*metal-heat+(cool_com-heat_com)/nH(ind(i))"
  write(ilun,format)"           lambda_prime=cool_prime+zzz(ind(i))*metal_prime-heat_prime+(cool_com_prime-heat_com_prime)/nH(ind(i))"
  write(ilun,format)""
  write(ilun,format)"        else"
  write(ilun,format)""
  write(ilun,format)"           !  this is cgs for high-temperature free free, so"
  write(ilun,format)"	   ! cooling and heating rates in this function must be cgs."
  write(ilun,format)""
  write(ilun,format)"           lambda=1.42*1d-27*sqrt(tau(ind(i)))*1.1"
  write(ilun,format)"           lambda_prime=lambda/2./tau(ind(i))"
  write(ilun,format)""
  write(ilun,format)"        endif"
  write(ilun,format)""
  write(ilun,format)"        wcool=MAX(abs(lambda)/tau(ind(i))*varmax,wmax(ind(i)),-lambda_prime*varmax)"
  write(ilun,format)""
  write(ilun,format)"        tau_old(ind(i))=tau(ind(i))"
  write(ilun,format)"        tau(ind(i))=tau(ind(i))*(1d0+lambda_prime/wcool-lambda/tau(ind(i))/wcool)/(1d0+lambda_prime/wcool)"
  write(ilun,format)"        time_old(ind(i))=time(ind(i))"
  write(ilun,format)"        time(ind(i))=time(ind(i))+1d0/wcool"
  write(ilun,format)""
  write(ilun,format)"        if(time(ind(i))<time_max(ind(i)))then"
  write(ilun,format)"           n_active=n_active+1"
  write(ilun,format)"           ind(n_active)=ind(i)"
  write(ilun,format)"        end if"
  write(ilun,format)"        "
  write(ilun,format)"     end do"
  write(ilun,format)"     n=n_active"
  write(ilun,format)"  end do"
  write(ilun,format)"  ! End loop over active cells"
  write(ilun,format)""
  write(ilun,format)"  ! Compute exact time solution"
  write(ilun,format)"  do i=1,ncell"
  write(ilun,format)"     tau(i)=tau(i)*(time_max(i)-time_old(i))/(time(i)-time_old(i))+tau_old(i)*(time(i)-time_max(i))/(time(i)-time_old(i))"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Check positivity "
  write(ilun,format)"  tau_negative=.false."
  write(ilun,format)"  do i=1,ncell"
  write(ilun,format)"     if (tau(i)<=0.)tau_negative=.true."
  write(ilun,format)"  end do  "
  write(ilun,format)"  if (tau_negative) then"
  write(ilun,format)"     write(*,*)'ERROR in solve_cooling :'"
  write(ilun,format)"     write(*,*)'Final temperature is negative'"
  write(ilun,format)"     STOP"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  ! Compute delta T"
  write(ilun,format)"  do i=1,ncell"
  write(ilun,format)"     deltaT2(i)=tau(i)-tau_ini(i)"
  write(ilun,format)"  end do"
  write(ilun,format)"  "
  write(ilun,format)"end subroutine solve_cooling"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"function J0simple(aexp)"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"! Le J0 dans le cas teyssier ou theuns"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"  real(kind=8) :: J0simple,aexp"
  write(ilun,format)"  if (aexp .lt. 1.d0/(1d0+zreioniz)) then"
  write(ilun,format)"     J0simple=0.d0"
  write(ilun,format)"  elseif (aexp .lt. 1.d0/4.d0)then"
  write(ilun,format)"     J0simple=4.d0*aexp"
  write(ilun,format)"  elseif (aexp .lt. 1.d0/3.d0)then"
  write(ilun,format)"     J0simple=1.d0"
  write(ilun,format)"  else"
  write(ilun,format)"     J0simple=1.d0/(3.*aexp)**3"
  write(ilun,format)"  endif"
  write(ilun,format)"  if(force_j0_one)J0simple=1.0"
  write(ilun,format)"  J0simple=max(J0simple*J0in,J0min)"
  write(ilun,format)"  return"
  write(ilun,format)"end function J0simple"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"subroutine cmp_table(nH_min,nH_max,T2_min,T2_max,nbin_n,nbin_T,aexp)"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  real(kind=8)::nH_min,nH_max,T2_min,T2_max,aexp,tmp"
  write(ilun,format)"  integer::nbin_n,nbin_T"
  write(ilun,format)"  integer::myid,ncpu,ierr"
  write(ilun,format)"  integer::i_n,i_T"
  write(ilun,format)"  real(kind=8),dimension(1:3)::t_rad_spec,h_rad_spec"
  write(ilun,format)"  integer :: i,j,n1,n2"
  write(ilun,format)"  logical,save:: first=.true."
  write(ilun,format)"  "
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  call MPI_COMM_RANK(MPI_COMM_WORLD,myid,ierr)"
  write(ilun,format)"  call MPI_COMM_SIZE(MPI_COMM_WORLD,ncpu,ierr)"
  write(ilun,format)"#endif"
  write(ilun,format)"#ifdef WITHOUTMPI"
  write(ilun,format)"  myid=0"
  write(ilun,format)"  ncpu=1"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  if(.not.first)then"
  write(ilun,format)"     deallocate(table%cool)"
  write(ilun,format)"     deallocate(table%heat)"
  write(ilun,format)"     deallocate(table%cool_com)"
  write(ilun,format)"     deallocate(table%heat_com)"
  write(ilun,format)"     deallocate(table%metal)"
  write(ilun,format)"     deallocate(table%cool_prime)"
  write(ilun,format)"     deallocate(table%heat_prime)"
  write(ilun,format)"     deallocate(table%cool_com_prime)"
  write(ilun,format)"     deallocate(table%heat_com_prime)"
  write(ilun,format)"     deallocate(table%metal_prime)"
  write(ilun,format)"     deallocate(table%mu)"
  write(ilun,format)"     deallocate(table%T2)"
  write(ilun,format)"     deallocate(table%nH)"
  write(ilun,format)"     if (if_species_abundances) deallocate(table%n_spec)"
  write(ilun,format)"  else"
  write(ilun,format)"     first=.false."
  write(ilun,format)"  endif"
  write(ilun,format)"  "
  write(ilun,format)"  table%n1=nbin_n"
  write(ilun,format)"  table%n2=nbin_T"
  write(ilun,format)"  allocate(table%cool(nbin_n,nbin_T))"
  write(ilun,format)"  allocate(table%heat(nbin_n,nbin_T))"
  write(ilun,format)"  allocate(table%cool_com(nbin_n,nbin_T))"
  write(ilun,format)"  allocate(table%heat_com(nbin_n,nbin_T))"
  write(ilun,format)"  allocate(table%metal(nbin_n,nbin_T))"
  write(ilun,format)"  allocate(table%cool_prime(nbin_n,nbin_T))"
  write(ilun,format)"  allocate(table%heat_prime(nbin_n,nbin_T))"
  write(ilun,format)"  allocate(table%cool_com_prime(nbin_n,nbin_T))"
  write(ilun,format)"  allocate(table%heat_com_prime(nbin_n,nbin_T))"
  write(ilun,format)"  allocate(table%metal_prime(nbin_n,nbin_T))"
  write(ilun,format)"  allocate(table%mu  (nbin_n,nbin_T))"
  write(ilun,format)"  allocate(table%nH  (1:nbin_n))"
  write(ilun,format)"  allocate(table%T2  (1:nbin_T))"
  write(ilun,format)"  if (if_species_abundances) allocate(table%n_spec(nbin_n,nbin_T,1:6))"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  allocate(table2%cool(nbin_n,nbin_T))"
  write(ilun,format)"  allocate(table2%heat(nbin_n,nbin_T))"
  write(ilun,format)"  allocate(table2%cool_com(nbin_n,nbin_T))"
  write(ilun,format)"  allocate(table2%heat_com(nbin_n,nbin_T))"
  write(ilun,format)"  allocate(table2%metal(nbin_n,nbin_T))"
  write(ilun,format)"  allocate(table2%cool_prime(nbin_n,nbin_T))"
  write(ilun,format)"  allocate(table2%heat_prime(nbin_n,nbin_T))"
  write(ilun,format)"  allocate(table2%cool_com_prime(nbin_n,nbin_T))"
  write(ilun,format)"  allocate(table2%heat_com_prime(nbin_n,nbin_T))"
  write(ilun,format)"  allocate(table2%metal_prime(nbin_n,nbin_T))"
  write(ilun,format)"  allocate(table2%mu  (nbin_n,nbin_T))"
  write(ilun,format)"  if (if_species_abundances) allocate(table2%n_spec(nbin_n,nbin_T,1:6))"
  write(ilun,format)"#endif  "
  write(ilun,format)"  do i_n=1,nbin_n"
  write(ilun,format)"     tmp=log10(nH_min)+(dble(i_n)-1d0)/(dble(nbin_n)-1d0)*(log10(nH_max)-log10(nH_min))"
  write(ilun,format)"     table%nH(i_n)=tmp"
  write(ilun,format)"  end do"
  write(ilun,format)"  do i_T=1,nbin_T"
  write(ilun,format)"     tmp=log10(T2_min)+(dble(i_T)-1d0)/(dble(nbin_T)-1d0)*(log10(T2_max)-log10(T2_min))"
  write(ilun,format)"     table%T2(i_T)=tmp"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Compute radiative ionization and heating rates"
  write(ilun,format)"  call set_rates(t_rad_spec,h_rad_spec,aexp)"
  write(ilun,format)""
  write(ilun,format)"  ! Create the table"
  write(ilun,format)"  table%mu=0.0"
  write(ilun,format)"  table%cool=0.0"
  write(ilun,format)"  table%heat=0.0"
  write(ilun,format)"  table%cool_com=0.0"
  write(ilun,format)"  table%heat_com=0.0"
  write(ilun,format)"  table%metal=0.0"
  write(ilun,format)"  table%cool_prime=0.0"
  write(ilun,format)"  table%heat_prime=0.0"
  write(ilun,format)"  table%cool_com_prime=0.0"
  write(ilun,format)"  table%heat_com_prime=0.0"
  write(ilun,format)"  table%metal_prime=0.0"
  write(ilun,format)"  if (if_species_abundances) table%n_spec=0.0"
  write(ilun,format)"  do i_n = myid+1,nbin_n,ncpu"
  write(ilun,format)"     call iterate(i_n,t_rad_spec,h_rad_spec,nbin_T,aexp)"
  write(ilun,format)"  end do"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  call MPI_ALLREDUCE(table%mu,table2%mu,nbin_n*nbin_T,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierr)"
  write(ilun,format)"  call MPI_ALLREDUCE(table%cool,table2%cool,nbin_n*nbin_T,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierr)"
  write(ilun,format)"  call MPI_ALLREDUCE(table%heat,table2%heat,nbin_n*nbin_T,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierr)"
  write(ilun,format)"  call MPI_ALLREDUCE(table%cool_com,table2%cool_com,nbin_n*nbin_T,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierr)"
  write(ilun,format)"  call MPI_ALLREDUCE(table%heat_com,table2%heat_com,nbin_n*nbin_T,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierr)"
  write(ilun,format)"  call MPI_ALLREDUCE(table%metal,table2%metal,nbin_n*nbin_T,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierr)"
  write(ilun,format)"  call MPI_ALLREDUCE(table%cool_prime,table2%cool_prime,nbin_n*nbin_T,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierr)"
  write(ilun,format)"  call MPI_ALLREDUCE(table%heat_prime,table2%heat_prime,nbin_n*nbin_T,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierr)"
  write(ilun,format)"  call MPI_ALLREDUCE(table%cool_com_prime,table2%cool_com_prime,nbin_n*nbin_T,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierr)"
  write(ilun,format)"  call MPI_ALLREDUCE(table%heat_com_prime,table2%heat_com_prime,nbin_n*nbin_T,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierr)"
  write(ilun,format)"  call MPI_ALLREDUCE(table%metal_prime,table2%metal_prime,nbin_n*nbin_T,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierr)"
  write(ilun,format)"  if (if_species_abundances)then"
  write(ilun,format)"     call MPI_ALLREDUCE(table%n_spec,table2%n_spec,6*nbin_n*nbin_T,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,ierr)"
  write(ilun,format)"  end if"
  write(ilun,format)"  table%cool = table2%cool"
  write(ilun,format)"  table%heat = table2%heat"
  write(ilun,format)"  table%cool_com = table2%cool_com"
  write(ilun,format)"  table%heat_com = table2%heat_com"
  write(ilun,format)"  table%metal = table2%metal"
  write(ilun,format)"  table%cool_prime = table2%cool_prime"
  write(ilun,format)"  table%heat_prime = table2%heat_prime"
  write(ilun,format)"  table%cool_com_prime = table2%cool_com_prime"
  write(ilun,format)"  table%heat_com_prime = table2%heat_com_prime"
  write(ilun,format)"  table%metal_prime = table2%metal_prime"
  write(ilun,format)"  table%mu = table2%mu"
  write(ilun,format)"  if (if_species_abundances)then"
  write(ilun,format)"     table%n_spec=table2%n_spec"
  write(ilun,format)"  endif"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  deallocate(table2%cool)"
  write(ilun,format)"  deallocate(table2%heat)"
  write(ilun,format)"  deallocate(table2%cool_com)"
  write(ilun,format)"  deallocate(table2%heat_com)"
  write(ilun,format)"  deallocate(table2%metal)"
  write(ilun,format)"  deallocate(table2%cool_prime)"
  write(ilun,format)"  deallocate(table2%heat_prime)"
  write(ilun,format)"  deallocate(table2%cool_com_prime)"
  write(ilun,format)"  deallocate(table2%heat_com_prime)"
  write(ilun,format)"  deallocate(table2%metal_prime)"
  write(ilun,format)"  deallocate(table2%mu)"
  write(ilun,format)"  if (if_species_abundances)then"
  write(ilun,format)"     deallocate(table2%n_spec)"
  write(ilun,format)"  endif"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"end subroutine cmp_table"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"subroutine set_rates(t_rad_spec,h_rad_spec,aexp)"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"  implicit none"
  write(ilun,format)"  real(kind=8),dimension(1:3) :: t_rad_spec,h_rad_spec"
  write(ilun,format)"  real(kind=8) :: J0,z,aexp"
  write(ilun,format)"  logical :: first=.true."
  write(ilun,format)"  save first"
  write(ilun,format)""
  write(ilun,format)"  z=1.d0/aexp-1.D0"
  write(ilun,format)"  if (high_z_realistic_ne) J0min=J0min_ref/(aexp/aexp_ref)**2"
  write(ilun,format)"  if (teyssier) then"
  write(ilun,format)"     J0=J0simple(aexp)"
  write(ilun,format)"     t_rad_spec(HI  ) = taux_rad(HI  ,J0)"
  write(ilun,format)"     t_rad_spec(HEI ) = taux_rad(HEI ,J0)"
  write(ilun,format)"     t_rad_spec(HEII) = taux_rad(HEII,J0)"
  write(ilun,format)"     h_rad_spec(HI  ) = heat_rad(HI  ,J0)"
  write(ilun,format)"     h_rad_spec(HEI ) = heat_rad(HEI ,J0)"
  write(ilun,format)"     h_rad_spec(HEII) = heat_rad(HEII,J0)"
  write(ilun,format)"  elseif (theuns) then"
  write(ilun,format)"     J0=J0simple(aexp)"
  write(ilun,format)"     t_rad_spec(HI  ) = taux_rad_theuns(HI  ,J0)"
  write(ilun,format)"     t_rad_spec(HEI ) = taux_rad_theuns(HEI ,J0)"
  write(ilun,format)"     t_rad_spec(HEII) = taux_rad_theuns(HEII,J0)"
  write(ilun,format)"     h_rad_spec(HI  ) = heat_rad_theuns(HI  ,J0)"
  write(ilun,format)"     h_rad_spec(HEI ) = heat_rad_theuns(HEI ,J0)"
  write(ilun,format)"     h_rad_spec(HEII) = heat_rad_theuns(HEII,J0)"
  write(ilun,format)"  elseif (madau) then"
  write(ilun,format)"     z=1.d0/aexp-1.D0"
  write(ilun,format)"     t_rad_spec(HI  ) = taux_rad_madau(HI  ,z)"
  write(ilun,format)"     t_rad_spec(HEI ) = taux_rad_madau(HEI ,z)"
  write(ilun,format)"     t_rad_spec(HEII) = taux_rad_madau(HEII,z)"
  write(ilun,format)"     h_rad_spec(HI  ) = heat_rad_madau(HI  ,z)"
  write(ilun,format)"     h_rad_spec(HEI ) = heat_rad_madau(HEI ,z)"
  write(ilun,format)"     h_rad_spec(HEII) = heat_rad_madau(HEII,z)     "
  write(ilun,format)"  elseif (weinbergint) then"
  write(ilun,format)"     t_rad_spec(HI  ) = taux_rad_weinbergint(HI  ,z)"
  write(ilun,format)"     t_rad_spec(HEI ) = taux_rad_weinbergint(HEI ,z)"
  write(ilun,format)"     t_rad_spec(HEII) = taux_rad_weinbergint(HEII,z)"
  write(ilun,format)"     h_rad_spec(HI  ) = heat_rad_weinbergint(HI  ,z)"
  write(ilun,format)"     h_rad_spec(HEI ) = heat_rad_weinbergint(HEI ,z)"
  write(ilun,format)"     h_rad_spec(HEII) = heat_rad_weinbergint(HEII,z)     "
  write(ilun,format)"  elseif (courty) then"
  write(ilun,format)"     t_rad_spec(HI  ) = taux_rad_courty(HI  ,z)"
  write(ilun,format)"     t_rad_spec(HEI ) = taux_rad_courty(HEI ,z)"
  write(ilun,format)"     t_rad_spec(HEII) = taux_rad_courty(HEII,z)"
  write(ilun,format)"     h_rad_spec(HI  ) = heat_rad_courty(HI  ,z)"
  write(ilun,format)"     h_rad_spec(HEI ) = heat_rad_courty(HEI ,z)"
  write(ilun,format)"     h_rad_spec(HEII) = heat_rad_courty(HEII,z)"
  write(ilun,format)"  endif  "
  write(ilun,format)"end subroutine set_rates"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"subroutine iterate(i_n,t_rad_spec,h_rad_spec,nbin_T,aexp)"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer :: i_n"
  write(ilun,format)"  real(kind=8),dimension(1:3)::t_rad_spec,h_rad_spec"
  write(ilun,format)"  real(kind=8) :: aexp"
  write(ilun,format)"  integer::nbin_T    "
  write(ilun,format)"  integer::i_T"
  write(ilun,format)"  real(kind=8) ::T2,T2_eps,nH"
  write(ilun,format)"  real(kind=8) ::mu,mu_eps"
  write(ilun,format)"  real(kind=8) ::T2_left,T2_right,err_T2"
  write(ilun,format)"  real(kind=8) ::cool_tot,heat_tot,cool_com,heat_com,metal_tot,metal_prime"
  write(ilun,format)"  real(kind=8) ::cool_tot_eps,heat_tot_eps,cool_com_eps,heat_com_eps,metal_tot_eps"
  write(ilun,format)"  real(kind=8) ::diff"
  write(ilun,format)"  integer::niter"
  write(ilun,format)"  real(kind=8),dimension(1:6) :: n_spec,n_spec_eps"
  write(ilun,format)"  "
  write(ilun,format)"  nH=10d0**table%nH(i_n)         "
  write(ilun,format)"  do i_T = 1,nbin_T"
  write(ilun,format)"     T2=10d0**table%T2(i_T)"
  write(ilun,format)"     ! Compute cooling, heating and mean molecular weight"
  write(ilun,format)"     call cmp_cooling(T2,nH,t_rad_spec,h_rad_spec,cool_tot,heat_tot,cool_com,heat_com,mu,aexp,n_spec)"
  write(ilun,format)"     table%cool(i_n,i_T)=log10(cool_tot)"
  write(ilun,format)"     table%heat(i_n,i_T)=log10(heat_tot)"
  write(ilun,format)"     table%cool_com(i_n,i_T)=log10(cool_com)"
  write(ilun,format)"     table%heat_com(i_n,i_T)=log10(heat_com)"
  write(ilun,format)"     table%mu(i_n,i_T)=mu"
  write(ilun,format)"     if (if_species_abundances)then"
  write(ilun,format)"        table%n_spec(i_n,i_T,1:6)=log10(n_spec(1:6))"
  write(ilun,format)"     endif"
  write(ilun,format)"     ! Compute cooling and heating derivatives"
  write(ilun,format)"     T2_eps=10d0**(table%T2(i_T)+0.01d0)"
  write(ilun,format)"     call cmp_cooling(T2_eps,nH,t_rad_spec,h_rad_spec,cool_tot_eps,heat_tot_eps,cool_com_eps,heat_com_eps,mu_eps,aexp,n_spec_eps)"
  write(ilun,format)"     table%cool_prime(i_n,i_T)=(log10(cool_tot_eps)-log10(cool_tot))/0.01"
  write(ilun,format)"     table%heat_prime(i_n,i_T)=(log10(heat_tot_eps)-log10(heat_tot))/0.01"
  write(ilun,format)"     table%cool_com_prime(i_n,i_T)=(log10(cool_com_eps)-log10(cool_com))/0.01"
  write(ilun,format)"     table%heat_com_prime(i_n,i_T)=(log10(heat_com_eps)-log10(heat_com))/0.01"
  write(ilun,format)"     ! Compute metal contribution for solar metallicity"
  write(ilun,format)"     call cmp_metals(T2,nH,mu,metal_tot,metal_prime,aexp)"
  write(ilun,format)"     table%metal(i_n,i_T)=log10(metal_tot)"
  write(ilun,format)"     table%metal_prime(i_n,i_T)=metal_prime"
  write(ilun,format)"  end do"
  write(ilun,format)"end subroutine iterate"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"subroutine cmp_metals(T2,nH,mu,metal_tot,metal_prime,aexp)"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"  implicit none"
  write(ilun,format)"  real(kind=8) ::T2,nH,mu,metal_tot,metal_prime,aexp"
  write(ilun,format)"  ! Compute cooling enhancement due to metals                                                "
  write(ilun,format)"  ! Sutherland and Dopita (93) at solar metalicity                                           "
  write(ilun,format)"  real(kind=8),dimension(1:91) :: temperature_sd93 = (/ &"
  write(ilun,format)"       & 4.00,4.05,4.10,4.15,4.20,4.25,4.30,4.35,4.40,4.45,4.50,4.55,4.60, &"
  write(ilun,format)"       & 4.65,4.70,4.75,4.80,4.85,4.90,4.95,5.00,5.05,5.10,5.15,5.20,5.25, &"
  write(ilun,format)"       & 5.30,5.35,5.40,5.45,5.50,5.55,5.60,5.65,5.70,5.75,5.80,5.85,5.90, &"
  write(ilun,format)"       & 5.95,6.00,6.05,6.10,6.15,6.20,6.25,6.30,6.35,6.40,6.45,6.50,6.55, &"
  write(ilun,format)"       & 6.60,6.65,6.70,6.75,6.80,6.85,6.90,6.95,7.00,7.05,7.10,7.15,7.20, &"
  write(ilun,format)"       & 7.25,7.30,7.35,7.40,7.45,7.50,7.55,7.60,7.65,7.70,7.75,7.80,7.85, &"
  write(ilun,format)"       & 7.90,7.95,8.00,8.05,8.10,8.15,8.20,8.25,8.30,8.35,8.40,8.45,8.50  /)"
  write(ilun,format)"  real(kind=8),dimension(1:91) :: excess_cooling_sd93 = (/ &"
  write(ilun,format)"       & -25.8772,-24.4777,-23.6389,-22.9812,-22.5772,-22.3998,-22.3194, &"
  write(ilun,format)"       & -22.2163,-22.0605,-21.9099,-21.7450,-21.6143,-21.4835,-21.3623, &"
  write(ilun,format)"       & -21.2572,-21.1564,-21.0694,-20.9940,-20.9351,-20.8923,-20.8885, &"
  write(ilun,format)"       & -20.9153,-20.9224,-20.8994,-20.8669,-20.8556,-20.8446,-20.8439, &"
  write(ilun,format)"       & -20.8736,-21.0144,-21.2366,-21.4396,-21.5513,-21.5916,-21.6013, &"
  write(ilun,format)"       & -21.6008,-21.6516,-21.7543,-21.8264,-21.8468,-21.8572,-21.8572, &"
  write(ilun,format)"       & -21.8468,-21.8364,-21.8364,-21.8681,-21.9734,-22.1119,-22.2315, &"
  write(ilun,format)"       & -22.3230,-22.3814,-22.4178,-22.4549,-22.4950,-22.5342,-22.5645, &"
  write(ilun,format)"       & -22.5960,-22.5991,-22.5791,-22.5723,-22.5756,-22.5962,-22.6461, &"
  write(ilun,format)"       & -22.7149,-22.7740,-22.8215,-22.8739,-22.9121,-22.9331,-22.9689, &"
  write(ilun,format)"       & -22.9721,-23.0007,-23.0063,-22.9863,-22.9929,-22.9729,-22.9994, &"
  write(ilun,format)"       & -22.9794,-22.9594,-22.9696,-22.9712,-22.9512,-22.9312,-22.9112, &"
  write(ilun,format)"       & -22.9145,-22.8945,-22.8745,-22.8798,-22.8598,-22.8398,-22.8472  /)"
  write(ilun,format)"  real(kind=8),dimension(1:91) :: excess_prime_sd93 = (/ &"
  write(ilun,format)"       & 33.5968475,22.3829498,14.9650421,10.6169891, 5.8140259, 2.5779724, &"
  write(ilun,format)"       & 1.8350220, 2.5890045, 3.0639954, 3.1549835, 2.9560089, 2.6150055, &"
  write(ilun,format)"       & 2.5199890, 2.2629852, 2.0589905, 1.8779907, 1.6240082, 1.3430023, &"
  write(ilun,format)"       & 1.0169983, 0.4660034,-0.2300110,-0.3390045, 0.1589813, 0.5549927, &"
  write(ilun,format)"       & 0.4380035, 0.2229919, 0.1170044,-0.2899933,-1.7050018,-3.6300049, &"
  write(ilun,format)"       & -4.2519836,-3.1469879,-1.5200043,-0.4999847,-0.0919800,-0.5030060, &"
  write(ilun,format)"       & -1.5350037,-1.7480164,-0.9250031,-0.3079987,-0.1040039, 0.1040039, &"
  write(ilun,format)"       & 0.2080078, 0.1040039,-0.3169861,-1.3700104,-2.4380188,-2.5809937, &"
  write(ilun,format)"       & -2.1109924,-1.4989929,-0.9480133,-0.7350159,-0.7720032,-0.7930145, &"
  write(ilun,format)"       & -0.6950073,-0.6180115,-0.3460083, 0.1690063, 0.2679901, 0.0350037, &"
  write(ilun,format)"       & -0.2390137,-0.7050018,-1.1869659,-1.2790070,-1.0660248,-0.9989929, &"
  write(ilun,format)"       & -0.9059906,-0.5919952,-0.5680084,-0.3899994,-0.3179932,-0.3419952, &"
  write(ilun,format)"       & 0.1439972, 0.1339722, 0.1339874,-0.0649872,-0.0650024, 0.3999939, &"
  write(ilun,format)"       & 0.0980072,-0.1180115, 0.1840057, 0.4000092, 0.4000092, 0.1670074, &"
  write(ilun,format)"       & 0.1669769, 0.3999939, 0.1470032, 0.1470032, 0.4000244, 0.1260071, &"
  write(ilun,format)"       & 0.0000000 /)"
  write(ilun,format)"  ! Compute cooling enhancement due to metals"
  write(ilun,format)"  ! Cloudy at solar metalicity"
  write(ilun,format)"  real(kind=8),dimension(1:91) :: temperature_cc07 = (/ &"
  write(ilun,format)"       & 3.9684,4.0187,4.0690,4.1194,4.1697,4.2200,4.2703, &"
  write(ilun,format)"       & 4.3206,4.3709,4.4212,4.4716,4.5219,4.5722,4.6225, &"
  write(ilun,format)"       & 4.6728,4.7231,4.7734,4.8238,4.8741,4.9244,4.9747, &"
  write(ilun,format)"       & 5.0250,5.0753,5.1256,5.1760,5.2263,5.2766,5.3269, &"
  write(ilun,format)"       & 5.3772,5.4275,5.4778,5.5282,5.5785,5.6288,5.6791, &"
  write(ilun,format)"       & 5.7294,5.7797,5.8300,5.8804,5.9307,5.9810,6.0313, &"
  write(ilun,format)"       & 6.0816,6.1319,6.1822,6.2326,6.2829,6.3332,6.3835, &"
  write(ilun,format)"       & 6.4338,6.4841,6.5345,6.5848,6.6351,6.6854,6.7357, &"
  write(ilun,format)"       & 6.7860,6.8363,6.8867,6.9370,6.9873,7.0376,7.0879, &"
  write(ilun,format)"       & 7.1382,7.1885,7.2388,7.2892,7.3395,7.3898,7.4401, &"
  write(ilun,format)"       & 7.4904,7.5407,7.5911,7.6414,7.6917,7.7420,7.7923, &"
  write(ilun,format)"       & 7.8426,7.8929,7.9433,7.9936,8.0439,8.0942,8.1445, &"
  write(ilun,format)"       & 8.1948,8.2451,8.2955,8.3458,8.3961,8.4464,8.4967 /)"
  write(ilun,format)"  real(kind=8),dimension(1:91) :: excess_cooling_cc07 = (/ &"
  write(ilun,format)"       & -24.9949,-24.7270,-24.0473,-23.0713,-22.2907,-21.8917,-21.8058, &"
  write(ilun,format)"       & -21.8501,-21.9142,-21.9553,-21.9644,-21.9491,-21.9134,-21.8559, &"
  write(ilun,format)"       & -21.7797,-21.6863,-21.5791,-21.4648,-21.3640,-21.2995,-21.2691, &"
  write(ilun,format)"       & -21.2658,-21.2838,-21.2985,-21.2941,-21.2845,-21.2809,-21.2748, &"
  write(ilun,format)"       & -21.2727,-21.3198,-21.4505,-21.5921,-21.6724,-21.6963,-21.6925, &"
  write(ilun,format)"       & -21.6892,-21.7142,-21.7595,-21.7779,-21.7674,-21.7541,-21.7532, &"
  write(ilun,format)"       & -21.7679,-21.7866,-21.8052,-21.8291,-21.8716,-21.9316,-22.0055, &"
  write(ilun,format)"       & -22.0800,-22.1600,-22.2375,-22.3126,-22.3701,-22.4125,-22.4353, &"
  write(ilun,format)"       & -22.4462,-22.4450,-22.4406,-22.4337,-22.4310,-22.4300,-22.4356, &"
  write(ilun,format)"       & -22.4455,-22.4631,-22.4856,-22.5147,-22.5444,-22.5718,-22.5904, &"
  write(ilun,format)"       & -22.6004,-22.5979,-22.5885,-22.5728,-22.5554,-22.5350,-22.5159, &"
  write(ilun,format)"       & -22.4955,-22.4781,-22.4600,-22.4452,-22.4262,-22.4089,-22.3900, &"
  write(ilun,format)"       & -22.3722,-22.3529,-22.3339,-22.3137,-22.2936,-22.2729,-22.2521 /)"
  write(ilun,format)"  real(kind=8),dimension(1:91) :: excess_prime_cc07 = (/ & "
  write(ilun,format)"       &   2.0037,  4.7267, 12.2283, 13.5820,  9.8755,  4.8379,  1.8046, &"
  write(ilun,format)"       &   1.4574,  1.8086,  2.0685,  2.2012,  2.2250,  2.2060,  2.1605, &"
  write(ilun,format)"       &   2.1121,  2.0335,  1.9254,  1.7861,  1.5357,  1.1784,  0.7628, &"
  write(ilun,format)"       &   0.1500, -0.1401,  0.1272,  0.3884,  0.2761,  0.1707,  0.2279, &"
  write(ilun,format)"       &  -0.2417, -1.7802, -3.0381, -2.3511, -0.9864, -0.0989,  0.1854, &"
  write(ilun,format)"       &  -0.1282, -0.8028, -0.7363, -0.0093,  0.3132,  0.1894, -0.1526, &"
  write(ilun,format)"       &  -0.3663, -0.3873, -0.3993, -0.6790, -1.0615, -1.4633, -1.5687, &"
  write(ilun,format)"       &  -1.7183, -1.7313, -1.8324, -1.5909, -1.3199, -0.8634, -0.5542, &"
  write(ilun,format)"       &  -0.1961, -0.0552,  0.0646, -0.0109, -0.0662, -0.2539, -0.3869, &"
  write(ilun,format)"       &  -0.6379, -0.8404, -1.1662, -1.3930, -1.6136, -1.5706, -1.4266, &"
  write(ilun,format)"       &  -1.0460, -0.7244, -0.3006, -0.1300,  0.1491,  0.0972,  0.2463, &"
  write(ilun,format)"       &   0.0252,  0.1079, -0.1893, -0.1033, -0.3547, -0.2393, -0.4280, &"
  write(ilun,format)"       &  -0.2735, -0.3670, -0.2033, -0.2261, -0.0821, -0.0754,  0.0634 /)"
  write(ilun,format)"  real(kind=8),dimension(1:50)::z_courty=(/ &"
  write(ilun,format)"       & 0.00000,0.04912,0.10060,0.15470,0.21140,0.27090,0.33330,0.39880, &"
  write(ilun,format)"       & 0.46750,0.53960,0.61520,0.69450,0.77780,0.86510,0.95670,1.05300, &"
  write(ilun,format)"       & 1.15400,1.25900,1.37000,1.48700,1.60900,1.73700,1.87100,2.01300, &"
  write(ilun,format)"       & 2.16000,2.31600,2.47900,2.64900,2.82900,3.01700,3.21400,3.42100, &"
  write(ilun,format)"       & 3.63800,3.86600,4.10500,4.35600,4.61900,4.89500,5.18400,5.48800, &"
  write(ilun,format)"       & 5.80700,6.14100,6.49200,6.85900,7.24600,7.65000,8.07500,8.52100, &"
  write(ilun,format)"       & 8.98900,9.50000 /)"
  write(ilun,format)"  real(kind=8),dimension(1:50)::phi_courty=(/ &"
  write(ilun,format)"       & 0.0499886,0.0582622,0.0678333,0.0788739,0.0915889,0.1061913,0.1229119, &"
  write(ilun,format)"       & 0.1419961,0.1637082,0.1883230,0.2161014,0.2473183,0.2822266,0.3210551, &"
  write(ilun,format)"       & 0.3639784,0.4111301,0.4623273,0.5172858,0.5752659,0.6351540,0.6950232, &"
  write(ilun,format)"       & 0.7529284,0.8063160,0.8520859,0.8920522,0.9305764,0.9682031,1.0058810, &"
  write(ilun,format)"       & 1.0444020,1.0848160,1.1282190,1.1745120,1.2226670,1.2723200,1.3231350, &"
  write(ilun,format)"       & 1.3743020,1.4247480,1.4730590,1.5174060,1.5552610,1.5833640,1.5976390, &"
  write(ilun,format)"       & 1.5925270,1.5613110,1.4949610,1.3813710,1.2041510,0.9403100,0.5555344, & "
  write(ilun,format)"       & 0.0000000 /)"
  write(ilun,format)"  real(kind=8)::TT,lTT,deltaT,lcool,lcool1,lcool2,lcool1_prime,lcool2_prime"
  write(ilun,format)"  real(kind=8)::ZZ,deltaZ"
  write(ilun,format)"  real(kind=8)::c1=0.4,c2=10.0,TT0=1d5,TTC=1d6,alpha1=0.15"
  write(ilun,format)"  real(kind=8)::ux,g_courty,f_courty=1d0,g_courty_prime,f_courty_prime"
  write(ilun,format)"  integer::iT,iZ"
  write(ilun,format)""
  write(ilun,format)"  ZZ=1d0/aexp-1d0"
  write(ilun,format)"  TT=T2*mu"
  write(ilun,format)"  lTT=log10(TT)"
  write(ilun,format)""
  write(ilun,format)"  ! This is a simple model to take into account the ionization background"
  write(ilun,format)"  ! on metal cooling (calibrated using CLOUDY). "
  write(ilun,format)"  if(madau.or.weinbergint.or.courty)then"
  write(ilun,format)"     if(ZZ.le.0.0.or.ZZ.ge.z_courty(50))then"
  write(ilun,format)"        ux=0.0"
  write(ilun,format)"     else"
  write(ilun,format)"        iZ=1+int(ZZ/z_courty(50)*49.)"
  write(ilun,format)"        iZ=min(iZ,49)"
  write(ilun,format)"        iZ=max(iZ,1)"
  write(ilun,format)"        deltaZ=z_courty(iZ+1)-z_courty(iZ)"
  write(ilun,format)"        ux=1d-4*(phi_courty(iZ+1)*(ZZ-z_courty(iZ))/deltaZ & "
  write(ilun,format)"             & + phi_courty(iZ)*(z_courty(iZ+1)-ZZ)/deltaZ )/nH"
  write(ilun,format)"     endif"
  write(ilun,format)"  else ! Theuns or Teyssier"
  write(ilun,format)"     ux=1d-4*J0simple(aexp)/1d-22/nH"
  write(ilun,format)"  endif"
  write(ilun,format)"  g_courty=c1*(TT/TT0)**alpha1+c2*exp(-TTC/TT)"
  write(ilun,format)"  g_courty_prime=(c1*alpha1*(TT/TT0)**alpha1+c2*exp(-TTC/TT)*TTC/TT)/TT"
  write(ilun,format)"  f_courty=1d0/(1d0+ux/g_courty)"
  write(ilun,format)"  f_courty_prime=ux/g_courty/(1d0+ux/g_courty)**2*g_courty_prime/g_courty"
  write(ilun,format)""
  write(ilun,format)"!  if(lTT.ge.temperature_sd93(91))then"
  write(ilun,format)"  if(lTT.ge.temperature_cc07(91))then"
  write(ilun,format)"     metal_tot=1d-100 !  no metal lines above T>10^8.5 K, I think"
  write(ilun,format)"     metal_prime=0d0"
  write(ilun,format)"  else if(lTT.ge.1.0)then"
  write(ilun,format)"     lcool1=-100d0"
  write(ilun,format)"     lcool1_prime=0d0"
  write(ilun,format)"!      if(lTT.ge.temperature_sd93(1))then"
  write(ilun,format)"      if(lTT.ge.temperature_cc07(1))then"
  write(ilun,format)"        !  cooling between 10^4 K and 10^8.5 K."
  write(ilun,format)""
  write(ilun,format)"!        iT=1+int((lTT-temperature_sd93(1))/(temperature_sd93(91)-temperature_sd93(1))*90.0)"
  write(ilun,format)"        iT=1+int((lTT-temperature_cc07(1))/(temperature_cc07(91)-temperature_cc07(1))*90.0)"
  write(ilun,format)"        iT=min(iT,90)"
  write(ilun,format)"        iT=max(iT,1)"
  write(ilun,format)"!        deltaT=temperature_sd93(iT+1)-temperature_sd93(iT)"
  write(ilun,format)"!        lcool1 = excess_cooling_sd93(iT+1)*(lTT-temperature_sd93(iT))/deltaT  &"
  write(ilun,format)"!             & + excess_cooling_sd93(iT)*(temperature_sd93(iT+1)-lTT)/deltaT"
  write(ilun,format)"!        lcool1_prime  = excess_prime_sd93(iT+1)*(lTT-temperature_sd93(iT))/deltaT  &"
  write(ilun,format)"!                    & + excess_prime_sd93(iT)*(temperature_sd93(iT+1)-lTT)/deltaT"
  write(ilun,format)"        deltaT=temperature_cc07(iT+1)-temperature_cc07(iT)"
  write(ilun,format)"        lcool1 = excess_cooling_cc07(iT+1)*(lTT-temperature_cc07(iT))/deltaT  &"
  write(ilun,format)"             & + excess_cooling_cc07(iT)*(temperature_cc07(iT+1)-lTT)/deltaT "
  write(ilun,format)"        lcool1_prime  = excess_prime_cc07(iT+1)*(lTT-temperature_cc07(iT))/deltaT  &"
  write(ilun,format)"                    & + excess_prime_cc07(iT)*(temperature_cc07(iT+1)-lTT)/deltaT "
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     ! Fine structure cooling from infrared lines"
  write(ilun,format)"     !"
  write(ilun,format)"     !  neglect low-T metal line cooling for SNR problem"
  write(ilun,format)"     lcool2 = -100d0"
  write(ilun,format)"     lcool2_prime = 0d0"
  write(ilun,format)"     !lcool2=-31.522879+2.0*lTT-20.0/TT-TT*4.342944d-5"
  write(ilun,format)"     !lcool2_prime=2d0+(20d0/TT-TT*4.342944d-5)*log(10d0)"
  write(ilun,format)"     "
  write(ilun,format)"     ! Total metal cooling and temperature derivative"
  write(ilun,format)"     metal_tot=10d0**lcool1+10d0**lcool2"
  write(ilun,format)"     metal_prime=(10d0**lcool1*lcool1_prime+10d0**lcool2*lcool2_prime)/metal_tot"
  write(ilun,format)"     metal_prime=metal_prime*f_courty+metal_tot*f_courty_prime"
  write(ilun,format)"     metal_tot=metal_tot*f_courty"
  write(ilun,format)"  else"
  write(ilun,format)"     !  No cooling below 10 K."
  write(ilun,format)"     metal_tot=1d-100"
  write(ilun,format)"     metal_prime=0d0"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"end subroutine cmp_metals"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"subroutine cmp_cooling(T2,nH,t_rad_spec,h_rad_spec,cool_tot,heat_tot,cool_com,heat_com,mu_out,aexp,n_spec)"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"  implicit none"
  write(ilun,format)"  "
  write(ilun,format)"  real(kind=8),dimension(1:3)::t_rad_spec,h_rad_spec"
  write(ilun,format)"  real(kind=8) ::T2,nH,cool_tot,heat_tot,cool_com,heat_com,mu_out,aexp"
  write(ilun,format)"  real(kind=8) ::mu,mu_old,err_mu,mu_left,mu_right"
  write(ilun,format)"  real(kind=8) ::T"
  write(ilun,format)"  real(kind=8) ::n_E,n_HI,n_HII,n_HEI,n_HEII,n_HEIII,n_TOT"
  write(ilun,format)"  real(kind=8),dimension(1:6)::n_spec"
  write(ilun,format)"  real(kind=8) ::cb1,cb2,cb3,ci1,ci2,ci3,cr1,cr2,cr3,cd,ce1,ce2,ce3,ch1,ch2,ch3,coc,coh"
  write(ilun,format)"  integer :: niter"
  write(ilun,format)"  "
  write(ilun,format)"  ! Iteration to find mu"
  write(ilun,format)"  err_mu=1."
  write(ilun,format)"  mu_left=0.5"
  write(ilun,format)"  mu_right=1.3"
  write(ilun,format)"  niter=0"
  write(ilun,format)"  do while (err_mu > 1.d-4 .and. niter <= 50)"
  write(ilun,format)"     mu_old=0.5*(mu_left+mu_right)"
  write(ilun,format)"     T = T2*mu_old"
  write(ilun,format)"     call cmp_chem_eq(T,nH,t_rad_spec,n_spec,n_TOT,mu)"
  write(ilun,format)"     err_mu = (mu-mu_old)/mu_old"
  write(ilun,format)"     if(err_mu>0.)then "
  write(ilun,format)"        mu_left =0.5*(mu_left+mu_right)"
  write(ilun,format)"        mu_right=mu_right"
  write(ilun,format)"     else"
  write(ilun,format)"        mu_left =mu_left"
  write(ilun,format)"        mu_right=0.5*(mu_left+mu_right)"
  write(ilun,format)"     end if"
  write(ilun,format)"     err_mu=ABS(err_mu)"
  write(ilun,format)"     niter=niter+1"
  write(ilun,format)"  end do"
  write(ilun,format)"  if (niter > 50) then"
  write(ilun,format)"     write(*,*) 'ERROR in cmp_cooling : too many iterations.'"
  write(ilun,format)"     STOP"
  write(ilun,format)"  endif"
  write(ilun,format)"    "
  write(ilun,format)"  ! Get equilibrium abundances"
  write(ilun,format)"  n_E     = n_spec(1) ! electrons"
  write(ilun,format)"  n_HI    = n_spec(2) ! H"
  write(ilun,format)"  n_HII   = n_spec(3) ! H+"
  write(ilun,format)"  n_HEI   = n_spec(4) ! He"
  write(ilun,format)"  n_HEII  = n_spec(5) ! He+"
  write(ilun,format)"  n_HEIII = n_spec(6) ! He++"
  write(ilun,format)"  ! Bremstrahlung"
  write(ilun,format)"  cb1 = cool_bre(HI  ,T)*n_E*n_HII  /nH**2"
  write(ilun,format)"  cb2 = cool_bre(HEI ,T)*n_E*n_HEII /nH**2"
  write(ilun,format)"  cb3 = cool_bre(HEII,T)*n_E*n_HEIII/nH**2"
  write(ilun,format)"  ! Ionization cooling"
  write(ilun,format)"  ci1 = cool_ion(HI  ,T)*n_E*n_HI   /nH**2"
  write(ilun,format)"  ci2 = cool_ion(HEI ,T)*n_E*n_HEI  /nH**2"
  write(ilun,format)"  ci3 = cool_ion(HEII,T)*n_E*n_HEII /nH**2"
  write(ilun,format)"  ! Recombination cooling"
  write(ilun,format)"  cr1 = cool_rec(HI  ,T)*n_E*n_HII  /nH**2"
  write(ilun,format)"  cr2 = cool_rec(HEI ,T)*n_E*n_HEII /nH**2"
  write(ilun,format)"  cr3 = cool_rec(HEII,T)*n_E*n_HEIII/nH**2"
  write(ilun,format)"  ! Dielectric recombination cooling"
  write(ilun,format)"  cd  = cool_die(T     )*n_E*n_HEII /nH**2"
  write(ilun,format)"  ! Line cooling"
  write(ilun,format)"  ce1 = cool_exc(HI  ,T)*n_E*n_HI   /nH**2"
  write(ilun,format)"  ce2 = cool_exc(HEI, T)*n_E*n_HEI  /nH**2"
  write(ilun,format)"  ce3 = cool_exc(HEII,T)*n_E*n_HEII /nH**2"
  write(ilun,format)"  ! Radiative heating"
  write(ilun,format)"  ch1 = h_rad_spec(HI  )    *n_HI   /nH**2"
  write(ilun,format)"  ch2 = h_rad_spec(HEI )    *n_HEI  /nH**2"
  write(ilun,format)"  ch3 = h_rad_spec(HEII)    *n_HEII /nH**2"
  write(ilun,format)"  ! Total cooling and heating rates"
  write(ilun,format)"  heat_tot = ch1+ch2+ch3"
  write(ilun,format)"  cool_tot = cb1+cb2+cb3+ci1+ci2+ci3+cr1+cr2+cr3+cd+ce1+ce2+ce3"
  write(ilun,format)""
  write(ilun,format)"  ! Compton cooling"
  write(ilun,format)"  "
  write(ilun,format)"  ! don't use tabulated Compton terms."
  write(ilun,format)"  !coc = cool_compton(T,aexp)*n_E/nH"
  write(ilun,format)"  coc = 0.0"
  write(ilun,format)""
  write(ilun,format)"  cool_com = coc"
  write(ilun,format)"  "
  write(ilun,format)"  ! Compton heating"
  write(ilun,format)"  "
  write(ilun,format)"  ! don't use tabulated Compton terms."
  write(ilun,format)"  !coh = heat_compton(T,aexp)*n_E/nH"
  write(ilun,format)"  coh = 0.0"
  write(ilun,format)"  "
  write(ilun,format)"  heat_com = coh"
  write(ilun,format)"  ! Mean molecular weight"
  write(ilun,format)"  mu_out = mu"
  write(ilun,format)"  "
  write(ilun,format)"  if (if_cooling_functions) then"
  write(ilun,format)"     cool_out=max(cool_tot,smallnum_cooling)"
  write(ilun,format)"     heat_out=max(heat_tot,smallnum_cooling)"
  write(ilun,format)"     cool_com=max(cool_com,smallnum_cooling)"
  write(ilun,format)"     heat_com=max(heat_com,smallnum_cooling)"
  write(ilun,format)"     cb1s=max(cb1,smallnum_cooling)"
  write(ilun,format)"     cb2s=max(cb2,smallnum_cooling)"
  write(ilun,format)"     cb3s=max(cb3,smallnum_cooling)"
  write(ilun,format)"     ci1s=max(ci1,smallnum_cooling)"
  write(ilun,format)"     ci2s=max(ci2,smallnum_cooling)"
  write(ilun,format)"     ci3s=max(ci3,smallnum_cooling)"
  write(ilun,format)"     cr1s=max(cr1,smallnum_cooling)"
  write(ilun,format)"     cr2s=max(cr2,smallnum_cooling)"
  write(ilun,format)"     cr3s=max(cr3,smallnum_cooling)"
  write(ilun,format)"     cds =max(cd ,smallnum_cooling)"
  write(ilun,format)"     ce1s=max(ce1,smallnum_cooling)"
  write(ilun,format)"     ce3s=max(ce3,smallnum_cooling)"
  write(ilun,format)"     cocs=max(coc,smallnum_cooling)"
  write(ilun,format)"     cohs=max(coh,smallnum_cooling)"
  write(ilun,format)"     ch1s=max(ch1,smallnum_cooling)"
  write(ilun,format)"     ch2s=max(ch2,smallnum_cooling)"
  write(ilun,format)"     ch3s=max(ch3,smallnum_cooling)"
  write(ilun,format)"     cohs=max(coh,smallnum_cooling)  "
  write(ilun,format)"  endif"
  write(ilun,format)"end subroutine cmp_cooling"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"subroutine cmp_chem_eq(T,n_H,t_rad_spec,n_spec,n_TOT,mu)"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"  implicit none"
  write(ilun,format)"  real(kind=8)::T,n_H,n_TOT,mu"
  write(ilun,format)"  real(kind=8),dimension(1:3)::t_rad_spec"
  write(ilun,format)"  real(kind=8),dimension(1:6)::n_spec"
  write(ilun,format)"  real(kind=8)::xx,yy"
  write(ilun,format)"  real(kind=8)::n_HI,n_HII,n_HEI,n_HEII,n_HEIII,n_E"
  write(ilun,format)"  real(kind=8)::t_rad_HI,t_rad_HEI,t_rad_HEII"
  write(ilun,format)"  real(kind=8)::t_rec_HI,t_rec_HEI,t_rec_HEII"
  write(ilun,format)"  real(kind=8)::t_ion_HI,t_ion_HEI,t_ion_HEII"
  write(ilun,format)"  real(kind=8)::t_ion2_HI,t_ion2_HEI,t_ion2_HEII"
  write(ilun,format)"  real(kind=8)::x1,err_nE"
  write(ilun,format)"  "
  write(ilun,format)"  xx=(1.-Y)"
  write(ilun,format)"  yy=Y/(1.-Y)/4."
  write(ilun,format)"  "
  write(ilun,format)"  t_rad_HI   = t_rad_spec(HI)"
  write(ilun,format)"  t_rec_HI   = taux_rec  (HI,T)"
  write(ilun,format)"  t_ion_HI   = taux_ion  (HI,T)"
  write(ilun,format)"  "
  write(ilun,format)"  t_rad_HEI  = t_rad_spec(HEI)"
  write(ilun,format)"  t_rec_HEI  = taux_rec  (HEI,T)"
  write(ilun,format)"  t_ion_HEI  = taux_ion  (HEI,T)"
  write(ilun,format)"  "
  write(ilun,format)"  t_rad_HEII = t_rad_spec(HEII)"
  write(ilun,format)"  t_rec_HEII = taux_rec  (HEII,T)"
  write(ilun,format)"  t_ion_HEII = taux_ion  (HEII,T)"
  write(ilun,format)"  "
  write(ilun,format)"  n_E = n_H        "
  write(ilun,format)"  err_nE = 1."
  write(ilun,format)"  "
  write(ilun,format)"  do while(err_nE > 1.d-8)"
  write(ilun,format)"     "
  write(ilun,format)"     t_ion2_HI   = t_ion_HI   + t_rad_HI  /MAX(n_E,1e-15*n_H)"
  write(ilun,format)"     t_ion2_HEI  = t_ion_HEI  + t_rad_HEI /MAX(n_E,1e-15*n_H)"
  write(ilun,format)"     t_ion2_HEII = t_ion_HEII + t_rad_HEII/MAX(n_E,1e-15*n_H)"
  write(ilun,format)"     "
  write(ilun,format)"     n_HI  = t_rec_HI/(t_ion2_HI+t_rec_HI)*n_H"
  write(ilun,format)"     n_HII = t_ion2_HI/(t_ion2_HI+t_rec_HI)*n_H"
  write(ilun,format)"     "
  write(ilun,format)"     x1 = (t_rec_HEII*t_rec_HEI+t_ion2_HEI*t_rec_HEII+t_ion2_HEII*t_ion2_HEI)"
  write(ilun,format)"     "
  write(ilun,format)"     n_HEIII = yy*t_ion2_HEII*t_ion2_HEI/x1*n_H"
  write(ilun,format)"     n_HEII  = yy*t_ion2_HEI *t_rec_HEII/x1*n_H"
  write(ilun,format)"     n_HEI   = yy*t_rec_HEII *t_rec_HEI /x1*n_H"
  write(ilun,format)"     "
  write(ilun,format)"     err_nE = ABS((n_E - (n_HII + n_HEII + 2.*n_HEIII))/n_H)"
  write(ilun,format)"     n_E = 0.5*n_E+0.5*(n_HII + n_HEII + 2.*n_HEIII)"
  write(ilun,format)"     "
  write(ilun,format)"  end do"
  write(ilun,format)"    "
  write(ilun,format)"  n_TOT    =n_E+n_HI+n_HII+n_HEI+n_HEII+n_HEIII"
  write(ilun,format)"  mu       =n_H/xx/n_TOT"
  write(ilun,format)"  n_spec(1)=n_E"
  write(ilun,format)"  n_spec(2)=n_HI"
  write(ilun,format)"  n_spec(3)=n_HII"
  write(ilun,format)"  n_spec(4)=n_HEI"
  write(ilun,format)"  n_spec(5)=n_HEII"
  write(ilun,format)"  n_spec(6)=n_HEIII"
  write(ilun,format)"  "
  write(ilun,format)"end subroutine cmp_chem_eq"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"function cool_bre(ispec,T)"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ispec"
  write(ilun,format)"  real(kind=8)   ::T,cool_bre"
  write(ilun,format)"  if(ispec==HI  )cool_bre = 1.42D-27*sqrt(T)*(1.1D0+0.34D0*exp(-(5.5D0-log10(T))**2 /3.D0))"
  write(ilun,format)"  if(ispec==HEI )cool_bre = 1.42D-27*sqrt(T)*(1.1D0+0.34D0*exp(-(5.5D0-log10(T))**2 /3.D0))"
  write(ilun,format)"  if(ispec==HEII)cool_bre = 5.68D-27*sqrt(T)*(1.1D0+0.34D0*exp(-(5.5D0-log10(T))**2 /3.D0))"
  write(ilun,format)"  return"
  write(ilun,format)"end function cool_bre"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"function cool_exc(ispec,T)"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ispec"
  write(ilun,format)"  real(kind=8)   ::T,cool_exc,T5"
  write(ilun,format)"  T5=1.d-5*T"
  write(ilun,format)"  if(ispec==HI  )cool_exc = 7.50D-19/(1.+sqrt(T5))              *exp(-118348.D0/T)"
  write(ilun,format)"  if(ispec==HEI )cool_exc = 9.10D-27/(1.+sqrt(T5))/(T**0.1687D0)*exp(-13179.D0/T)"
  write(ilun,format)"  if(ispec==HEII)cool_exc = 5.54D-17/(1.+sqrt(T5))/(T**0.397D0 )*exp(-473638.D0/T)"
  write(ilun,format)"  return"
  write(ilun,format)"end function cool_exc"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"function cool_rec(ispec,T)"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ispec"
  write(ilun,format)"  real(kind=8)   ::T,cool_rec"
  write(ilun,format)"  real(kind=8)   ::T3, T6"
  write(ilun,format)"  T3 = 1.d-03*T"
  write(ilun,format)"  T6 = 1.d-06*T"
  write(ilun,format)"  if(ispec==HI  )cool_rec = 8.70D-27*SQRT(T)/T3**(0.2D0)/(1.D0+T6**0.7D0)"
  write(ilun,format)"  if(ispec==HEI )cool_rec = 1.55D-26*T**0.3647D0"
  write(ilun,format)"  if(ispec==HEII)cool_rec = 3.48D-26*SQRT(T)/T3**(0.2D0)/(1.D0+T6**0.7D0)"
  write(ilun,format)"  return"
  write(ilun,format)"end function cool_rec"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"function cool_die(T)"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"  implicit none"
  write(ilun,format)"  real(kind=8) :: T,cool_die"
  write(ilun,format)"  cool_die=1.24D-13*T**(-1.5D0)*exp(-470000.D0/T)*(1.D0+0.3D0*exp(-94000.D0/T))"
  write(ilun,format)"  return"
  write(ilun,format)"end function cool_die"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"function taux_rec(ispec,T)"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ispec"
  write(ilun,format)"  real(kind=8)   ::T,taux_rec"
  write(ilun,format)"  real(kind=8)   ::T3, T6"
  write(ilun,format)"  T3 = 1.d-03*T"
  write(ilun,format)"  T6 = 1.d-06*T"
  write(ilun,format)"  if(ispec==HI  )taux_rec = dumfac_rec*8.40e-11/SQRT(T)/T3**(0.2)/(1.+T6**0.7)"
  write(ilun,format)"  if(ispec==HEI )taux_rec = 1.50e-10/T**0.6353+taux_die(T)"
  write(ilun,format)"  if(ispec==HEII)taux_rec = 3.36e-10/SQRT(T)/T3**(0.2)/(1.+T6**0.7)"
  write(ilun,format)"  return"
  write(ilun,format)"end function taux_rec"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"function taux_die(T)"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"  implicit none"
  write(ilun,format)"  real(kind=8) :: T,taux_die"
  write(ilun,format)"  taux_die=1.9D-3*T**(-1.5D0)*exp(-470000.D0/T)*(1.D0+0.3D0*exp(-94000.D0/T))"
  write(ilun,format)"  return"
  write(ilun,format)"end function taux_die"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"function cool_ion(ispec,T)"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ispec"
  write(ilun,format)"  real(kind=8)   ::T,cool_ion"
  write(ilun,format)"  real(kind=8)   ::T5"
  write(ilun,format)"  T5 = 1.d-05*T"
  write(ilun,format)"  if(ispec==HI  )cool_ion = dumfac_ion*1.27D-21*SQRT(T)/(1.+SQRT(T5))*EXP(-157809.1D0/T)"
  write(ilun,format)"  if(ispec==HEI )cool_ion = dumfac_ion*9.38D-22*SQRT(T)/(1.+SQRT(T5))*EXP(-285335.4D0/T)"
  write(ilun,format)"  if(ispec==HEII)cool_ion = dumfac_ion*4.95D-22*SQRT(T)/(1.+SQRT(T5))*EXP(-631515.0D0/T)"
  write(ilun,format)"  return"
  write(ilun,format)"end function cool_ion"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"function cool_compton(T,LAGN,r)"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"  implicit none"
  write(ilun,format)"  real(kind=8) ::cool_compton,T"
  write(ilun,format)"  real(dp):: LAGN,r,Uph"
  write(ilun,format)""
  write(ilun,format)"  !cool_compton=5.406D-36*T/aexp**4 "
  write(ilun,format)"  "
  write(ilun,format)"  ! Non-relativistic inverse Compton."
  write(ilun,format)"  !"
  write(ilun,format)"  ! energy/(per e * time), cgs."
  write(ilun,format)"  Uph = LAGN/(4.0*pi*r**2.0*clight)"
  write(ilun,format)""
  write(ilun,format)"  cool_compton = (4.0*kB*T/(me*clight))*sigmaT*Uph"
  write(ilun,format)" "
  write(ilun,format)"  return"
  write(ilun,format)"end function cool_compton"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"function heat_compton(T,aexp)"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"  implicit none"
  write(ilun,format)"  real(kind=8) ::T,aexp,heat_compton"
  write(ilun,format)"  heat_compton=5.406D-36*2.726D0/aexp**5"
  write(ilun,format)"  return"
  write(ilun,format)"end function heat_compton"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"function taux_ion(ispec,T)"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ispec"
  write(ilun,format)"  real(kind=8)   :: T,taux_ion"
  write(ilun,format)"  real(kind=8)   :: T5"
  write(ilun,format)"  T5 = 1.d-05*T"
  write(ilun,format)"  if(ispec==HI  )taux_ion = dumfac_ion*5.85D-11*SQRT(T)/(1.+SQRT(T5))*EXP(-157809.1D0/T)"
  write(ilun,format)"  if(ispec==HEI )taux_ion = dumfac_ion*2.38D-11*SQRT(T)/(1.+SQRT(T5))*EXP(-285335.4D0/T)"
  write(ilun,format)"  if(ispec==HEII)taux_ion = dumfac_ion*5.68D-12*SQRT(T)/(1.+SQRT(T5))*EXP(-631515.0D0/T)"
  write(ilun,format)"  return"
  write(ilun,format)"end function taux_ion"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"function J_nu(e,J0)"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"  implicit none"
  write(ilun,format)"  real(kind=8) :: e,J_nu,e_L,J0,Jloc"
  write(ilun,format)"  Jloc = max(J0,J0min) "
  write(ilun,format)"  e_L  = 13.598*eV"
  write(ilun,format)"  J_nu = Jloc*(e_L/e)"
  write(ilun,format)"  return"
  write(ilun,format)"end function J_nu"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"function sigma_rad(e,ispec)"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ispec"
  write(ilun,format)"  real(kind=8)   ::sigma_rad,e,e_i,xxx,alph"
  write(ilun,format)"  if(ispec==HI  )e_i = 13.598D0*eV"
  write(ilun,format)"  if(ispec==HEI )e_i = 24.587D0*eV"
  write(ilun,format)"  if(ispec==HEII)e_i = 54.416D0*eV"
  write(ilun,format)"  xxx = e/e_i"
  write(ilun,format)"  alph = sqrt(xxx-1.0d0)"
  write(ilun,format)"  if(ispec==HI  )sigma_rad = 6.30D-18/xxx**4*exp(4.D0-4.D0*atan(alph)/alph) &"
  write(ilun,format)"       &                             /(1.D0-exp(-twopi/alph))"
  write(ilun,format)"  if(ispec==HEI )sigma_rad = 7.42D-18*(1.66D0/xxx**2.05D0-0.66D0/xxx**3.05D0)"
  write(ilun,format)"  if(ispec==HEII)sigma_rad = 1.58D-18/xxx**4*exp(4.D0-4.D0*atan(alph)/alph) &"
  write(ilun,format)"       &                             /(1.D0-exp(-twopi/alph))"
  write(ilun,format)"  return"
  write(ilun,format)"end function sigma_rad"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"function taux_rad(ispec,J0)"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"  implicit none  "
  write(ilun,format)"  integer::ispec"
  write(ilun,format)"  real(kind=8) :: J0,taux_rad,e_i,e,de,error,integ"
  write(ilun,format)"  if(ispec==HI  )e_i = 13.598D0*eV"
  write(ilun,format)"  if(ispec==HEI )e_i = 24.587D0*eV"
  write(ilun,format)"  if(ispec==HEII)e_i = 54.416D0*eV"
  write(ilun,format)"  integ = 0.0d0"
  write(ilun,format)"  e = e_i"
  write(ilun,format)"  de = e/100.D0"
  write(ilun,format)"  error = 1.D0"
  write(ilun,format)"  do while(error>1.d-6)"
  write(ilun,format)"     e = e + de"
  write(ilun,format)"     de = e/100.D0"
  write(ilun,format)"     error = 2.0d0*twopi*J_nu(e,J0)*sigma_rad(e,ispec)*de/e"
  write(ilun,format)"     integ = integ + error"
  write(ilun,format)"     error = error/abs(integ)"
  write(ilun,format)"  end do"
  write(ilun,format)"  taux_rad = integ/hplanck"
  write(ilun,format)"  return"
  write(ilun,format)"end function taux_rad"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"function taux_rad_madau(ispec,z)"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer :: ispec"
  write(ilun,format)"  real(kind=8) :: z,taux_rad_madau,tt"
  write(ilun,format)"  if (z < 15.d0) then"
  write(ilun,format)"     if (ispec==HI  ) taux_rad_madau=normfacJ0*exp(-31.04D0+2.795D0*z-0.5589D0*z**2)"
  write(ilun,format)"     if (ispec==HEI ) taux_rad_madau=normfacJ0*exp(-31.08D0+2.822D0*z-0.5664D0*z**2)"
  write(ilun,format)"     if (ispec==HEII) taux_rad_madau=normfacJ0*exp(-34.30D0+1.826D0*z-0.3899D0*z**2)"
  write(ilun,format)"  else"
  write(ilun,format)"     taux_rad_madau=0.d0"
  write(ilun,format)"  endif"
  write(ilun,format)"  tt=taux_rad_theuns(ispec,J0min)"
  write(ilun,format)"  if (taux_rad_madau < tt) taux_rad_madau=tt"
  write(ilun,format)"  return"
  write(ilun,format)"end function taux_rad_madau"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"function taux_rad_weinbergint(ispec,z)"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer :: ispec,i,iweinb"
  write(ilun,format)"  real(kind=8) :: z,zz,taux_rad_weinbergint,hh,tt"
  write(ilun,format)"  if (z < 8.5d0) then"
  write(ilun,format)"     if (ispec==HI  ) iweinb=1"
  write(ilun,format)"     if (ispec==HEI ) iweinb=2"
  write(ilun,format)"     if (ispec==HEII) iweinb=3"
  write(ilun,format)"     hh=0.d0"
  write(ilun,format)"     zz=max(z,1.0d-15)"
  write(ilun,format)"     do i=1,Norderweinberg"
  write(ilun,format)"        hh=hh+coefweinberg(i,iweinb)*zz**(i-1)"
  write(ilun,format)"     enddo"
  write(ilun,format)"     taux_rad_weinbergint=normfacJ0*exp(hh)"
  write(ilun,format)"  else"
  write(ilun,format)"     taux_rad_weinbergint=0.d0"
  write(ilun,format)"  endif"
  write(ilun,format)"  tt=taux_rad_theuns(ispec,J0min)"
  write(ilun,format)"  if (taux_rad_weinbergint < tt) taux_rad_weinbergint=tt"
  write(ilun,format)"  return"
  write(ilun,format)"end function taux_rad_weinbergint"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"function taux_rad_theuns(ispec,J0)"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer :: ispec"
  write(ilun,format)"  real(kind=8) :: J0,taux_rad_theuns"
  write(ilun,format)"  if (ispec==HI  ) taux_rad_theuns=1.26D10*J0/(3.D0+alpha)"
  write(ilun,format)"  if (ispec==HEI ) taux_rad_theuns=1.48D10*J0*0.553D0**alpha &"
  write(ilun,format)"                     & *(1.66D0/(alpha+2.05D0)-0.66D0/(alpha+3.05D0))"
  write(ilun,format)"  if (ispec==HEII) taux_rad_theuns=3.34D9*J0*0.249D0**alpha/(3.D0+alpha)"
  write(ilun,format)"  return"
  write(ilun,format)"end function taux_rad_theuns"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"function taux_rad_courty(ispec,z)"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer :: ispec,i,iweinb"
  write(ilun,format)"  real(kind=8) :: z,zz,taux_rad_courty,hh,tt,hhreion"
  write(ilun,format)"  if (z < zreioniz) then"
  write(ilun,format)"     if (ispec==HI  ) iweinb=1"
  write(ilun,format)"     if (ispec==HEI ) iweinb=2"
  write(ilun,format)"     if (ispec==HEII) iweinb=3"
  write(ilun,format)"     hh=0.d0"
  write(ilun,format)"     zz=max(z,1.0d-15)"
  write(ilun,format)"     do i=0,Nordercourty"
  write(ilun,format)"        hh=hh+coefcourty(i,iweinb)*zz**i"
  write(ilun,format)"     enddo"
  write(ilun,format)"     hhreion=coef_fit(iweinb)*(zz/zreioniz)**beta_fit(iweinb)"
  write(ilun,format)"     taux_rad_courty=10.**(hh-hhreion)"
  write(ilun,format)"  else"
  write(ilun,format)"     taux_rad_courty=0.d0"
  write(ilun,format)"  endif"
  write(ilun,format)"  tt=taux_rad_theuns(ispec,J0min)"
  write(ilun,format)"  if (taux_rad_courty < tt) taux_rad_courty=tt"
  write(ilun,format)"  return"
  write(ilun,format)"end function taux_rad_courty"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"function heat_rad(ispec,J0)"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"  implicit none  "
  write(ilun,format)"  integer::ispec"
  write(ilun,format)"  real(kind=8) :: J0,heat_rad,e_i,e,de,error,integ"
  write(ilun,format)"  if(ispec==HI  )e_i = 13.598D0*eV"
  write(ilun,format)"  if(ispec==HEI )e_i = 24.587D0*eV"
  write(ilun,format)"  if(ispec==HEII)e_i = 54.416D0*eV"
  write(ilun,format)"  integ = 0.0d0"
  write(ilun,format)"  e = e_i"
  write(ilun,format)"  de = e/100.D0"
  write(ilun,format)"  error = 1.D0"
  write(ilun,format)"  do while(error>1.d-6)"
  write(ilun,format)"     e = e + de"
  write(ilun,format)"     de = e/100.D0"
  write(ilun,format)"     error = 2.0d0*twopi*J_nu(e,J0)*sigma_rad(e,ispec)*(e/e_i-1.D0)*de/e"
  write(ilun,format)"     integ = integ + error"
  write(ilun,format)"     error=error/abs(integ)"
  write(ilun,format)"  end do"
  write(ilun,format)"  heat_rad = integ/hplanck*e_i"
  write(ilun,format)"  return"
  write(ilun,format)"end function heat_rad"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"function heat_rad_madau(ispec,z)"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer :: ispec"
  write(ilun,format)"  real(kind=8) :: z,heat_rad_madau,tt"
  write(ilun,format)"  if (z < 15.d0) then"
  write(ilun,format)"     if (ispec==HI  ) heat_rad_madau=normfacJ0*exp(-56.62D0+2.788D0*z-0.5594D0*z**2)"
  write(ilun,format)"     if (ispec==HEI ) heat_rad_madau=normfacJ0*exp(-56.06D0+2.800D0*z-0.5532D0*z**2)"
  write(ilun,format)"     if (ispec==HEII) heat_rad_madau=normfacJ0*exp(-58.67D0+1.888D0*z-0.3947D0*z**2)"
  write(ilun,format)"  else"
  write(ilun,format)"     heat_rad_madau=0.d0"
  write(ilun,format)"  endif"
  write(ilun,format)"  tt=heat_rad_theuns(ispec,J0min)"
  write(ilun,format)"  if (heat_rad_madau < tt) heat_rad_madau=tt"
  write(ilun,format)"  return"
  write(ilun,format)"end function heat_rad_madau"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"function heat_rad_weinbergint(ispec,z)"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer :: ispec,i,iweinb"
  write(ilun,format)"  real(kind=8) :: z,zz,heat_rad_weinbergint,hh,tt"
  write(ilun,format)"  if (z < 8.5d0) then"
  write(ilun,format)"     if (ispec==HI  ) iweinb=4"
  write(ilun,format)"     if (ispec==HEI ) iweinb=5"
  write(ilun,format)"     if (ispec==HEII) iweinb=6"
  write(ilun,format)"     hh=0.d0"
  write(ilun,format)"     zz=max(z,1.0d-15)"
  write(ilun,format)"     do i=1,Norderweinberg"
  write(ilun,format)"        hh=hh+coefweinberg(i,iweinb)*zz**(i-1)"
  write(ilun,format)"     enddo"
  write(ilun,format)"     heat_rad_weinbergint=normfacJ0*exp(hh)"
  write(ilun,format)"  else"
  write(ilun,format)"     heat_rad_weinbergint=0.d0"
  write(ilun,format)"  endif"
  write(ilun,format)"  tt=heat_rad_theuns(ispec,J0min)"
  write(ilun,format)"  if (heat_rad_weinbergint < tt) heat_rad_weinbergint=tt"
  write(ilun,format)"  return"
  write(ilun,format)"end function heat_rad_weinbergint"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"function heat_rad_theuns(ispec,J0)"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer :: ispec"
  write(ilun,format)"  real(kind=8) :: J0,heat_rad_theuns"
  write(ilun,format)"  if (ispec==HI  ) heat_rad_theuns=(2.91D-1*J0/(2.D0+alpha))/(3.D0+alpha)"
  write(ilun,format)"  if (ispec==HEI ) heat_rad_theuns=5.84D-1*J0*0.553D0**alpha* &"
  write(ilun,format)"                 & (1.66D0/(alpha+1.05D0)-2.32D0/(alpha+2.05D0)+0.66D0/(alpha+3.05D0))"
  write(ilun,format)"  if (ispec==HEII) heat_rad_theuns=(2.92D-1*J0*0.249D0**alpha/(2.D0+alpha))/(3.D0+alpha)"
  write(ilun,format)"  return"
  write(ilun,format)"end function heat_rad_theuns"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"function heat_rad_courty(ispec,z)"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer :: ispec,i,iweinb"
  write(ilun,format)"  real(kind=8) :: z,zz,heat_rad_courty,hh,tt,hhreion"
  write(ilun,format)"  if (z < zreioniz) then"
  write(ilun,format)"     if (ispec==HI  ) iweinb=4"
  write(ilun,format)"     if (ispec==HEI ) iweinb=5"
  write(ilun,format)"     if (ispec==HEII) iweinb=6"
  write(ilun,format)"     hh=0.d0"
  write(ilun,format)"     zz=max(z,1.0d-15)"
  write(ilun,format)"     do i=0,Nordercourty"
  write(ilun,format)"        hh=hh+coefcourty(i,iweinb)*zz**i"
  write(ilun,format)"     enddo"
  write(ilun,format)"     hhreion=coef_fit(iweinb)*(zz/zreioniz)**beta_fit(iweinb)"
  write(ilun,format)"     heat_rad_courty=10.**(hh-hhreion)"
  write(ilun,format)"  else"
  write(ilun,format)"     heat_rad_courty=0.d0"
  write(ilun,format)"  endif"
  write(ilun,format)"  tt=heat_rad_theuns(ispec,J0min)"
  write(ilun,format)"  if (heat_rad_courty < tt) heat_rad_courty=tt"
  write(ilun,format)"  return"
  write(ilun,format)"end function heat_rad_courty"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"function HsurH0(z,omega0,omegaL,OmegaR)"
  write(ilun,format)"!======================================================================="
  write(ilun,format)"  implicit none"
  write(ilun,format)"  real(kind=8) :: HsurH0,z,omega0,omegaL,omegaR"
  write(ilun,format)"  HsurH0=sqrt(Omega0*(1.d0+z)**3+OmegaR*(1.d0+z)**2+OmegaL)"
  write(ilun,format)"end function HsurH0"
  write(ilun,format)""
  write(ilun,format)"end module cooling_module"
  write(ilun,format)""
  write(ilun,format)"../patch/hydro/stratified_medium_fx_NSM/courant_fine.f90"
  write(ilun,format)"subroutine courant_fine(ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use poisson_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)"  !----------------------------------------------------------------------"
  write(ilun,format)"  ! Using the Courant-Friedrich-Levy stability condition,               !"
  write(ilun,format)"  ! this routine computes the maximum allowed time-step.                !"
  write(ilun,format)"  !----------------------------------------------------------------------"
  write(ilun,format)"  integer::i,ivar,idim,ind,ncache,igrid,iskip"
  write(ilun,format)"  integer::info,nleaf,ngrid"
  write(ilun,format)"  integer,dimension(1:nvector),save::ind_grid,ind_cell,ind_leaf"
  write(ilun,format)""
  write(ilun,format)"  real(dp)::dt_lev,dx,vol"
  write(ilun,format)"  real(kind=8),dimension(3)::comm_buffin,comm_buffout"
  write(ilun,format)"  real(kind=8)::mass_loc,ekin_loc,eint_loc,dt_loc"
  write(ilun,format)"  real(kind=8)::mass_all,ekin_all,eint_all,dt_all"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:nvar),save::uu"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim),save::gg"
  write(ilun,format)"  "
  write(ilun,format)"  real(dp)::scale,dx0"
  write(ilun,format)""
  write(ilun,format)"  ! Rescaling factor "
  write(ilun,format)"  scale=dble(icoarse_max-icoarse_min+1)/boxlen"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  if(numbtot(1,ilevel)==0)return"
  write(ilun,format)"  if(verbose)write(*,111)ilevel"
  write(ilun,format)""
  write(ilun,format)"  mass_all=0.0d0; mass_loc=0.0d0"
  write(ilun,format)"  ekin_all=0.0d0; ekin_loc=0.0d0"
  write(ilun,format)"  eint_all=0.0d0; eint_loc=0.0d0"
  write(ilun,format)"  dt_all=dtnew(ilevel); dt_loc=dt_all"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh spacing at that level"
  write(ilun,format)"  dx=0.5D0**ilevel/scale"
  write(ilun,format)"  vol=dx**ndim"
  write(ilun,format)""
  write(ilun,format)"  ! Loop over active grids by vector sweeps"
  write(ilun,format)"  ncache=active(ilevel)%ngrid"
  write(ilun,format)"  do igrid=1,ncache,nvector"
  write(ilun,format)"     ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"     do i=1,ngrid"
  write(ilun,format)"        ind_grid(i)=active(ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"     end do"
  write(ilun,format)"     "
  write(ilun,format)"     ! Loop over cells"
  write(ilun,format)"     do ind=1,twotondim        "
  write(ilun,format)"        iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_cell(i)=ind_grid(i)+iskip"
  write(ilun,format)"        end do"
  write(ilun,format)"        "
  write(ilun,format)"        ! Gather leaf cells"
  write(ilun,format)"        nleaf=0"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           if(son(ind_cell(i))==0)then"
  write(ilun,format)"              nleaf=nleaf+1"
  write(ilun,format)"              ind_leaf(nleaf)=ind_cell(i)"
  write(ilun,format)"           end if"
  write(ilun,format)"        end do"
  write(ilun,format)""
  write(ilun,format)"        ! Gather hydro variables"
  write(ilun,format)"        do ivar=1,nvar"
  write(ilun,format)"           do i=1,nleaf"
  write(ilun,format)"              uu(i,ivar)=uold(ind_leaf(i),ivar)"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"        "
  write(ilun,format)"        ! Gather gravitational acceleration"
  write(ilun,format)"        gg=0.0d0"
  write(ilun,format)"        if(poisson)then"
  write(ilun,format)"           do idim=1,ndim"
  write(ilun,format)"              do i=1,nleaf"
  write(ilun,format)"                 gg(i,idim)=f(ind_leaf(i),idim)"
  write(ilun,format)"              end do"
  write(ilun,format)"           end do"
  write(ilun,format)"        end if"
  write(ilun,format)"        "
  write(ilun,format)"        ! Compute total mass"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           mass_loc=mass_loc+uu(i,1)*vol"
  write(ilun,format)"        end do"
  write(ilun,format)"        "
  write(ilun,format)"        ! Compute total energy"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           ekin_loc=ekin_loc+uu(i,ndim+2)*vol"
  write(ilun,format)"        end do"
  write(ilun,format)"        "
  write(ilun,format)"        ! Compute total internal energy"
  write(ilun,format)"        do i=1,nleaf"
  write(ilun,format)"           eint_loc=eint_loc+uu(i,ndim+2)*vol"
  write(ilun,format)"        end do"
  write(ilun,format)"        do ivar=1,ndim"
  write(ilun,format)"           do i=1,nleaf"
  write(ilun,format)"              eint_loc=max(eint_loc-0.5d0*uu(i,1+ivar)**2/uu(i,1)*vol,uu(i,1)*vol*smallc**2)"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"        "
  write(ilun,format)"        ! Compute CFL time-step"
  write(ilun,format)"        if(nleaf>0)then"
  write(ilun,format)"           call cmpdt(uu,gg,dx,dt_lev,nleaf)"
  write(ilun,format)"           dt_loc=min(dt_loc,dt_lev)"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"           ! DEBUG: much larger than we would expect for dx/vin..."
  write(ilun,format)"           !write(*,*) 'dt_loc='"
  write(ilun,format)"	   !write(*,*) dt_loc"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"        end if"
  write(ilun,format)"        "
  write(ilun,format)"     end do"
  write(ilun,format)"     ! End loop over cells"
  write(ilun,format)"     "
  write(ilun,format)"  end do"
  write(ilun,format)"  ! End loop over grids"
  write(ilun,format)""
  write(ilun,format)"  ! Compute global quantities"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  comm_buffin(1)=mass_loc"
  write(ilun,format)"  comm_buffin(2)=ekin_loc"
  write(ilun,format)"  comm_buffin(3)=eint_loc"
  write(ilun,format)"  call MPI_ALLREDUCE(comm_buffin,comm_buffout,3,MPI_DOUBLE_PRECISION,MPI_SUM,&"
  write(ilun,format)"       &MPI_COMM_WORLD,info)"
  write(ilun,format)"  call MPI_ALLREDUCE(dt_loc,dt_all,1,MPI_DOUBLE_PRECISION,MPI_MIN,&"
  write(ilun,format)"       &MPI_COMM_WORLD,info)"
  write(ilun,format)"  mass_all=comm_buffout(1)"
  write(ilun,format)"  ekin_all=comm_buffout(2)"
  write(ilun,format)"  eint_all=comm_buffout(3)"
  write(ilun,format)"#endif"
  write(ilun,format)"#ifdef WITHOUTMPI"
  write(ilun,format)"  mass_all=mass_loc"
  write(ilun,format)"  ekin_all=ekin_loc"
  write(ilun,format)"  eint_all=eint_loc"
  write(ilun,format)"  dt_all=dt_loc"
  write(ilun,format)"#endif"
  write(ilun,format)"  mass_tot=mass_tot+mass_all"
  write(ilun,format)"  ekin_tot=ekin_tot+ekin_all"
  write(ilun,format)"  eint_tot=eint_tot+eint_all"
  write(ilun,format)"  dtnew(ilevel)=MIN(dtnew(ilevel),dt_all)"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! Comment out continuous wind injection for SNR case. "
  write(ilun,format)"  !if(ilevel==nlevelmax)call wind_fine(ilevel)"
  write(ilun,format)""
  write(ilun,format)"111 format('   Entering courant_fine for level ',I2)"
  write(ilun,format)""
  write(ilun,format)"end subroutine courant_fine"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"subroutine wind_fine(ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use poisson_parameters"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)"  "
  write(ilun,format)"  integer::igrid,ncache,i,ind,iskip,ngrid"
  write(ilun,format)"  integer::ix,iy,iz,idim,ivar"
  write(ilun,format)"  integer,dimension(1:nvector),save::ind_grid,ind_cell"
  write(ilun,format)""
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v"
  write(ilun,format)""
  write(ilun,format)"  real(dp)::dx,scale"
  write(ilun,format)"  real(dp),dimension(1:twotondim,1:ndim)::xc"
  write(ilun,format)"  real(dp),dimension(1:nvector),save::rr"
  write(ilun,format)" "
  write(ilun,format)""
  write(ilun,format)"  real(dp),parameter:: pi = 3.14159265"
  write(ilun,format)"  real(dp),parameter:: kB = 1.3806200e-16 ! Boltzmann constant, cgs "
  write(ilun,format)"  character(LEN=160)::infile"
  write(ilun,format)"  real(dp)::cx, cy, cz, xcell, ycell, zcell, dctr "
  write(ilun,format)"  real(dp)::Lcgs, Luser, Luser_dens, mu"
  write(ilun,format)"  real(dp)::vx_BC, vy_BC, vz_BC, rho_BC, P_BC"
  write(ilun,format)"  real(dp)::xwinds,ywinds,zwinds"
  write(ilun,format)""
  write(ilun,format)"  if(numbtot(1,ilevel)==0)return"
  write(ilun,format)"  if(verbose)write(*,111)ilevel"
  write(ilun,format)""
  write(ilun,format)"  ! Conversion factor from user units to cgs units "
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! DEBUG: hardcoded mean molecular weight."
  write(ilun,format)"  mu = 0.6"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! Assume grid units = user (code) units, since boxlen=1."
  write(ilun,format)"  Lcgs = (1.0D51)/31536000.0 ! 1 SNe per year"
  write(ilun,format)"  Luser = Lcgs/(scale_d*scale_l**2.0*scale_v**3.0)"
  write(ilun,format)""
  write(ilun,format)"  Luser_dens = Luser/(4.0*pi*rc**3.0/3.0)"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! Mesh size"
  write(ilun,format)"  dx=0.5d0**ilevel"
  write(ilun,format)""
  write(ilun,format)"  ! Rescaling factor"
  write(ilun,format)"  scale=dble(icoarse_max-icoarse_min+1)/boxlen"
  write(ilun,format)"  "
  write(ilun,format)""
  write(ilun,format)"  ! Location of the point source (grid or code units?)"
  write(ilun,format)"  !"
  write(ilun,format)"  ! Need this correction here, but not in condinit. Distinction"
  write(ilun,format)"  ! between code and user units?"
  write(ilun,format)"  xwinds = xwind*scale+dble(icoarse_min)"
  write(ilun,format)"  ywinds = ywind*scale+dble(jcoarse_min)"
  write(ilun,format)"  zwinds = zwind*scale+dble(kcoarse_min)"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! Set position of cell centers relative to grid center"
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     iz=(ind-1)/4"
  write(ilun,format)"     iy=(ind-1-4*iz)/2"
  write(ilun,format)"     ix=(ind-1-2*iy-4*iz)"
  write(ilun,format)"     if(ndim>0)xc(ind,1)=(dble(ix)-0.5D0)*dx !-xwinds"
  write(ilun,format)"     if(ndim>1)xc(ind,2)=(dble(iy)-0.5D0)*dx !-ywinds"
  write(ilun,format)"     if(ndim>2)xc(ind,3)=(dble(iz)-0.5D0)*dx !-zwinds"
  write(ilun,format)"  end do"
  write(ilun,format)" "
  write(ilun,format)""
  write(ilun,format)"  ! Loop over active grids by vector sweeps"
  write(ilun,format)"  ncache=active(ilevel)%ngrid"
  write(ilun,format)"  do igrid=1,ncache,nvector"
  write(ilun,format)"     ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"     do i=1,ngrid"
  write(ilun,format)"        ind_grid(i)=active(ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"     end do"
  write(ilun,format)"     "
  write(ilun,format)"     ! Loop over cells (i.e., cell 1, 2, 3, ..., 8 for each oct)."
  write(ilun,format)"     do ind=1,twotondim"
  write(ilun,format)"        iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"        "
  write(ilun,format)"	do i=1,ngrid"
  write(ilun,format)"           ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)""
  write(ilun,format)"           xcell = xg(ind_grid(i),1)+xc(ind,1)"
  write(ilun,format)"           ycell = xg(ind_grid(i),2)+xc(ind,2)"
  write(ilun,format)"           zcell = xg(ind_grid(i),3)+xc(ind,3)"
  write(ilun,format)""
  write(ilun,format)"           dctr = ((xcell-xwinds)**2.0 + (ycell-ywinds)**2.0 + (zcell-zwinds)**2.0)**0.5"
  write(ilun,format)""
  write(ilun,format)"	   ! Spatial condition, then add energy."
  write(ilun,format)"           if(dctr<rc)then"
  write(ilun,format)""
  write(ilun,format)"             ! Enforce boundary conditions at the sphere boundary."
  write(ilun,format)"             "
  write(ilun,format)"	     ! Wind velocity, pointing outward from the center."
  write(ilun,format)"	     "
  write(ilun,format)"	     vx_BC = (xcell - xwinds)*vin/dctr"
  write(ilun,format)"	     vy_BC = (ycell - ywinds)*vin/dctr"
  write(ilun,format)"	     vz_BC = (zcell - zwinds)*vin/dctr"
  write(ilun,format)""
  write(ilun,format)"             rho_BC = Mdot_in/(4.0*pi*rc**2.0*vin)"
  write(ilun,format)"	     rho_BC = rho_BC*(dctr/(alph*rc+(1.0-alph)*dctr))**(-2.0)"
  write(ilun,format)"             P_BC = (Tin_K/mu)*rho_BC/scale_T2"
  write(ilun,format)""
  write(ilun,format)"             uold(ind_cell(i),1) = rho_BC"
  write(ilun,format)"             uold(ind_cell(i),2) = rho_BC*vx_BC"
  write(ilun,format)"             uold(ind_cell(i),3) = rho_BC*vy_BC"
  write(ilun,format)"             uold(ind_cell(i),4) = rho_BC*vz_BC"
  write(ilun,format)"             uold(ind_cell(i),5) = 0.5*rho_BC*vin**2.0 + P_BC/(gamma-1.0d0)"
  write(ilun,format)""
  write(ilun,format)"           end if "
  write(ilun,format)""
  write(ilun,format)"       end do"
  write(ilun,format)""
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! Update boundaries"
  write(ilun,format)"  do ivar=1,nvar"
  write(ilun,format)"     call make_virtual_fine_dp(uold(1,ivar),ilevel)"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"111 format('   Entering wind_fine for level ',I2)"
  write(ilun,format)""
  write(ilun,format)"end subroutine wind_fine"
  write(ilun,format)"../patch/hydro/stratified_medium_fx_NSM/feedback.f90"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine thermal_feedback(ilevel,icount)"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ilevel,icount"
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)"  ! This routine computes the thermal energy, the kinetic energy and "
  write(ilun,format)"  ! the metal mass dumped in the gas by stars (SNII, SNIa, winds)."
  write(ilun,format)"  ! This routine is called every fine time step."
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v"
  write(ilun,format)"  real(dp)::t0,scale,dx_min,vsn,rdebris,ethermal"
  write(ilun,format)"  integer::igrid,jgrid,ipart,jpart,next_part"
  write(ilun,format)"  integer::i,ig,ip,npart1,npart2,icpu,nx_loc"
  write(ilun,format)"  real(dp),dimension(1:3)::skip_loc"
  write(ilun,format)"  integer,dimension(1:nvector),save::ind_grid,ind_part,ind_grid_part"
  write(ilun,format)""
  write(ilun,format)"  if(numbtot(1,ilevel)==0)return"
  write(ilun,format)"  if(verbose)write(*,111)ilevel"
  write(ilun,format)"  if(icount==2)return"
  write(ilun,format)""
  write(ilun,format)"  ! Gather star particles only."
  write(ilun,format)""
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)"  ! Loop over cpus"
  write(ilun,format)"  do icpu=1,ncpu"
  write(ilun,format)"     "
  write(ilun,format)"     !  headl is linked list"
  write(ilun,format)"     ! head list in level"
  write(ilun,format)""
  write(ilun,format)"     igrid=headl(icpu,ilevel)"
  write(ilun,format)"     ig=0"
  write(ilun,format)"     ip=0"
  write(ilun,format)"     ! Loop over grids "
  write(ilun,format)"     !"
  write(ilun,format)"     !  in level (level is passed as argument to function)"
  write(ilun,format)"     do jgrid=1,numbl(icpu,ilevel)"
  write(ilun,format)"        npart1=numbp(igrid)  ! Number of particles in the grid"
  write(ilun,format)"        npart2=0"
  write(ilun,format)"        "
  write(ilun,format)"        ! Count star particles"
  write(ilun,format)"        if(npart1>0)then"
  write(ilun,format)"           ipart=headp(igrid) !  linked list of pointers to particles in linked list"
  write(ilun,format)"           ! Loop over particles"
  write(ilun,format)"           do jpart=1,npart1"
  write(ilun,format)"              ! Save next particle   <--- Very important !!!"
  write(ilun,format)"              next_part=nextp(ipart)"
  write(ilun,format)"              if(idp(ipart).gt.0.and.tp(ipart).ne.0)then !  idp is particle ID; tp is birth epoch"
  write(ilun,format)"                 npart2=npart2+1"
  write(ilun,format)"              endif"
  write(ilun,format)"              ipart=next_part  ! Go to next particle"
  write(ilun,format)"           end do"
  write(ilun,format)"        endif"
  write(ilun,format)"        "
  write(ilun,format)"        ! Gather star particles"
  write(ilun,format)"        if(npart2>0)then        "
  write(ilun,format)"           ig=ig+1"
  write(ilun,format)"           ind_grid(ig)=igrid"
  write(ilun,format)"           ipart=headp(igrid)"
  write(ilun,format)"           ! Loop over particles"
  write(ilun,format)"           do jpart=1,npart1"
  write(ilun,format)"              ! Save next particle   <--- Very important !!!"
  write(ilun,format)"              next_part=nextp(ipart)"
  write(ilun,format)"              ! Select only star particles"
  write(ilun,format)"              if(idp(ipart).gt.0.and.tp(ipart).ne.0)then"
  write(ilun,format)"                 if(ig==0)then"
  write(ilun,format)"                    ig=1"
  write(ilun,format)"                    ind_grid(ig)=igrid"
  write(ilun,format)"                 end if"
  write(ilun,format)"                 ip=ip+1"
  write(ilun,format)"                 ind_part(ip)=ipart"
  write(ilun,format)"                 ind_grid_part(ip)=ig   "
  write(ilun,format)"              endif"
  write(ilun,format)"              if(ip==nvector)then"
  write(ilun,format)"                !  feedbk routine called for a number of particles equal to"
  write(ilun,format)"                !       nvector."
  write(ilun,format)"                !"
  write(ilun,format)"                ! nvector is size of vector sweeps"
  write(ilun,format)" "
  write(ilun,format)"                 call feedbk(ind_grid,ind_part,ind_grid_part,ig,ip,ilevel)"
  write(ilun,format)"                 ip=0"
  write(ilun,format)"                 ig=0"
  write(ilun,format)"              end if"
  write(ilun,format)"              ipart=next_part  ! Go to next particle"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! End loop over particles"
  write(ilun,format)"        end if"
  write(ilun,format)"        igrid=next(igrid)   ! Go to next grid"
  write(ilun,format)"     end do"
  write(ilun,format)"     ! End loop over grids"
  write(ilun,format)"     if(ip>0)call feedbk(ind_grid,ind_part,ind_grid_part,ig,ip,ilevel)"
  write(ilun,format)"  end do "
  write(ilun,format)"  ! End loop over cpus"
  write(ilun,format)""
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"111 format('   Entering thermal_feedback for level ',I2)"
  write(ilun,format)""
  write(ilun,format)"end subroutine thermal_feedback"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine feedbk(ind_grid,ind_part,ind_grid_part,ng,np,ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use random"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ng,np,ilevel"
  write(ilun,format)"  integer,dimension(1:nvector)::ind_grid"
  write(ilun,format)"  integer,dimension(1:nvector)::ind_grid_part,ind_part"
  write(ilun,format)"  !-----------------------------------------------------------------------"
  write(ilun,format)"  ! This routine is called by subroutine feedback. Each debris particle"
  write(ilun,format)"  ! dumps mass, momentum and energy in the nearest grid cell using array"
  write(ilun,format)"  ! uold."
  write(ilun,format)"  !-----------------------------------------------------------------------"
  write(ilun,format)"  integer::i,j,idim,nx_loc"
  write(ilun,format)"  real(kind=8)::RandNum"
  write(ilun,format)"  real(dp)::SN_BOOST,mstar,dx_min,vol_min"
  write(ilun,format)"  real(dp)::xxx,mmm,t0,ESN,mejecta,zloss"
  write(ilun,format)"  real(dp)::dx,dx_loc,scale,vol_loc,birth_time"
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v"
  write(ilun,format)"  logical::error"
  write(ilun,format)"  ! Grid based arrays"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim),save::x0"
  write(ilun,format)"  integer ,dimension(1:nvector),save::ind_cell"
  write(ilun,format)"  integer ,dimension(1:nvector,1:threetondim),save::nbors_father_cells"
  write(ilun,format)"  integer ,dimension(1:nvector,1:twotondim),save::nbors_father_grids"
  write(ilun,format)"  ! Particle based arrays"
  write(ilun,format)"  integer,dimension(1:nvector),save::igrid_son,ind_son"
  write(ilun,format)"  integer,dimension(1:nvector),save::list1"
  write(ilun,format)"  logical,dimension(1:nvector),save::ok"
  write(ilun,format)"  real(dp),dimension(1:nvector),save::mloss,mzloss,ethermal,ekinetic,dteff"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim),save::x"
  write(ilun,format)"  integer ,dimension(1:nvector,1:ndim),save::id,igd,icd"
  write(ilun,format)"  integer ,dimension(1:nvector),save::igrid,icell,indp,kg"
  write(ilun,format)"  real(dp),dimension(1:3)::skip_loc"
  write(ilun,format)""
  write(ilun,format)"  ! Conversion factor from user units to cgs units"
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)""
  write(ilun,format)"  !  function is called for a specific level. It is called for each level,"
  write(ilun,format)"  ! recurviely in amr_step"
  write(ilun,format)" "
  write(ilun,format)"  ! Mesh spacing in that level"
  write(ilun,format)"  dx=0.5D0**ilevel"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  skip_loc=(/0.0d0,0.0d0,0.0d0/)"
  write(ilun,format)"  if(ndim>0)skip_loc(1)=dble(icoarse_min)"
  write(ilun,format)"  if(ndim>1)skip_loc(2)=dble(jcoarse_min)"
  write(ilun,format)"  if(ndim>2)skip_loc(3)=dble(kcoarse_min)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)"  vol_loc=dx_loc**ndim"
  write(ilun,format)"  dx_min=(0.5D0**nlevelmax)*scale"
  write(ilun,format)"  vol_min=dx_min**ndim"
  write(ilun,format)""
  write(ilun,format)"  ! Minimum star particle mass"
  write(ilun,format)"  if(m_star < 0d0)then"
  write(ilun,format)"     mstar=n_star/(scale_nH*aexp**3)*vol_min"
  write(ilun,format)"  else"
  write(ilun,format)"     mstar=m_star*mass_sph"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  ! Compute stochastic boost to account for target GMC mass"
  write(ilun,format)"  SN_BOOST=MAX(mass_gmc*2d33/(scale_d*scale_l**3)/mstar,1d0)"
  write(ilun,format)""
  write(ilun,format)"  ! Massive star lifetime from Myr to code units"
  write(ilun,format)"  t0=10.*1d6*(365.*24.*3600.)/scale_t"
  write(ilun,format)""
  write(ilun,format)"  ! Type II supernova specific energy from cgs to code units"
  write(ilun,format)"  ESN=1d51/(10.*2d33)/scale_v**2"
  write(ilun,format)""
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)"  ! Lower left corner of 3x3x3 grid-cube"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do i=1,ng"
  write(ilun,format)"        x0(i,idim)=xg(ind_grid(i),idim)-3.0D0*dx"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Gather 27 neighboring father cells (should be present anytime !)"
  write(ilun,format)"  "
  write(ilun,format)"  do i=1,ng"
  write(ilun,format)"     ind_cell(i)=father(ind_grid(i))"
  write(ilun,format)"  end do"
  write(ilun,format)"  call get3cubefather(ind_cell,nbors_father_cells,nbors_father_grids,ng,ilevel)"
  write(ilun,format)""
  write(ilun,format)"  ! Rescale position at level ilevel"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        x(j,idim)=xp(ind_part(j),idim)/scale+skip_loc(idim)"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        x(j,idim)=x(j,idim)-x0(ind_grid_part(j),idim)"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        x(j,idim)=x(j,idim)/dx"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Check for illegal moves"
  write(ilun,format)"  error=.false."
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        if(x(j,idim)<=2.0D0.or.x(j,idim)>=4.0D0)error=.true."
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  if(error)then"
  write(ilun,format)"     write(*,*)'problem in sn2'"
  write(ilun,format)"     write(*,*)ilevel,ng,np"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  ! NGP at level ilevel"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        id(j,idim)=x(j,idim)"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"   ! Compute parent grids"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        igd(j,idim)=id(j,idim)/2"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     kg(j)=1+igd(j,1)+3*igd(j,2)+9*igd(j,3)"
  write(ilun,format)"  end do"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     igrid(j)=son(nbors_father_cells(ind_grid_part(j),kg(j)))"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Check if particles are entirely in level ilevel"
  write(ilun,format)"  ok(1:np)=.true."
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     ok(j)=ok(j).and.igrid(j)>0"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Compute parent cell position"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        if(ok(j))then"
  write(ilun,format)"           icd(j,idim)=id(j,idim)-2*igd(j,idim)"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     if(ok(j))then"
  write(ilun,format)"        icell(j)=1+icd(j,1)+2*icd(j,2)+4*icd(j,3)"
  write(ilun,format)"     end if"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Compute parent cell adresses"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     if(ok(j))then"
  write(ilun,format)"        indp(j)=ncoarse+(icell(j)-1)*ngridmax+igrid(j)"
  write(ilun,format)"     end if"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Compute individual time steps"
  write(ilun,format)"  ! WARNING: the time step is always the coarser level time step"
  write(ilun,format)"  ! since we do not have feedback for icount=2"
  write(ilun,format)"  if(ilevel==levelmin)then"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        if(ok(j))then"
  write(ilun,format)"           dteff(j)=dtold(levelp(ind_part(j)))"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  else"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        if(ok(j))then"
  write(ilun,format)"           dteff(j)=dtold(levelp(ind_part(j))-1)"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  ! Reset ejected mass, metallicity, thermal energy"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     if(ok(j))then"
  write(ilun,format)"        mloss(j)=0d0"
  write(ilun,format)"        mzloss(j)=0d0"
  write(ilun,format)"        ethermal(j)=0d0"
  write(ilun,format)"     endif"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Compute stellar mass loss and thermal feedback due to supernovae"
  write(ilun,format)"  !"
  write(ilun,format)"  !  f_w is SN mass loading factor"
  write(ilun,format)"  if(f_w==0)then"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        "
  write(ilun,format)"       if(ok(j))then"
  write(ilun,format)"           birth_time=tp(ind_part(j))"
  write(ilun,format)"           ! Make sure that we don't count feedback twice"
  write(ilun,format)"           if(birth_time.lt.(t-t0).and.birth_time.ge.(t-t0-dteff(j)))then"
  write(ilun,format)"              ! Stellar mass loss"
  write(ilun,format)"              mejecta=eta_sn*mp(ind_part(j))"
  write(ilun,format)"              mloss(j)=mloss(j)+mejecta/vol_loc"
  write(ilun,format)"              ! Thermal energy"
  write(ilun,format)"              ethermal(j)=ethermal(j)+mejecta*ESN/vol_loc"
  write(ilun,format)"              ! Metallicity"
  write(ilun,format)"              if(metal)then"
  write(ilun,format)"                 zloss=yield+(1d0-yield)*zp(ind_part(j))"
  write(ilun,format)"                 mzloss(j)=mzloss(j)+mejecta*zloss/vol_loc"
  write(ilun,format)"              endif"
  write(ilun,format)"              ! Reduce star particle mass"
  write(ilun,format)"              mp(ind_part(j))=mp(ind_part(j))-mejecta"
  write(ilun,format)"              ! Boost SNII energy and depopulate accordingly"
  write(ilun,format)"              if(SN_BOOST>1d0)then"
  write(ilun,format)"                 call ranf(localseed,RandNum)"
  write(ilun,format)"                 if(RandNum<1d0/SN_BOOST)then"
  write(ilun,format)"                    mloss(j)=SN_BOOST*mloss(j)"
  write(ilun,format)"                    mzloss(j)=SN_BOOST*mzloss(j)"
  write(ilun,format)"                    ethermal(j)=SN_BOOST*ethermal(j)"
  write(ilun,format)"                 else"
  write(ilun,format)"                    mloss(j)=0d0"
  write(ilun,format)"                    mzloss(j)=0d0"
  write(ilun,format)"                    ethermal(j)=0d0"
  write(ilun,format)"                 endif"
  write(ilun,format)"              endif"
  write(ilun,format)"           endif"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  ! Update hydro variables due to feedback"
  write(ilun,format)"  "
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     if(ok(j))then"
  write(ilun,format)"        ! Specific kinetic energy of the star"
  write(ilun,format)"        ekinetic(j)=0.5*(vp(ind_part(j),1)**2 &"
  write(ilun,format)"             &          +vp(ind_part(j),2)**2 &"
  write(ilun,format)"             &          +vp(ind_part(j),3)**2)"
  write(ilun,format)"        ! Update hydro variable in NGP cell"
  write(ilun,format)""
  write(ilun,format)"        uold(indp(j),1)=uold(indp(j),1)+mloss(j) !  mass"
  write(ilun,format)"        uold(indp(j),2)=uold(indp(j),2)+mloss(j)*vp(ind_part(j),1) !  momentum"
  write(ilun,format)"        uold(indp(j),3)=uold(indp(j),3)+mloss(j)*vp(ind_part(j),2)"
  write(ilun,format)"        uold(indp(j),4)=uold(indp(j),4)+mloss(j)*vp(ind_part(j),3)"
  write(ilun,format)"        uold(indp(j),5)=uold(indp(j),5)+mloss(j)*ekinetic(j)+ethermal(j) !  energy"
  write(ilun,format)"        "
  write(ilun,format)"     endif"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Add metals"
  write(ilun,format)"  if(metal)then"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        if(ok(j))then"
  write(ilun,format)"           uold(indp(j),imetal)=uold(indp(j),imetal)+mzloss(j)"
  write(ilun,format)"        endif"
  write(ilun,format)"     end do"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  ! Add delayed cooling switch variable"
  write(ilun,format)"  if(delayed_cooling)then"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        if(ok(j))then"
  write(ilun,format)"           uold(indp(j),idelay)=uold(indp(j),idelay)+mloss(j)"
  write(ilun,format)"        endif"
  write(ilun,format)"     end do"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"#endif"
  write(ilun,format)"  "
  write(ilun,format)"end subroutine feedbk"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine blast_wave_feedback(ilevel, icount)"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use random"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  integer::ilevel,icount"
  write(ilun,format)"! this routine is used in this patch to inject thermal"
  write(ilun,format)"! and kinetic energy when a SNR explodes."
  write(ilun,format)"  integer::ind,ix,iy,iz,ngrid,iskip,ilev"
  write(ilun,format)"  integer::i,nx_loc,igrid,ncache,info"
  write(ilun,format)"  integer,dimension(1:nvector),save::ind_grid,ind_cell"
  write(ilun,format)"  real(dp)::x,y,z,dx,dxx,dyy,dzz,drr,dtprob"
  write(ilun,format)"  real(dp)::scale,dx_min,dx_loc,vol_loc,rmax2,rmax"
  write(ilun,format)"  real(dp)::rboost,vlimit "
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v"
  write(ilun,format)"  real(dp),dimension(1:3)::skip_loc"
  write(ilun,format)"  real(dp),dimension(1:twotondim,1:3)::xc"
  write(ilun,format)"  logical ,dimension(1:nvector)::ok"
  write(ilun,format)"  real(kind=8)::RandNum,xsnr,ysnr,zsnr"
  write(ilun,format)"  real(dp)::vri,vxi,vyi,vzi,mu"
  write(ilun,format)"  real(dp)::Ei,Vi,Pi_,M_ej,rho_ej,pi,rho_average,weight,rho_average_all,weight_all"
  write(ilun,format)"  real(dp)::Z_average,Z_average_all"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:3)::pos"
  write(ilun,format)"  integer,dimension(1:nvector)::cell_index,cell_levl,cc"
  write(ilun,format)""
  write(ilun,format)"  real(dp)::alpha,rcool,rrise,rnod,rbreak"
  write(ilun,format)""
  write(ilun,format)"  integer::exp_type"
  write(ilun,format)""
  write(ilun,format)"  if(numbtot(1,ilevel)==0)return"
  write(ilun,format)"  if(verbose)write(*,111)ilevel"
  write(ilun,format)"  if(icount==2)return"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh spacing in that level"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  skip_loc=(/0.0d0,0.0d0,0.0d0/)"
  write(ilun,format)"  skip_loc(1)=dble(icoarse_min)"
  write(ilun,format)"  skip_loc(2)=dble(jcoarse_min)"
  write(ilun,format)"  skip_loc(3)=dble(kcoarse_min)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_min=scale*0.5D0**nlevelmax"
  write(ilun,format)""
  write(ilun,format)"  ! Conversion factor from user units to cgs units"
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)""
  write(ilun,format)"  pi=3.14159265359"
  write(ilun,format)""
  write(ilun,format)"  ! Maximum radius of the ejecta"
  write(ilun,format)"  rmax=rc/aexp ! Check the units of the ejecta radius. Not sure about aexp, no problem for cosmo=.false.."
  write(ilun,format)"  rmax2=rmax*rmax"
  write(ilun,format)""
  write(ilun,format)"  ! Check if it is the right time for a SN to explode."
  write(ilun,format)"  nsnr=int(sn_rate*tout(noutput))"
  write(ilun,format)"  if(.not.init_marker)then"
  write(ilun,format)"     allocate(marker(1:nsnr))"
  write(ilun,format)"     marker=0"
  write(ilun,format)"     do i=1,nblast_current"
  write(ilun,format)"        marker(i)=1"
  write(ilun,format)"     end do"
  write(ilun,format)"     nblast_current_internal=nblast_current"
  write(ilun,format)"     init_marker=.true."
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  do while (nblast_current_internal.lt.nsnr .and. & "
  write(ilun,format)"       & random_expl(nblast_current_internal+1).lt. & "
  write(ilun,format)"       & (t-dble(nblast_current_internal)*tout(noutput)/dble(nsnr))*dble(nsnr)/tout(noutput))"
  write(ilun,format)""
  write(ilun,format)"     if(marker(nblast_current_internal+1).eq.0)then"
  write(ilun,format)""
  write(ilun,format)"        nblast_current_internal=nblast_current_internal+1"
  write(ilun,format)"        marker(nblast_current_internal)=1"
  write(ilun,format)"        ! Now extract the position of the SNR in the computational box"
  write(ilun,format)"        ! at this step we choose to distribute the SN explosions"
  write(ilun,format)"        ! randomly in the box"
  write(ilun,format)"        pos=0.0d0"
  write(ilun,format)""
  write(ilun,format)"        xsnr=x_expl(nblast_current_internal)*scale"
  write(ilun,format)"        ysnr=y_expl(nblast_current_internal)*scale"
  write(ilun,format)"        zsnr=z_expl(nblast_current_internal)*scale"
  write(ilun,format)"        exp_type=1"
  write(ilun,format)""
  write(ilun,format)"        if(random_NSM(nblast_current_internal) < conversion_NSM.and.random_Ia(nblast_current_internal)>=conversion_Ia)then"
  write(ilun,format)"           exp_type=2"
  write(ilun,format)"           zsnr=(z_expl(nblast_current_internal)-0.5)*scale*H_NSM+0.5*scale"
  write(ilun,format)"        else if (random_Ia(nblast_current_internal) < conversion_Ia .and. random_NSM(nblast_current_internal)>=conversion_NSM)then"
  write(ilun,format)"           exp_type=3"
  write(ilun,format)"           zsnr=(z_expl(nblast_current_internal)-0.5)*scale*H_Ia+0.5*scale"
  write(ilun,format)"        else if (random_Ia(nblast_current_internal) < conversion_Ia .and. random_NSM(nblast_current_internal) < conversion_NSM) then "
  write(ilun,format)"           if (dice(nblast_current_internal)<Ia_vs_NSM)then"
  write(ilun,format)"              exp_type=3"
  write(ilun,format)"              zsnr=(z_expl(nblast_current_internal)-0.5)*scale*H_Ia+0.5*scale"
  write(ilun,format)"           else"
  write(ilun,format)"              exp_type=2"
  write(ilun,format)"              zsnr=(z_expl(nblast_current_internal)-0.5)*scale*H_NSM+0.5*scale"
  write(ilun,format)"           end if "
  write(ilun,format)"        end if"
  write(ilun,format)""
  write(ilun,format)"        ! Identify the cpu and the cell where the blastwave center will be."
  write(ilun,format)"        pos(1,1)=xsnr"
  write(ilun,format)"        pos(1,2)=ysnr"
  write(ilun,format)"        pos(1,3)=zsnr"
  write(ilun,format)""
  write(ilun,format)"        ! Compute average density"
  write(ilun,format)""
  write(ilun,format)"        rho_average=0.0d0"
  write(ilun,format)"        weight=1.0d-20"
  write(ilun,format)"        Z_average=0.0d0"
  write(ilun,format)""
  write(ilun,format)"        ! Loop over levels"
  write(ilun,format)"        do ilev=levelmin,nlevelmax"
  write(ilun,format)"           ! Computing local volume (important for averaging hydro quantities)"
  write(ilun,format)"           dx=0.5D0**ilev"
  write(ilun,format)"           dx_loc=dx*scale"
  write(ilun,format)"           vol_loc=dx_loc**ndim"
  write(ilun,format)"           ! Cells center position relative to grid center position"
  write(ilun,format)"           do ind=1,twotondim"
  write(ilun,format)"              iz=(ind-1)/4"
  write(ilun,format)"              iy=(ind-1-4*iz)/2"
  write(ilun,format)"              ix=(ind-1-2*iy-4*iz)"
  write(ilun,format)"              xc(ind,1)=(dble(ix)-0.5D0)*dx"
  write(ilun,format)"              xc(ind,2)=(dble(iy)-0.5D0)*dx"
  write(ilun,format)"              xc(ind,3)=(dble(iz)-0.5D0)*dx"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"           ! Loop over grids"
  write(ilun,format)"           ncache=active(ilev)%ngrid"
  write(ilun,format)"           do igrid=1,ncache,nvector"
  write(ilun,format)"              ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 ind_grid(i)=active(ilev)%igrid(igrid+i-1)"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"              ! Loop over cells"
  write(ilun,format)"              do ind=1,twotondim"
  write(ilun,format)"                 iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"                 do i=1,ngrid"
  write(ilun,format)"                    ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"                 end do"
  write(ilun,format)""
  write(ilun,format)"                 ! Flag leaf cells"
  write(ilun,format)"                 do i=1,ngrid"
  write(ilun,format)"                    ok(i)=son(ind_cell(i))==0"
  write(ilun,format)"                 end do"
  write(ilun,format)""
  write(ilun,format)"                 do i=1,ngrid"
  write(ilun,format)"                    if(ok(i))then"
  write(ilun,format)"                       ! Get gas cell position"
  write(ilun,format)"                       x=(xg(ind_grid(i),1)+xc(ind,1)-skip_loc(1))*scale"
  write(ilun,format)"                       y=(xg(ind_grid(i),2)+xc(ind,2)-skip_loc(2))*scale"
  write(ilun,format)"                       z=(xg(ind_grid(i),3)+xc(ind,3)-skip_loc(3))*scale"
  write(ilun,format)""
  write(ilun,format)"                       ! Check if the cell lies within the ejecta radius"
  write(ilun,format)"                       dxx=x-xsnr"
  write(ilun,format)"                       if(dxx> 0.5*scale)then"
  write(ilun,format)"                          dxx=dxx-scale"
  write(ilun,format)"                       endif"
  write(ilun,format)"                       if(dxx<-0.5*scale)then"
  write(ilun,format)"                          dxx=dxx+scale"
  write(ilun,format)"                       endif"
  write(ilun,format)"                       dyy=y-ysnr"
  write(ilun,format)"                       if(dyy> 0.5*scale)then"
  write(ilun,format)"                          dyy=dyy-scale"
  write(ilun,format)"                       endif"
  write(ilun,format)"                       if(dyy<-0.5*scale)then"
  write(ilun,format)"                          dyy=dyy+scale"
  write(ilun,format)"                       endif"
  write(ilun,format)"                       dzz=z-zsnr"
  write(ilun,format)"                       if(dzz> 0.5*scale)then"
  write(ilun,format)"                          dzz=dzz-scale"
  write(ilun,format)"                       endif"
  write(ilun,format)"                       if(dzz<-0.5*scale)then"
  write(ilun,format)"                          dzz=dzz+scale"
  write(ilun,format)"                       endif"
  write(ilun,format)"                       drr=dxx*dxx+dyy*dyy+dzz*dzz"
  write(ilun,format)""
  write(ilun,format)"                       if(drr.lt.rmax2)then"
  write(ilun,format)"                          rho_average=rho_average+uold(ind_cell(i),1)*vol_loc"
  write(ilun,format)"                          weight=weight+vol_loc"
  write(ilun,format)"                          if(metal)Z_average=Z_average+uold(ind_cell(i),6)/uold(ind_cell(i),1)*vol_loc+uold(ind_cell(i),7)/uold(ind_cell(i),1)*vol_loc+uold(ind_cell(i),8)/uold(ind_cell(i),1)*vol_loc"
  write(ilun,format)"                       endif"
  write(ilun,format)"                    endif"
  write(ilun,format)"                 end do"
  write(ilun,format)""
  write(ilun,format)"              end do"
  write(ilun,format)"              ! End loop over cells"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! End loop over grids"
  write(ilun,format)"        end do"
  write(ilun,format)"        ! End loop over levels"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"        rho_average_all=0.0d0"
  write(ilun,format)"        weight_all=0.0d0"
  write(ilun,format)"        call MPI_ALLREDUCE(rho_average,rho_average_all,1,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"        rho_average=rho_average_all"
  write(ilun,format)"        call MPI_ALLREDUCE(weight,weight_all,1,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"        weight=weight_all"
  write(ilun,format)"        if(metal)then"
  write(ilun,format)"           Z_average_all=0.0d0"
  write(ilun,format)"           call MPI_ALLREDUCE(Z_average,Z_average_all,1,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"           Z_average=Z_average_all"
  write(ilun,format)"        end if"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"        rho_average=rho_average/weight"
  write(ilun,format)"        Z_average=Z_average/weight"
  write(ilun,format)""
  write(ilun,format)"        if(Z_average/0.02<0.01) Z_average = 0.01"
  write(ilun,format)""
  write(ilun,format)"        vlimit=5.0d7 ! cm/s limit velocity"
  write(ilun,format)"        ! Momentum criterion"
  write(ilun,format)"        rboost=((2.84d43*(rho_average/100)**(-0.16)-5.97*1d33*vlimit) &"
  write(ilun,format)"             & /(4.0*3.1415*vlimit*rho_average*1.66d-24/(3.0*0.76)))**(1.0/3.0)/scale_l/(rc/aexp)"
  write(ilun,format)"        rmax=max(rc/aexp,rboost*rc/aexp)"
  write(ilun,format)"        ! Thermal energy criterion"
  write(ilun,format)"        alpha=-7.83*(rho_average/scale_nH/100.)**(0.024)*(Z_average/0.02)**(0.050)"
  write(ilun,format)"        rcool=3.021*3.08d18/scale_l*(rho_average/scale_nH/100.)**(-0.421)*(Z_average/0.02)**(-0.082)"
  write(ilun,format)"        rrise=5.472*3.08d18/scale_l*(rho_average/scale_nH/100.)**(-0.403)*(Z_average/0.02)**(-0.074)"
  write(ilun,format)"        !alpha=-11.3*(rho_average/scale_nH/100.)**(0.072)*(Z_average/0.02)**(0.070)"
  write(ilun,format)"        !rcool=6.35*3.08d18/scale_l*(rho_average/scale_nH/100.)**(-0.418)*(Z_average/0.02)**(-0.050)"
  write(ilun,format)"        !rrise=9.19*3.08d18/scale_l*(rho_average/scale_nH/100.)**(-0.439)*(Z_average/0.02)**(-0.067)"
  write(ilun,format)"        if (rc/aexp<rcool) then"
  write(ilun,format)"           E_SN_th=7.1d50"
  write(ilun,format)"        else"
  write(ilun,format)"           if (rcool <= rc/aexp .and. rc/aexp < rrise) then"
  write(ilun,format)"              E_SN_th=7.1d50*(rc/aexp/rcool)**alpha"
  write(ilun,format)"           else"
  write(ilun,format)"              E_SN_th=7.1d50*(rrise/rcool)**alpha"
  write(ilun,format)"           end if"
  write(ilun,format)"        end if"
  write(ilun,format)"        rboost=(3.0*0.76*gamma*(gamma-1.0)*E_SN_th/(4.0*3.1415*1.66d-24*rho_average*vlimit**2))**(1.0/3.0)/scale_l/(rc/aexp)"
  write(ilun,format)"        rmax=max(rmax,rboost*rc/aexp)"
  write(ilun,format)"        rmax=min(rmax,50.*3.08d18/scale_l)"
  write(ilun,format)"        ind=int(rmax/dx_min)+1"
  write(ilun,format)"        rmax=1.1*dble(ind)*dx_min"
  write(ilun,format)"        rmax2=rmax*rmax"
  write(ilun,format)""
  write(ilun,format)"        rmax=rc/aexp"
  write(ilun,format)"        rmax2=rmax*rmax"
  write(ilun,format)"        if(myid==1)write(*,*)'Average density: ',rho_average"
  write(ilun,format)"        if(myid==1)write(*,*)'Average metalicity =', Z_average/0.02"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"        ! Compute average density"
  write(ilun,format)"        rho_average=0.0d0"
  write(ilun,format)"        weight=1.0d-20"
  write(ilun,format)"        Z_average=0.0d0"
  write(ilun,format)""
  write(ilun,format)"        ! Loop over levels "
  write(ilun,format)"        do ilev=levelmin,nlevelmax"
  write(ilun,format)"           ! Computing local volume (important for averaging hydro quantities) "
  write(ilun,format)"           dx=0.5D0**ilev"
  write(ilun,format)"           dx_loc=dx*scale"
  write(ilun,format)"           vol_loc=dx_loc**ndim"
  write(ilun,format)"           ! Cells center position relative to grid center position"
  write(ilun,format)"           do ind=1,twotondim"
  write(ilun,format)"              iz=(ind-1)/4"
  write(ilun,format)"              iy=(ind-1-4*iz)/2"
  write(ilun,format)"              ix=(ind-1-2*iy-4*iz)"
  write(ilun,format)"              xc(ind,1)=(dble(ix)-0.5D0)*dx"
  write(ilun,format)"              xc(ind,2)=(dble(iy)-0.5D0)*dx"
  write(ilun,format)"              xc(ind,3)=(dble(iz)-0.5D0)*dx"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"           ! Loop over grids"
  write(ilun,format)"           ncache=active(ilev)%ngrid"
  write(ilun,format)"           do igrid=1,ncache,nvector"
  write(ilun,format)"              ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 ind_grid(i)=active(ilev)%igrid(igrid+i-1)"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"              ! Loop over cells"
  write(ilun,format)"              do ind=1,twotondim"
  write(ilun,format)"                 iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"                 do i=1,ngrid"
  write(ilun,format)"                    ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"                 end do"
  write(ilun,format)""
  write(ilun,format)"                 ! Flag leaf cells"
  write(ilun,format)"                 do i=1,ngrid"
  write(ilun,format)"                    ok(i)=son(ind_cell(i))==0"
  write(ilun,format)"                 end do"
  write(ilun,format)""
  write(ilun,format)"                 do i=1,ngrid"
  write(ilun,format)"                    if(ok(i))then"
  write(ilun,format)"                       ! Get gas cell position "
  write(ilun,format)"                       x=(xg(ind_grid(i),1)+xc(ind,1)-skip_loc(1))*scale"
  write(ilun,format)"                       y=(xg(ind_grid(i),2)+xc(ind,2)-skip_loc(2))*scale"
  write(ilun,format)"                       z=(xg(ind_grid(i),3)+xc(ind,3)-skip_loc(3))*scale"
  write(ilun,format)""
  write(ilun,format)"                       ! Check if the cell lies within the ejecta radius"
  write(ilun,format)"                       dxx=x-xsnr"
  write(ilun,format)"                       if(dxx> 0.5*scale)then"
  write(ilun,format)"                          dxx=dxx-scale"
  write(ilun,format)"                       endif"
  write(ilun,format)"                       if(dxx<-0.5*scale)then"
  write(ilun,format)"                          dxx=dxx+scale"
  write(ilun,format)"                       endif"
  write(ilun,format)"                       dyy=y-ysnr"
  write(ilun,format)"                       if(dyy> 0.5*scale)then"
  write(ilun,format)"                          dyy=dyy-scale"
  write(ilun,format)"                       endif"
  write(ilun,format)"                       if(dyy<-0.5*scale)then"
  write(ilun,format)"                          dyy=dyy+scale"
  write(ilun,format)"                       endif"
  write(ilun,format)"                       dzz=z-zsnr"
  write(ilun,format)"                       if(dzz> 0.5*scale)then"
  write(ilun,format)"                          dzz=dzz-scale"
  write(ilun,format)"                       endif"
  write(ilun,format)"                       if(dzz<-0.5*scale)then"
  write(ilun,format)"                          dzz=dzz+scale"
  write(ilun,format)"                       endif"
  write(ilun,format)"                       drr=dxx*dxx+dyy*dyy+dzz*dzz"
  write(ilun,format)""
  write(ilun,format)"                       if(drr.lt.rmax2)then"
  write(ilun,format)"                          rho_average=rho_average+uold(ind_cell(i),1)*vol_loc"
  write(ilun,format)"                          weight=weight+vol_loc"
  write(ilun,format)"                          if(metal)Z_average=Z_average+uold(ind_cell(i),6)/uold(ind_cell(i),1)*vol_loc+uold(ind_cell(i),7)/uold(ind_cell(i),1)*vol_loc + uold(ind_cell(i),8)/uold(ind_cell(i),1)*vol_loc"
  write(ilun,format)"                       endif"
  write(ilun,format)"                    endif"
  write(ilun,format)"                 end do"
  write(ilun,format)""
  write(ilun,format)"              end do"
  write(ilun,format)"              ! End loop over cells"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! End loop over grids"
  write(ilun,format)"        end do"
  write(ilun,format)"        ! End loop over levels   "
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"        rho_average_all=0.0d0"
  write(ilun,format)"        weight_all=0.0d0"
  write(ilun,format)"        call MPI_ALLREDUCE(rho_average,rho_average_all,1,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"        rho_average=rho_average_all"
  write(ilun,format)"        call MPI_ALLREDUCE(weight,weight_all,1,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"        weight=weight_all"
  write(ilun,format)"        if(metal)then"
  write(ilun,format)"           Z_average_all=0.0d0"
  write(ilun,format)"           call MPI_ALLREDUCE(Z_average,Z_average_all,1,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"           Z_average=Z_average_all"
  write(ilun,format)"        end if"
  write(ilun,format)"#endif"
  write(ilun,format)"        "
  write(ilun,format)"        rho_average=rho_average/weight"
  write(ilun,format)"        Z_average=Z_average_all/weight"
  write(ilun,format)""
  write(ilun,format)"        if(Z_average/0.02<0.01) Z_average = 0.01"
  write(ilun,format)""
  write(ilun,format)"        if(myid==1)write(*,*)'Average density ', rho_average"
  write(ilun,format)"        if(myid==1)write(*,*)'Average metalliciy (solar units) ', Z_average"
  write(ilun,format)"        if(myid==1)write(*,*)'Output number = ', noutput"
  write(ilun,format)""
  write(ilun,format)"        !Subgrid model                                                                                                                                                                                                                                                        "
  write(ilun,format)"        rbreak=4.001*3.08d18/scale_l*(rho_average/scale_nH/100.)**(-0.429)*(Z_average/0.02)**(-0.077)"
  write(ilun,format)"        rnod=0.969*3.08d18/scale_l*(rho_average/scale_nH/100.)**(-0.330)*(Z_average/0.02)**(0.046)"
  write(ilun,format)"        !rbreak=7.97*3.08d18/scale_l*(rho_average/scale_nH/100.)**(-0.458)*(Z_average/0.02)**(-0.058)"
  write(ilun,format)"        !rnod=2.438*3.08d18/scale_l*(rho_average/scale_nH/100.)**(-0.349)*(Z_average/0.02)**(0.021)"
  write(ilun,format)"        !Momentum"
  write(ilun,format)"        if (rmax<rbreak) then"
  write(ilun,format)"           P_SN_rad=3.479830d42*(rmax/rnod)**1.5"
  write(ilun,format)"        else"
  write(ilun,format)"           P_SN_rad=3.479830d42*(rbreak/rnod)**1.5"
  write(ilun,format)"        end if"
  write(ilun,format)"        !Thermal energy"
  write(ilun,format)"        alpha=-7.83*(rho_average/scale_nH/100.)**(0.024)*(Z_average/0.02)**(0.050)"
  write(ilun,format)"        rcool=3.021*3.08d18/scale_l*(rho_average/scale_nH/100.)**(-0.421)*(Z_average/0.02)**(-0.082)"
  write(ilun,format)"        rrise=5.472*3.08d18/scale_l*(rho_average/scale_nH/100.)**(-0.403)*(Z_average/0.02)**(-0.074)"
  write(ilun,format)"        !alpha=-11.3*(rho_average/scale_nH/100.)**(0.072)*(Z_average/0.02)**(0.070)"
  write(ilun,format)"        !rcool=6.35*3.08d18/scale_l*(rho_average/scale_nH/100.)**(-0.418)*(Z_average/0.02)**(-0.050)"
  write(ilun,format)"        !rrise=9.19*3.08d18/scale_l*(rho_average/scale_nH/100.)**(-0.439)*(Z_average/0.02)**(-0.067)"
  write(ilun,format)"        if (rmax<rcool) then"
  write(ilun,format)"           E_SN_th=7.1d50"
  write(ilun,format)"        else"
  write(ilun,format)"           if (rcool <= rmax .and. rmax < rrise) then"
  write(ilun,format)"              E_SN_th=7.1d50*(rmax/rcool)**alpha"
  write(ilun,format)"           else"
  write(ilun,format)"              E_SN_th=7.1d50*(rrise/rcool)**alpha"
  write(ilun,format)"           end if"
  write(ilun,format)"        end if"
  write(ilun,format)""
  write(ilun,format)"        if(myid==1.and.exp_type==1)write(*,*)'SN explosion, E_th, P_rad (cgs) =',E_SN_th,P_SN_rad"
  write(ilun,format)"        if(myid==1.and.exp_type==2)write(*,*)'NSM explosion, E_th, P_rad (cgs) =', E_SN_th, P_SN_rad"
  write(ilun,format)"        if(myid==1.and.exp_type==3)write(*,*)'Ia explosion, E_th, P_rad (cgs) =', E_SN_th, P_SN_rad"
  write(ilun,format)""
  write(ilun,format)"        ! Inject supernova energy and momentum"
  write(ilun,format)"        ! Loop over levels"
  write(ilun,format)"        do ilev=levelmin,nlevelmax"
  write(ilun,format)"           ! Computing local volume (important for averaging hydro quantities)"
  write(ilun,format)"           dx=0.5D0**ilev"
  write(ilun,format)"           dx_loc=dx*scale"
  write(ilun,format)"           vol_loc=dx_loc**ndim"
  write(ilun,format)"           ! Cells center position relative to grid center position"
  write(ilun,format)"           do ind=1,twotondim"
  write(ilun,format)"              iz=(ind-1)/4"
  write(ilun,format)"              iy=(ind-1-4*iz)/2"
  write(ilun,format)"              ix=(ind-1-2*iy-4*iz)"
  write(ilun,format)"              xc(ind,1)=(dble(ix)-0.5D0)*dx"
  write(ilun,format)"              xc(ind,2)=(dble(iy)-0.5D0)*dx"
  write(ilun,format)"              xc(ind,3)=(dble(iz)-0.5D0)*dx"
  write(ilun,format)"           end do"
  write(ilun,format)"           "
  write(ilun,format)"           ! Loop over grids"
  write(ilun,format)"           ncache=active(ilev)%ngrid"
  write(ilun,format)"           do igrid=1,ncache,nvector"
  write(ilun,format)"              ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 ind_grid(i)=active(ilev)%igrid(igrid+i-1)"
  write(ilun,format)"              end do"
  write(ilun,format)"              "
  write(ilun,format)"              ! Loop over cells"
  write(ilun,format)"              do ind=1,twotondim"
  write(ilun,format)"                 iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"                 do i=1,ngrid"
  write(ilun,format)"                    ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"                 end do"
  write(ilun,format)"                 "
  write(ilun,format)"                 ! Flag leaf cells"
  write(ilun,format)"                 do i=1,ngrid"
  write(ilun,format)"                    ok(i)=son(ind_cell(i))==0"
  write(ilun,format)"                 end do"
  write(ilun,format)"                 "
  write(ilun,format)"                 do i=1,ngrid"
  write(ilun,format)"                    if(ok(i))then"
  write(ilun,format)"                       ! Get gas cell position"
  write(ilun,format)"                       x=(xg(ind_grid(i),1)+xc(ind,1)-skip_loc(1))*scale"
  write(ilun,format)"                       y=(xg(ind_grid(i),2)+xc(ind,2)-skip_loc(2))*scale"
  write(ilun,format)"                       z=(xg(ind_grid(i),3)+xc(ind,3)-skip_loc(3))*scale"
  write(ilun,format)"                       "
  write(ilun,format)"                       ! Check if the cell lies within the ejecta radius"
  write(ilun,format)"                       dxx=x-xsnr"
  write(ilun,format)"                       if(dxx> 0.5*scale)then"
  write(ilun,format)"                          dxx=dxx-scale"
  write(ilun,format)"                       endif"
  write(ilun,format)"                       if(dxx<-0.5*scale)then"
  write(ilun,format)"                          dxx=dxx+scale"
  write(ilun,format)"                       endif"
  write(ilun,format)"                       dyy=y-ysnr"
  write(ilun,format)"                       if(dyy> 0.5*scale)then"
  write(ilun,format)"                          dyy=dyy-scale"
  write(ilun,format)"                       endif"
  write(ilun,format)"                       if(dyy<-0.5*scale)then"
  write(ilun,format)"                          dyy=dyy+scale"
  write(ilun,format)"                       endif"
  write(ilun,format)"                       dzz=z-zsnr"
  write(ilun,format)"                       if(dzz> 0.5*scale)then"
  write(ilun,format)"                          dzz=dzz-scale"
  write(ilun,format)"                       endif"
  write(ilun,format)"                       if(dzz<-0.5*scale)then"
  write(ilun,format)"                          dzz=dzz+scale"
  write(ilun,format)"                       endif"
  write(ilun,format)"                       drr=dxx*dxx+dyy*dyy+dzz*dzz"
  write(ilun,format)"                       "
  write(ilun,format)"                       if(drr.lt.rmax2)then"
  write(ilun,format)"                          ! Update the gas properties"
  write(ilun,format)"                          "
  write(ilun,format)"                          ! Thermal and kinetic energy have been alreadyconverted to code units"
  write(ilun,format)"                          ! in condinit. They are global variables. They should not be converted here."
  write(ilun,format)"                          "
  write(ilun,format)"                          ! Initial pressure in the injection radius, in code units."
  write(ilun,format)"                          ! Use for injection in thermal form."
  write(ilun,format)"                          Vi = (4.0*pi*rmax**3.0)/3.0 ! code units"
  write(ilun,format)"                          Pi_ = (2.0/3.0)*(E_SN_th/Vi/(scale_v**2.0*scale_d*scale_l**3.0))"
  write(ilun,format)"                          "
  write(ilun,format)"                          if(random_NSM(nblast_current_internal)<conversion_NSM.and.random_Ia(nblast_current_internal)>=conversion_Ia)then"
  write(ilun,format)"                             M_ej = 0.01*1.98*1d33"
  write(ilun,format)""
  write(ilun,format)"                             M_ej = M_ej/(scale_d*scale_l**3.0)"
  write(ilun,format)"                             rho_ej = M_ej/Vi"
  write(ilun,format)""
  write(ilun,format)"                          else if (random_Ia(nblast_current_internal)<conversion_Ia.and.random_NSM(nblast_current_internal)>=conversion_NSM)then"
  write(ilun,format)"                             M_ej = 1.4*1.98*1d33"
  write(ilun,format)"                             "
  write(ilun,format)"                             M_ej = M_ej/(scale_d*scale_l**3.0)"
  write(ilun,format)"                             rho_ej = M_ej/Vi"
  write(ilun,format)"                          else if (random_Ia(nblast_current_internal)<conversion_Ia.and.random_NSM(nblast_current_internal)<conversion_NSM)then"
  write(ilun,format)"                             if (dice(nblast_current_internal)< Ia_vs_NSM)then"
  write(ilun,format)"                                M_ej = 1.4*1.98*1d33"
  write(ilun,format)"                                "
  write(ilun,format)"                                M_ej = M_ej/(scale_d*scale_l**3.0)"
  write(ilun,format)"                                rho_ej = M_ej/Vi"
  write(ilun,format)"                             else "
  write(ilun,format)"                                M_ej = 0.01*1.98*1d33"
  write(ilun,format)"                                "
  write(ilun,format)"                                M_ej = M_ej/(scale_d*scale_l**3.0)"
  write(ilun,format)"                                rho_ej = M_ej/Vi"
  write(ilun,format)"                             end if "
  write(ilun,format)"                          else "
  write(ilun,format)"                             ! Density of SN ejecta, assuming uniformly distributed within rmax, as"
  write(ilun,format)"                             ! in Thornton et al. (1998)."
  write(ilun,format)"                             M_ej = 6.8*1.98*1d33 ! 3 Msun, cgs"
  write(ilun,format)"                          "
  write(ilun,format)"                             ! Mass from cgs to code units."
  write(ilun,format)"                             M_ej = M_ej/(scale_d*scale_l**3.0)"
  write(ilun,format)"                             rho_ej = M_ej/Vi"
  write(ilun,format)"                          end if"
  write(ilun,format)""
  write(ilun,format)"                          ! Radial velocity of the gas within rmax"
  write(ilun,format)"                          vri = 3.0*P_SN_rad/(4.0*pi*(rho_ej+rho_average)*rmax**3.0)/(scale_v*scale_d*scale_l**3.0)"
  write(ilun,format)""
  write(ilun,format)"                          ! As in courant_file.f90."
  write(ilun,format)"                          mu = 0.6"
  write(ilun,format)"                          "
  write(ilun,format)"                          vxi = dxx*vri/sqrt(drr)"
  write(ilun,format)"                          vyi = dyy*vri/sqrt(drr)"
  write(ilun,format)"                          vzi = dzz*vri/sqrt(drr)"
  write(ilun,format)"                          "
  write(ilun,format)"                          ! This is a what is done when the blast-wave is simply added"
  write(ilun,format)"                          uold(ind_cell(i),1)=rho_ej+rho_average "
  write(ilun,format)"                          uold(ind_cell(i),2)=uold(ind_cell(i),2)+(rho_ej+rho_average)*vxi"
  write(ilun,format)"                          uold(ind_cell(i),3)=uold(ind_cell(i),3)+(rho_ej+rho_average)*vyi"
  write(ilun,format)"                          uold(ind_cell(i),4)=uold(ind_cell(i),4)+(rho_ej+rho_average)*vzi"
  write(ilun,format)"                          uold(ind_cell(i),5)=uold(ind_cell(i),5)+0.5*(rho_ej+rho_average)*(vxi**2+vyi**2+vzi**2)+Pi_/(gamma-1.0d0)"
  write(ilun,format)"                          if(metal.and.random_NSM(nblast_current_internal)>=conversion_NSM.and.random_Ia(nblast_current_internal)>=conversion_Ia)then"
  write(ilun,format)"                             uold(ind_cell(i),6)=uold(ind_cell(i),6)+yield_cc_Fe*rho_ej ! metal yield"
  write(ilun,format)"                             uold(ind_cell(i),7)=uold(ind_cell(i),7)+yield_cc_alpha*rho_ej"
  write(ilun,format)"                             uold(ind_cell(i),8)=uold(ind_cell(i),8)+yield_cc_rp*rho_ej"
  write(ilun,format)""
  write(ilun,format)"                          else if(metal.and.random_NSM(nblast_current_internal)<conversion_NSM.and.random_Ia(nblast_current_internal)>=conversion_Ia)then"
  write(ilun,format)"                             uold(ind_cell(i),6)=uold(ind_cell(i),6)+yield_NSM_Fe*rho_ej"
  write(ilun,format)"                             uold(ind_cell(i),7)=uold(ind_cell(i),7)+yield_NSM_alpha*rho_ej"
  write(ilun,format)"                             uold(ind_cell(i),8)=uold(ind_cell(i),8)+yield_NSM_rp*rho_ej"
  write(ilun,format)""
  write(ilun,format)"                          else if(metal.and.random_NSM(nblast_current_internal)>=conversion_NSM.and.random_Ia(nblast_current_internal)<conversion_Ia)then"
  write(ilun,format)"                             uold(ind_cell(i),6)=uold(ind_cell(i),6)+yield_Ia_Fe*rho_ej"
  write(ilun,format)"                             uold(ind_cell(i),7)=uold(ind_cell(i),7)+yield_Ia_alpha*rho_ej"
  write(ilun,format)"                             uold(ind_cell(i),8)=uold(ind_cell(i),8)+yield_Ia_rp*rho_ej"
  write(ilun,format)"                          else if(metal.and.random_NSM(nblast_current_internal)<conversion_NSM.and.random_Ia(nblast_current_internal)<conversion_Ia)then"
  write(ilun,format)"                             if (dice(nblast_current_internal)<Ia_vs_NSM)then"
  write(ilun,format)"                                uold(ind_cell(i),6)=uold(ind_cell(i),6)+yield_Ia_Fe*rho_ej"
  write(ilun,format)"                                uold(ind_cell(i),7)=uold(ind_cell(i),7)+yield_Ia_alpha*rho_ej"
  write(ilun,format)"                                uold(ind_cell(i),8)=uold(ind_cell(i),8)+yield_Ia_rp*rho_ej"
  write(ilun,format)"                             else "
  write(ilun,format)"                                uold(ind_cell(i),6)=uold(ind_cell(i),6)+yield_NSM_Fe*rho_ej"
  write(ilun,format)"                                uold(ind_cell(i),7)=uold(ind_cell(i),7)+yield_NSM_alpha*rho_ej"
  write(ilun,format)"                                uold(ind_cell(i),8)=uold(ind_cell(i),8)+yield_NSM_rp*rho_ej"
  write(ilun,format)"                             end if "
  write(ilun,format)"                          end if"
  write(ilun,format)"                       endif"
  write(ilun,format)"                    endif"
  write(ilun,format)"                 end do"
  write(ilun,format)"                 "
  write(ilun,format)"              end do"
  write(ilun,format)"              ! End loop over cells"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! End loop over grids"
  write(ilun,format)"        end do"
  write(ilun,format)"        ! End loop over levels"
  write(ilun,format)"        "
  write(ilun,format)"     end if"
  write(ilun,format)"  end do"
  write(ilun,format)"  "
  write(ilun,format)"111 format('   Entering blast_wave_feedback for level ',I2)"
  write(ilun,format)"  "
  write(ilun,format)"end subroutine blast_wave_feedback"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine kinetic_feedback"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use cooling_module, ONLY: XH=>X, rhoc, mH "
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"  integer::nSN_tot_all"
  write(ilun,format)"  integer,dimension(1:ncpu)::nSN_icpu_all"
  write(ilun,format)"  real(dp),dimension(:),allocatable::mSN_all,sSN_all,ZSN_all"
  write(ilun,format)"  real(dp),dimension(:,:),allocatable::xSN_all,vSN_all"
  write(ilun,format)"#endif"
  write(ilun,format)"  !----------------------------------------------------------------------"
  write(ilun,format)"  ! This subroutine compute the kinetic feedback due to SNII and"
  write(ilun,format)"  ! implement this using exploding GMC particles. "
  write(ilun,format)"  ! This routine is called only at coarse time step."
  write(ilun,format)"  ! Yohan Dubois"
  write(ilun,format)"  !----------------------------------------------------------------------"
  write(ilun,format)"  ! local constants"
  write(ilun,format)"  integer::ip,icpu,igrid,jgrid,npart1,npart2,ipart,jpart,next_part"
  write(ilun,format)"  integer::nSN,nSN_loc,nSN_tot,info,iSN,ilevel,ivar"
  write(ilun,format)"  integer,dimension(1:ncpu)::nSN_icpu"
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v,t0"
  write(ilun,format)"  real(dp)::scale,dx_min,vol_min,nISM,nCOM,d0,mstar"
  write(ilun,format)"  integer::nx_loc"
  write(ilun,format)"  integer,dimension(:),allocatable::ind_part,ind_grid"
  write(ilun,format)"  logical,dimension(:),allocatable::ok_free"
  write(ilun,format)"  integer ,dimension(:),allocatable::indSN"
  write(ilun,format)"  real(dp),dimension(:),allocatable::mSN,sSN,ZSN,m_gas,vol_gas,ekBlast"
  write(ilun,format)"  real(dp),dimension(:,:),allocatable::xSN,vSN,u_gas,dq"
  write(ilun,format)""
  write(ilun,format)"  if(.not. hydro)return"
  write(ilun,format)"  if(ndim.ne.3)return"
  write(ilun,format)""
  write(ilun,format)"  if(verbose)write(*,*)'Entering make_sn'"
  write(ilun,format)"  "
  write(ilun,format)"  ! Conversion factor from user units to cgs units"
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh spacing in that level"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_min=(0.5D0**nlevelmax)*scale"
  write(ilun,format)"  vol_min=dx_min**ndim"
  write(ilun,format)""
  write(ilun,format)"  ! Initial star particle mass"
  write(ilun,format)"  mstar=n_star/(scale_nH*aexp**3)*vol_min"
  write(ilun,format)""
  write(ilun,format)"  ! Lifetime of Giant Molecular Clouds from Myr to code units"
  write(ilun,format)"  t0=10.*(1d6*365.*24.*3600.)/scale_t"
  write(ilun,format)""
  write(ilun,format)"  !------------------------------------------------------"
  write(ilun,format)"  ! Gather GMC particles eligible for disruption"
  write(ilun,format)"  !------------------------------------------------------"
  write(ilun,format)"  nSN_loc=0"
  write(ilun,format)"  ! Loop over levels"
  write(ilun,format)"  do icpu=1,ncpu"
  write(ilun,format)"  ! Loop over cpus"
  write(ilun,format)"     igrid=headl(icpu,levelmin)"
  write(ilun,format)"     ! Loop over grids"
  write(ilun,format)"     do jgrid=1,numbl(icpu,levelmin)"
  write(ilun,format)"        npart1=numbp(igrid)  ! Number of particles in the grid"
  write(ilun,format)"        npart2=0"
  write(ilun,format)"        ! Count old enough GMC particles"
  write(ilun,format)"        if(npart1>0)then"
  write(ilun,format)"           ipart=headp(igrid)"
  write(ilun,format)"           ! Loop over particles"
  write(ilun,format)"           do jpart=1,npart1"
  write(ilun,format)"              ! Save next particle   <--- Very important !!!"
  write(ilun,format)"              next_part=nextp(ipart)"
  write(ilun,format)"              if(idp(ipart).le.0.and. tp(ipart).lt.(t-t0))then"
  write(ilun,format)"                 npart2=npart2+1"
  write(ilun,format)"              endif"
  write(ilun,format)"              ipart=next_part  ! Go to next particle"
  write(ilun,format)"            end do"
  write(ilun,format)"        endif"
  write(ilun,format)"        nSN_loc=nSN_loc+npart2   ! Add SNe to the total"
  write(ilun,format)"        igrid=next(igrid)   ! Go to next grid"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  ! End loop over levels"
  write(ilun,format)"  nSN_icpu=0"
  write(ilun,format)"  nSN_icpu(myid)=nSN_loc"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  ! Give an array of number of SN on each cpu available to all cpus"
  write(ilun,format)"  call MPI_ALLREDUCE(nSN_icpu,nSN_icpu_all,ncpu,MPI_INTEGER,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"  nSN_icpu=nSN_icpu_all"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  nSN_tot=sum(nSN_icpu(1:ncpu))"
  write(ilun,format)""
  write(ilun,format)"  if (nSN_tot .eq. 0) return"
  write(ilun,format)"  "
  write(ilun,format)"  if(myid==1)then"
  write(ilun,format)"     write(*,*)'-----------------------------------------------'"
  write(ilun,format)"     write(*,*)'Number of GMC to explode=',nSN_tot"
  write(ilun,format)"     write(*,*)'-----------------------------------------------'"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  ! Allocate arrays for the position and the mass of the SN"
  write(ilun,format)"  allocate(xSN(1:nSN_tot,1:3),vSN(1:nSN_tot,1:3))"
  write(ilun,format)"  allocate(mSN(1:nSN_tot),sSN(1:nSN_tot),ZSN(1:nSN_tot))"
  write(ilun,format)"  xSN=0.;vSN=0.;mSN=0.;sSN=0.;ZSN=0."
  write(ilun,format)"  ! Allocate arrays for particles index and parent grid"
  write(ilun,format)"  if(nSN_loc>0)then"
  write(ilun,format)"     allocate(ind_part(1:nSN_loc),ind_grid(1:nSN_loc),ok_free(1:nSN_loc))"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  !------------------------------------------------------"
  write(ilun,format)"  ! Store position and mass of the GMC into the SN array"
  write(ilun,format)"  !------------------------------------------------------"
  write(ilun,format)"  if(myid==1)then"
  write(ilun,format)"     iSN=0"
  write(ilun,format)"  else"
  write(ilun,format)"     iSN=sum(nSN_icpu(1:myid-1))"
  write(ilun,format)"  endif"
  write(ilun,format)"  ! Loop over levels"
  write(ilun,format)"  ip=0"
  write(ilun,format)"  do icpu=1,ncpu"
  write(ilun,format)"     igrid=headl(icpu,levelmin)"
  write(ilun,format)"     ! Loop over grids"
  write(ilun,format)"     do jgrid=1,numbl(icpu,levelmin)"
  write(ilun,format)"        npart1=numbp(igrid)  ! Number of particles in the grid"
  write(ilun,format)"        ! Count old enough star particles that have not exploded"
  write(ilun,format)"        if(npart1>0)then"
  write(ilun,format)"           ipart=headp(igrid)"
  write(ilun,format)"           ! Loop over particles"
  write(ilun,format)"           do jpart=1,npart1"
  write(ilun,format)"              ! Save next particle   <--- Very important !!!"
  write(ilun,format)"              next_part=nextp(ipart)"
  write(ilun,format)"              if(idp(ipart).le.0.and. tp(ipart).lt.(t-t0))then"
  write(ilun,format)"                 iSN=iSN+1"
  write(ilun,format)"                 xSN(iSN,1)=xp(ipart,1)"
  write(ilun,format)"                 xSN(iSN,2)=xp(ipart,2)"
  write(ilun,format)"                 xSN(iSN,3)=xp(ipart,3)"
  write(ilun,format)"                 vSN(iSN,1)=vp(ipart,1)"
  write(ilun,format)"                 vSN(iSN,2)=vp(ipart,2)"
  write(ilun,format)"                 vSN(iSN,3)=vp(ipart,3)"
  write(ilun,format)"                 mSN(iSN)=mp(ipart)"
  write(ilun,format)"                 sSN(iSN)=dble(-idp(ipart))*mstar"
  write(ilun,format)"                 if(metal)ZSN(iSN)=zp(ipart)"
  write(ilun,format)"                 ip=ip+1"
  write(ilun,format)"                 ind_grid(ip)=igrid"
  write(ilun,format)"                 ind_part(ip)=ipart"
  write(ilun,format)"              endif"
  write(ilun,format)"              ipart=next_part  ! Go to next particle"
  write(ilun,format)"           end do"
  write(ilun,format)"        endif"
  write(ilun,format)"        igrid=next(igrid)   ! Go to next grid"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do "
  write(ilun,format)"  ! End loop over levels"
  write(ilun,format)""
  write(ilun,format)"  ! Remove GMC particle"
  write(ilun,format)"  IF(nSN_loc>0)then"
  write(ilun,format)"     ok_free=.true."
  write(ilun,format)"     call remove_list(ind_part,ind_grid,ok_free,nSN_loc)"
  write(ilun,format)"     call add_free_cond(ind_part,ok_free,nSN_loc)"
  write(ilun,format)"     deallocate(ind_part,ind_grid,ok_free)"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  allocate(xSN_all(1:nSN_tot,1:3),vSN_all(1:nSN_tot,1:3),mSN_all(1:nSN_tot),sSN_all(1:nSN_tot),ZSN_all(1:nSN_tot))"
  write(ilun,format)"  call MPI_ALLREDUCE(xSN,xSN_all,nSN_tot*3,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"  call MPI_ALLREDUCE(vSN,vSN_all,nSN_tot*3,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"  call MPI_ALLREDUCE(mSN,mSN_all,nSN_tot  ,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"  call MPI_ALLREDUCE(sSN,sSN_all,nSN_tot  ,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"  call MPI_ALLREDUCE(ZSN,ZSN_all,nSN_tot  ,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"  xSN=xSN_all"
  write(ilun,format)"  vSN=vSN_all"
  write(ilun,format)"  mSN=mSN_all"
  write(ilun,format)"  sSN=sSN_all"
  write(ilun,format)"  ZSN=ZSN_all"
  write(ilun,format)"  deallocate(xSN_all,vSN_all,mSN_all,sSN_all,ZSN_all)"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  nSN=nSN_tot"
  write(ilun,format)"  allocate(m_gas(1:nSN),u_gas(1:nSN,1:3),vol_gas(1:nSN),dq(1:nSN,1:3),ekBlast(1:nSN))"
  write(ilun,format)"  allocate(indSN(1:nSN))"
  write(ilun,format)""
  write(ilun,format)"  ! Compute the grid discretization effects"
  write(ilun,format)"  call average_SN(xSN,vol_gas,dq,ekBlast,indSN,nSN)"
  write(ilun,format)""
  write(ilun,format)"  ! Modify hydro quantities to account for a Sedov blast wave"
  write(ilun,format)"  call Sedov_blast(xSN,vSN,mSN,sSN,ZSN,indSN,vol_gas,dq,ekBlast,nSN)"
  write(ilun,format)""
  write(ilun,format)"  deallocate(xSN,vSN,mSN,sSN,ZSN,indSN,m_gas,u_gas,vol_gas,dq,ekBlast)"
  write(ilun,format)""
  write(ilun,format)"  ! Update hydro quantities for split cells"
  write(ilun,format)"  do ilevel=nlevelmax,levelmin,-1"
  write(ilun,format)"     call upload_fine(ilevel)"
  write(ilun,format)"     do ivar=1,nvar"
  write(ilun,format)"        call make_virtual_fine_dp(uold(1,ivar),ilevel)"
  write(ilun,format)"     enddo"
  write(ilun,format)"  enddo"
  write(ilun,format)""
  write(ilun,format)"end subroutine kinetic_feedback"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine average_SN(xSN,vol_gas,dq,ekBlast,ind_blast,nSN)"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)"  ! This routine average the hydro quantities inside the SN bubble"
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)"  integer::ilevel,ncache,nSN,j,iSN,ind,ix,iy,iz,ngrid,iskip"
  write(ilun,format)"  integer::i,nx_loc,igrid,info"
  write(ilun,format)"  integer,dimension(1:nvector),save::ind_grid,ind_cell"
  write(ilun,format)"  real(dp)::x,y,z,dr_SN,d,u,v,w,ek,u2,v2,w2,dr_cell"
  write(ilun,format)"  real(dp)::scale,dx,dxx,dyy,dzz,dx_min,dx_loc,vol_loc,rmax2,rmax"
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v"
  write(ilun,format)"  real(dp),dimension(1:3)::skip_loc"
  write(ilun,format)"  real(dp),dimension(1:twotondim,1:3)::xc"
  write(ilun,format)"  integer ,dimension(1:nSN)::ind_blast"
  write(ilun,format)"  real(dp),dimension(1:nSN)::mSN,m_gas,vol_gas,ekBlast"
  write(ilun,format)"  real(dp),dimension(1:nSN,1:3)::xSN,vSN,u_gas,dq,u2Blast"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  real(dp),dimension(1:nSN)::m_gas_all,vol_gas_all,ekBlast_all"
  write(ilun,format)"  real(dp),dimension(1:nSN,1:3)::u_gas_all,dq_all,u2Blast_all"
  write(ilun,format)"#endif"
  write(ilun,format)"  logical ,dimension(1:nvector),save::ok"
  write(ilun,format)""
  write(ilun,format)"  if(nSN==0)return"
  write(ilun,format)"  if(verbose)write(*,*)'Entering average_SN'"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh spacing in that level"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  skip_loc=(/0.0d0,0.0d0,0.0d0/)"
  write(ilun,format)"  skip_loc(1)=dble(icoarse_min)"
  write(ilun,format)"  skip_loc(2)=dble(jcoarse_min)"
  write(ilun,format)"  skip_loc(3)=dble(kcoarse_min)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_min=scale*0.5D0**nlevelmax"
  write(ilun,format)""
  write(ilun,format)"  ! Conversion factor from user units to cgs units"
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)""
  write(ilun,format)"  ! Maximum radius of the ejecta"
  write(ilun,format)"  rmax=MAX(2.0d0*dx_min*scale_l/aexp,rbubble*3.08d18)"
  write(ilun,format)"  rmax=rmax/scale_l"
  write(ilun,format)"  rmax2=rmax*rmax"
  write(ilun,format)""
  write(ilun,format)"  ! Initialize the averaged variables"
  write(ilun,format)"  vol_gas=0.0;dq=0.0;u2Blast=0.0;ekBlast=0.0;ind_blast=-1"
  write(ilun,format)""
  write(ilun,format)"  ! Loop over levels"
  write(ilun,format)"  do ilevel=levelmin,nlevelmax"
  write(ilun,format)"     ! Computing local volume (important for averaging hydro quantities) "
  write(ilun,format)"     dx=0.5D0**ilevel "
  write(ilun,format)"     dx_loc=dx*scale"
  write(ilun,format)"     vol_loc=dx_loc**ndim"
  write(ilun,format)"     ! Cells center position relative to grid center position"
  write(ilun,format)"     do ind=1,twotondim  "
  write(ilun,format)"        iz=(ind-1)/4"
  write(ilun,format)"        iy=(ind-1-4*iz)/2"
  write(ilun,format)"        ix=(ind-1-2*iy-4*iz)"
  write(ilun,format)"        xc(ind,1)=(dble(ix)-0.5D0)*dx"
  write(ilun,format)"        xc(ind,2)=(dble(iy)-0.5D0)*dx"
  write(ilun,format)"        xc(ind,3)=(dble(iz)-0.5D0)*dx"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     ! Loop over grids"
  write(ilun,format)"     ncache=active(ilevel)%ngrid"
  write(ilun,format)"     do igrid=1,ncache,nvector"
  write(ilun,format)"        ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_grid(i)=active(ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"        end do"
  write(ilun,format)""
  write(ilun,format)"        ! Loop over cells"
  write(ilun,format)"        do ind=1,twotondim  "
  write(ilun,format)"           iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"           ! Flag leaf cells"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              ok(i)=son(ind_cell(i))==0"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              if(ok(i))then"
  write(ilun,format)"                 ! Get gas cell position"
  write(ilun,format)"                 x=(xg(ind_grid(i),1)+xc(ind,1)-skip_loc(1))*scale"
  write(ilun,format)"                 y=(xg(ind_grid(i),2)+xc(ind,2)-skip_loc(2))*scale"
  write(ilun,format)"                 z=(xg(ind_grid(i),3)+xc(ind,3)-skip_loc(3))*scale"
  write(ilun,format)"                 do iSN=1,nSN"
  write(ilun,format)"                    ! Check if the cell lies within the SN radius"
  write(ilun,format)"                    dxx=x-xSN(iSN,1)"
  write(ilun,format)"                    dyy=y-xSN(iSN,2)"
  write(ilun,format)"                    dzz=z-xSN(iSN,3)"
  write(ilun,format)"                    dr_SN=dxx**2+dyy**2+dzz**2"
  write(ilun,format)"                    dr_cell=MAX(ABS(dxx),ABS(dyy),ABS(dzz))"
  write(ilun,format)"                    if(dr_SN.lt.rmax2)then"
  write(ilun,format)"                       vol_gas(iSN)=vol_gas(iSN)+vol_loc"
  write(ilun,format)"                       ! Take account for grid effects on the conservation of the"
  write(ilun,format)"                       ! normalized linear momentum"
  write(ilun,format)"                       u=dxx/rmax"
  write(ilun,format)"                       v=dyy/rmax"
  write(ilun,format)"                       w=dzz/rmax"
  write(ilun,format)"                       ! Add the local normalized linear momentum to the total linear"
  write(ilun,format)"                       ! momentum of the blast wave (should be zero with no grid effect)"
  write(ilun,format)"                       dq(iSN,1)=dq(iSN,1)+u*vol_loc"
  write(ilun,format)"                       dq(iSN,2)=dq(iSN,2)+v*vol_loc"
  write(ilun,format)"                       dq(iSN,3)=dq(iSN,3)+w*vol_loc"
  write(ilun,format)"                       u2Blast(iSN,1)=u2Blast(iSN,1)+u*u*vol_loc"
  write(ilun,format)"                       u2Blast(iSN,2)=u2Blast(iSN,2)+v*v*vol_loc"
  write(ilun,format)"                       u2Blast(iSN,3)=u2Blast(iSN,3)+w*w*vol_loc"
  write(ilun,format)"                    endif"
  write(ilun,format)"                    if(dr_cell.le.dx_loc/2.0)then"
  write(ilun,format)"                       ind_blast(iSN)=ind_cell(i)"
  write(ilun,format)"                       ekBlast  (iSN)=vol_loc"
  write(ilun,format)"                    endif"
  write(ilun,format)"                 end do"
  write(ilun,format)"              endif"
  write(ilun,format)"           end do"
  write(ilun,format)"           "
  write(ilun,format)"        end do"
  write(ilun,format)"        ! End loop over cells"
  write(ilun,format)"     end do"
  write(ilun,format)"     ! End loop over grids"
  write(ilun,format)"  end do"
  write(ilun,format)"  ! End loop over levels"
  write(ilun,format)""
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  call MPI_ALLREDUCE(vol_gas,vol_gas_all,nSN  ,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"  call MPI_ALLREDUCE(dq     ,dq_all     ,nSN*3,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"  call MPI_ALLREDUCE(u2Blast,u2Blast_all,nSN*3,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"  call MPI_ALLREDUCE(ekBlast,ekBlast_all,nSN  ,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"  vol_gas=vol_gas_all"
  write(ilun,format)"  dq     =dq_all"
  write(ilun,format)"  u2Blast=u2Blast_all"
  write(ilun,format)"  ekBlast=ekBlast_all"
  write(ilun,format)"#endif"
  write(ilun,format)"  do iSN=1,nSN"
  write(ilun,format)"     if(vol_gas(iSN)>0d0)then"
  write(ilun,format)"        dq(iSN,1)=dq(iSN,1)/vol_gas(iSN)"
  write(ilun,format)"        dq(iSN,2)=dq(iSN,2)/vol_gas(iSN)"
  write(ilun,format)"        dq(iSN,3)=dq(iSN,3)/vol_gas(iSN)"
  write(ilun,format)"        u2Blast(iSN,1)=u2Blast(iSN,1)/vol_gas(iSN)"
  write(ilun,format)"        u2Blast(iSN,2)=u2Blast(iSN,2)/vol_gas(iSN)"
  write(ilun,format)"        u2Blast(iSN,3)=u2Blast(iSN,3)/vol_gas(iSN)"
  write(ilun,format)"        u2=u2Blast(iSN,1)-dq(iSN,1)**2"
  write(ilun,format)"        v2=u2Blast(iSN,2)-dq(iSN,2)**2"
  write(ilun,format)"        w2=u2Blast(iSN,3)-dq(iSN,3)**2"
  write(ilun,format)"        ekBlast(iSN)=max(0.5d0*(u2+v2+w2),0.0d0)"
  write(ilun,format)"     endif"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  if(verbose)write(*,*)'Exiting average_SN'"
  write(ilun,format)""
  write(ilun,format)"end subroutine average_SN"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine Sedov_blast(xSN,vSN,mSN,sSN,ZSN,indSN,vol_gas,dq,ekBlast,nSN)"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)"  ! This routine merges SN using the FOF algorithm."
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)"  integer::ilevel,j,iSN,nSN,ind,ix,iy,iz,ngrid,iskip"
  write(ilun,format)"  integer::i,nx_loc,igrid,info,ncache"
  write(ilun,format)"  integer,dimension(1:nvector),save::ind_grid,ind_cell"
  write(ilun,format)"  real(dp)::x,y,z,dx,dxx,dyy,dzz,dr_SN,d,u,v,w,ek,u_r,ESN"
  write(ilun,format)"  real(dp)::scale,dx_min,dx_loc,vol_loc,rmax2,rmax"
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v"
  write(ilun,format)"  real(dp),dimension(1:3)::skip_loc"
  write(ilun,format)"  real(dp),dimension(1:twotondim,1:3)::xc"
  write(ilun,format)"  real(dp),dimension(1:nSN)::mSN,sSN,ZSN,m_gas,p_gas,d_gas,d_metal,vol_gas,uSedov,ekBlast"
  write(ilun,format)"  real(dp),dimension(1:nSN,1:3)::xSN,vSN,u_gas,dq"
  write(ilun,format)"  integer ,dimension(1:nSN)::indSN"
  write(ilun,format)"  logical ,dimension(1:nvector),save::ok"
  write(ilun,format)""
  write(ilun,format)"  if(nSN==0)return"
  write(ilun,format)"  if(verbose)write(*,*)'Entering Sedov_blast'"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh spacing in that level"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  skip_loc=(/0.0d0,0.0d0,0.0d0/)"
  write(ilun,format)"  skip_loc(1)=dble(icoarse_min)"
  write(ilun,format)"  skip_loc(2)=dble(jcoarse_min)"
  write(ilun,format)"  skip_loc(3)=dble(kcoarse_min)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_min=scale*0.5D0**nlevelmax"
  write(ilun,format)""
  write(ilun,format)"  ! Conversion factor from user units to cgs units"
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)""
  write(ilun,format)"  ! Maximum radius of the ejecta"
  write(ilun,format)"  rmax=MAX(2.0d0*dx_min*scale_l/aexp,rbubble*3.08d18)"
  write(ilun,format)"  rmax=rmax/scale_l"
  write(ilun,format)"  rmax2=rmax*rmax"
  write(ilun,format)"  "
  write(ilun,format)"  ! Supernova specific energy from cgs to code units"
  write(ilun,format)"  ESN=(1d51/(10d0*2d33))/scale_v**2"
  write(ilun,format)""
  write(ilun,format)"  do iSN=1,nSN"
  write(ilun,format)"     if(vol_gas(iSN)>0d0)then"
  write(ilun,format)"        d_gas(iSN)=mSN(iSN)/vol_gas(iSN)"
  write(ilun,format)"        if(metal)d_metal(iSN)=ZSN(iSN)*mSN(iSN)/vol_gas(iSN)"
  write(ilun,format)"        if(ekBlast(iSN)==0d0)then"
  write(ilun,format)"           p_gas(iSN)=eta_sn*sSN(iSN)*ESN/vol_gas(iSN)"
  write(ilun,format)"           uSedov(iSN)=0d0"
  write(ilun,format)"        else"
  write(ilun,format)"           p_gas(iSN)=(1d0-f_ek)*eta_sn*sSN(iSN)*ESN/vol_gas(iSN)"
  write(ilun,format)"           uSedov(iSN)=sqrt(f_ek*eta_sn*sSN(iSN)*ESN/mSN(iSN)/ekBlast(iSN))"
  write(ilun,format)"        endif"
  write(ilun,format)"     else"
  write(ilun,format)"        d_gas(iSN)=mSN(iSN)/ekBlast(iSN)"
  write(ilun,format)"        p_gas(iSN)=eta_sn*sSN(iSN)*ESN/ekBlast(iSN)"
  write(ilun,format)"        if(metal)d_metal(iSN)=ZSN(iSN)*mSN(iSN)/ekBlast(iSN)"
  write(ilun,format)"     endif"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Loop over levels"
  write(ilun,format)"  do ilevel=levelmin,nlevelmax"
  write(ilun,format)"     ! Computing local volume (important for averaging hydro quantities) "
  write(ilun,format)"     dx=0.5D0**ilevel "
  write(ilun,format)"     dx_loc=dx*scale"
  write(ilun,format)"     vol_loc=dx_loc**ndim"
  write(ilun,format)"     ! Cells center position relative to grid center position"
  write(ilun,format)"     do ind=1,twotondim  "
  write(ilun,format)"        iz=(ind-1)/4"
  write(ilun,format)"        iy=(ind-1-4*iz)/2"
  write(ilun,format)"        ix=(ind-1-2*iy-4*iz)"
  write(ilun,format)"        xc(ind,1)=(dble(ix)-0.5D0)*dx"
  write(ilun,format)"        xc(ind,2)=(dble(iy)-0.5D0)*dx"
  write(ilun,format)"        xc(ind,3)=(dble(iz)-0.5D0)*dx"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     ! Loop over grids"
  write(ilun,format)"     ncache=active(ilevel)%ngrid"
  write(ilun,format)"     do igrid=1,ncache,nvector"
  write(ilun,format)"        ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_grid(i)=active(ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"        end do"
  write(ilun,format)""
  write(ilun,format)"        ! Loop over cells"
  write(ilun,format)"        do ind=1,twotondim  "
  write(ilun,format)"           iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"           ! Flag leaf cells"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              ok(i)=son(ind_cell(i))==0"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              if(ok(i))then"
  write(ilun,format)"                 ! Get gas cell position"
  write(ilun,format)"                 x=(xg(ind_grid(i),1)+xc(ind,1)-skip_loc(1))*scale"
  write(ilun,format)"                 y=(xg(ind_grid(i),2)+xc(ind,2)-skip_loc(2))*scale"
  write(ilun,format)"                 z=(xg(ind_grid(i),3)+xc(ind,3)-skip_loc(3))*scale"
  write(ilun,format)"                 do iSN=1,nSN"
  write(ilun,format)"                    ! Check if the cell lies within the SN radius"
  write(ilun,format)"                    dxx=x-xSN(iSN,1)"
  write(ilun,format)"                    dyy=y-xSN(iSN,2)"
  write(ilun,format)"                    dzz=z-xSN(iSN,3)"
  write(ilun,format)"                    dr_SN=dxx**2+dyy**2+dzz**2"
  write(ilun,format)"                    if(dr_SN.lt.rmax2)then"
  write(ilun,format)"                       ! Compute the mass density in the cell"
  write(ilun,format)"                       uold(ind_cell(i),1)=uold(ind_cell(i),1)+d_gas(iSN)"
  write(ilun,format)"                       ! Compute the metal density in the cell"
  write(ilun,format)"                       if(metal)uold(ind_cell(i),imetal)=uold(ind_cell(i),imetal)+d_metal(iSN)"
  write(ilun,format)"                       ! Velocity at a given dr_SN linearly interpolated between zero and uSedov"
  write(ilun,format)"                       u=uSedov(iSN)*(dxx/rmax-dq(iSN,1))+vSN(iSN,1)"
  write(ilun,format)"                       v=uSedov(iSN)*(dyy/rmax-dq(iSN,2))+vSN(iSN,2)"
  write(ilun,format)"                       w=uSedov(iSN)*(dzz/rmax-dq(iSN,3))+vSN(iSN,3)"
  write(ilun,format)"                       ! Add each momentum component of the blast wave to the gas"
  write(ilun,format)"                       uold(ind_cell(i),2)=uold(ind_cell(i),2)+d_gas(iSN)*u"
  write(ilun,format)"                       uold(ind_cell(i),3)=uold(ind_cell(i),3)+d_gas(iSN)*v"
  write(ilun,format)"                       uold(ind_cell(i),4)=uold(ind_cell(i),4)+d_gas(iSN)*w"
  write(ilun,format)"                       ! Finally update the total energy of the gas"
  write(ilun,format)"                       uold(ind_cell(i),5)=uold(ind_cell(i),5)+0.5*d_gas(iSN)*(u*u+v*v+w*w)+p_gas(iSN)"
  write(ilun,format)"                    endif"
  write(ilun,format)"                 end do"
  write(ilun,format)"              endif"
  write(ilun,format)"           end do"
  write(ilun,format)"           "
  write(ilun,format)"        end do"
  write(ilun,format)"        ! End loop over cells"
  write(ilun,format)"     end do"
  write(ilun,format)"     ! End loop over grids"
  write(ilun,format)"  end do"
  write(ilun,format)"  ! End loop over levels"
  write(ilun,format)""
  write(ilun,format)"  do iSN=1,nSN"
  write(ilun,format)"     if(vol_gas(iSN)==0d0)then"
  write(ilun,format)"        u=vSN(iSN,1)"
  write(ilun,format)"        v=vSN(iSN,2)"
  write(ilun,format)"        w=vSN(iSN,3)"
  write(ilun,format)"        if(indSN(iSN)>0)then"
  write(ilun,format)"           uold(indSN(iSN),1)=uold(indSN(iSN),1)+d_gas(iSN)"
  write(ilun,format)"           uold(indSN(iSN),2)=uold(indSN(iSN),2)+d_gas(iSN)*u"
  write(ilun,format)"           uold(indSN(iSN),3)=uold(indSN(iSN),3)+d_gas(iSN)*v"
  write(ilun,format)"           uold(indSN(iSN),4)=uold(indSN(iSN),4)+d_gas(iSN)*w"
  write(ilun,format)"           uold(indSN(iSN),5)=uold(indSN(iSN),5)+d_gas(iSN)*0.5*(u*u+v*v+w*w)+p_gas(iSN)"
  write(ilun,format)"           if(metal)uold(indSN(iSN),imetal)=uold(indSN(iSN),imetal)+d_metal(iSN)"
  write(ilun,format)"        endif"
  write(ilun,format)"     endif"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  if(verbose)write(*,*)'Exiting Sedov_blast'"
  write(ilun,format)""
  write(ilun,format)"end subroutine Sedov_blast"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"../patch/hydro/stratified_medium_fx_NSM/force_fine.f90"
  write(ilun,format)"!#########################################################"
  write(ilun,format)"!#########################################################"
  write(ilun,format)"!#########################################################"
  write(ilun,format)"!#########################################################"
  write(ilun,format)"subroutine force_fine(ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use poisson_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)"  !----------------------------------------------------------"
  write(ilun,format)"  ! This routine computes the gravitational acceleration,"
  write(ilun,format)"  ! the maximum density rho_max, and the potential energy"
  write(ilun,format)"  !----------------------------------------------------------"
  write(ilun,format)"  integer::igrid,ngrid,ncache,i,ind,iskip,ix,iy,iz"
  write(ilun,format)"  integer::info,ibound,nx_loc,idim"
  write(ilun,format)"  real(dp)::dx,dx_loc,scale,fact,fourpi"
  write(ilun,format)"  real(kind=8)::rho_loc,rho_all,epot_loc,epot_all"
  write(ilun,format)"  real(dp),dimension(1:twotondim,1:3)::xc"
  write(ilun,format)"  real(dp),dimension(1:3)::skip_loc"
  write(ilun,format)""
  write(ilun,format)"  integer ,dimension(1:nvector),save::ind_grid,ind_cell,ind_cell_father"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim),save::xx,ff"
  write(ilun,format)" "
  write(ilun,format)"  if(numbtot(1,ilevel)==0)return"
  write(ilun,format)"  if(verbose)write(*,111)ilevel"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh size at level ilevel in coarse cell units"
  write(ilun,format)"  dx=0.5D0**ilevel"
  write(ilun,format)"  "
  write(ilun,format)"  ! Rescaling factors"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  skip_loc=(/0.0d0,0.0d0,0.0d0/)"
  write(ilun,format)"  if(ndim>0)skip_loc(1)=dble(icoarse_min)"
  write(ilun,format)"  if(ndim>1)skip_loc(2)=dble(jcoarse_min)"
  write(ilun,format)"  if(ndim>2)skip_loc(3)=dble(kcoarse_min)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)""
  write(ilun,format)"  ! Set position of cell centers relative to grid center"
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     iz=(ind-1)/4"
  write(ilun,format)"     iy=(ind-1-4*iz)/2"
  write(ilun,format)"     ix=(ind-1-2*iy-4*iz)"
  write(ilun,format)"     if(ndim>0)xc(ind,1)=(dble(ix)-0.5D0)*dx"
  write(ilun,format)"     if(ndim>1)xc(ind,2)=(dble(iy)-0.5D0)*dx"
  write(ilun,format)"     if(ndim>2)xc(ind,3)=(dble(iz)-0.5D0)*dx"
  write(ilun,format)"  end do"
  write(ilun,format)"  "
  write(ilun,format)"  !-------------------------------------"
  write(ilun,format)"  ! Compute analytical gravity force"
  write(ilun,format)"  !-------------------------------------"
  write(ilun,format)"  if(gravity_type>0)then "
  write(ilun,format)""
  write(ilun,format)"     ! Loop over myid grids by vector sweeps"
  write(ilun,format)"     ncache=active(ilevel)%ngrid"
  write(ilun,format)"     do igrid=1,ncache,nvector"
  write(ilun,format)"        ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_grid(i)=active(ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"        end do"
  write(ilun,format)"     "
  write(ilun,format)"        ! Loop over cells"
  write(ilun,format)"        do ind=1,twotondim"
  write(ilun,format)""
  write(ilun,format)"           ! Gather cell indices"
  write(ilun,format)"           iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! Gather cell centre positions"
  write(ilun,format)"           do idim=1,ndim"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 xx(i,idim)=xg(ind_grid(i),idim)+xc(ind,idim)"
  write(ilun,format)"              end do"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! Rescale position from code units to user units"
  write(ilun,format)"           do idim=1,ndim"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 xx(i,idim)=(xx(i,idim)-skip_loc(idim))*scale"
  write(ilun,format)"              end do"
  write(ilun,format)"           end do"
  write(ilun,format)"           "
  write(ilun,format)"           ! Call analytical gravity routine"
  write(ilun,format)"           call gravana(xx,ff,dx_loc,ngrid)"
  write(ilun,format)"           "
  write(ilun,format)"           ! Scatter variables"
  write(ilun,format)"           do idim=1,ndim"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 f(ind_cell(i),idim)=ff(i,idim)"
  write(ilun,format)"              end do"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"        end do"
  write(ilun,format)"        ! End loop over cells"
  write(ilun,format)""
  write(ilun,format)"     end do"
  write(ilun,format)"     ! End loop over grids"
  write(ilun,format)""
  write(ilun,format)"     ! Update boundaries"
  write(ilun,format)"     do idim=1,ndim"
  write(ilun,format)"        call make_virtual_fine_dp(f(1,idim),ilevel)"
  write(ilun,format)"     end do"
  write(ilun,format)"     if(simple_boundary)call make_boundary_force(ilevel)"
  write(ilun,format)""
  write(ilun,format)"  !------------------------------"
  write(ilun,format)"  ! Compute gradient of potential"
  write(ilun,format)"  !------------------------------"
  write(ilun,format)"  else"
  write(ilun,format)"     ! Update physical boundaries"
  write(ilun,format)"     call make_boundary_phi(ilevel)"
  write(ilun,format)""
  write(ilun,format)"     ! Loop over myid grids by vector sweeps"
  write(ilun,format)"     ncache=active(ilevel)%ngrid"
  write(ilun,format)"     do igrid=1,ncache,nvector"
  write(ilun,format)"        ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_grid(i)=active(ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"        end do"
  write(ilun,format)"        ! Compute gradient of potential"
  write(ilun,format)"        call gradient_phi(ind_grid,ngrid,ilevel)"
  write(ilun,format)"     end do"
  write(ilun,format)"     ! End loop over grids"
  write(ilun,format)""
  write(ilun,format)"     ! Update boundaries"
  write(ilun,format)"     do idim=1,ndim"
  write(ilun,format)"        call make_virtual_fine_dp(f(1,idim),ilevel)"
  write(ilun,format)"     end do"
  write(ilun,format)"     if(simple_boundary)call make_boundary_force(ilevel)"
  write(ilun,format)""
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  !----------------------------------------------"
  write(ilun,format)"  ! Compute gravity potential and maximum density"
  write(ilun,format)"  !----------------------------------------------"
  write(ilun,format)"  rho_loc =0.0; rho_all =0.0"
  write(ilun,format)"  epot_loc=0.0; epot_all=0.0"
  write(ilun,format)"  fourpi=4.0D0*ACOS(-1.0D0)"
  write(ilun,format)"  if(cosmo)fourpi=1.5D0*omega_m*aexp"
  write(ilun,format)"  fact=-dx_loc**ndim/fourpi/2.0D0"
  write(ilun,format)""
  write(ilun,format)"  ! Loop over myid grids by vector sweeps"
  write(ilun,format)"  ncache=active(ilevel)%ngrid"
  write(ilun,format)"  do igrid=1,ncache,nvector"
  write(ilun,format)"     ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"     do i=1,ngrid"
  write(ilun,format)"        ind_grid(i)=active(ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"     end do     "
  write(ilun,format)"     ! Loop over cells"
  write(ilun,format)"     do ind=1,twotondim"
  write(ilun,format)"        ! Gather cell indices"
  write(ilun,format)"        iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"        end do"
  write(ilun,format)"        ! Loop over dimensions"
  write(ilun,format)"        do idim=1,ndim"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              if(son(ind_cell(i))==0)then"
  write(ilun,format)"                 epot_loc=epot_loc+fact*f(ind_cell(i),idim)**2"
  write(ilun,format)"              end if"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"        ! End loop over dimensions"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           rho_loc=MAX(rho_loc,dble(abs(rho(ind_cell(i)))))"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     ! End loop over cells"
  write(ilun,format)"  end do"
  write(ilun,format)"  ! End loop over grids"
  write(ilun,format)""
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     call MPI_ALLREDUCE(epot_loc,epot_all,1,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"     call MPI_ALLREDUCE(rho_loc ,rho_all ,1,MPI_DOUBLE_PRECISION,MPI_MAX,MPI_COMM_WORLD,info)"
  write(ilun,format)"     epot_loc=epot_all"
  write(ilun,format)"     rho_loc =rho_all"
  write(ilun,format)"#endif"
  write(ilun,format)"     epot_tot=epot_tot+epot_loc"
  write(ilun,format)"     rho_max(ilevel)=rho_loc"
  write(ilun,format)"  "
  write(ilun,format)"111 format('   Entering force_fine for level ',I2)"
  write(ilun,format)""
  write(ilun,format)"end subroutine force_fine"
  write(ilun,format)"!#########################################################"
  write(ilun,format)"!#########################################################"
  write(ilun,format)"!#########################################################"
  write(ilun,format)"!#########################################################"
  write(ilun,format)"subroutine gradient_phi(ind_grid,ngrid,ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use poisson_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ngrid,ilevel"
  write(ilun,format)"  integer,dimension(1:nvector)::ind_grid"
  write(ilun,format)"  !-------------------------------------------------"
  write(ilun,format)"  ! This routine compute the 3-force for all cells"
  write(ilun,format)"  ! in grids ind_grid(:) at level ilevel, using a"
  write(ilun,format)"  ! 5 nodes kernel (5 points FDA)."
  write(ilun,format)"  !-------------------------------------------------"
  write(ilun,format)"  integer::i,idim,ind,iskip,nx_loc"
  write(ilun,format)"  integer::id1,id2,id3,id4"
  write(ilun,format)"  integer::ig1,ig2,ig3,ig4"
  write(ilun,format)"  integer::ih1,ih2,ih3,ih4"
  write(ilun,format)"  real(dp)::dx,a,b,scale,dx_loc"
  write(ilun,format)"  integer,dimension(1:3,1:4,1:8)::ggg,hhh"
  write(ilun,format)""
  write(ilun,format)"  integer ,dimension(1:nvector),save::ind_cell"
  write(ilun,format)"  integer ,dimension(1:nvector,1:ndim),save::ind_left,ind_right"
  write(ilun,format)"  integer ,dimension(1:nvector,0:twondim),save::igridn"
  write(ilun,format)"  real(dp),dimension(1:nvector),save::phi1,phi2,phi3,phi4"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:twotondim,1:ndim),save::phi_left,phi_right"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh size at level ilevel"
  write(ilun,format)"  dx=0.5D0**ilevel"
  write(ilun,format)""
  write(ilun,format)"  ! Rescaling factor"
  write(ilun,format)"  nx_loc=icoarse_max-icoarse_min+1"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)""
  write(ilun,format)"  a=0.50D0*4.0D0/3.0D0/dx"
  write(ilun,format)"  b=0.25D0*1.0D0/3.0D0/dx"
  write(ilun,format)"  !   |dim"
  write(ilun,format)"  !   | |node"
  write(ilun,format)"  !   | | |cell"
  write(ilun,format)"  !   v v v"
  write(ilun,format)"  ggg(1,1,1:8)=(/1,0,1,0,1,0,1,0/); hhh(1,1,1:8)=(/2,1,4,3,6,5,8,7/)"
  write(ilun,format)"  ggg(1,2,1:8)=(/0,2,0,2,0,2,0,2/); hhh(1,2,1:8)=(/2,1,4,3,6,5,8,7/)"
  write(ilun,format)"  ggg(1,3,1:8)=(/1,1,1,1,1,1,1,1/); hhh(1,3,1:8)=(/1,2,3,4,5,6,7,8/)"
  write(ilun,format)"  ggg(1,4,1:8)=(/2,2,2,2,2,2,2,2/); hhh(1,4,1:8)=(/1,2,3,4,5,6,7,8/)"
  write(ilun,format)"  ggg(2,1,1:8)=(/3,3,0,0,3,3,0,0/); hhh(2,1,1:8)=(/3,4,1,2,7,8,5,6/)"
  write(ilun,format)"  ggg(2,2,1:8)=(/0,0,4,4,0,0,4,4/); hhh(2,2,1:8)=(/3,4,1,2,7,8,5,6/)"
  write(ilun,format)"  ggg(2,3,1:8)=(/3,3,3,3,3,3,3,3/); hhh(2,3,1:8)=(/1,2,3,4,5,6,7,8/)"
  write(ilun,format)"  ggg(2,4,1:8)=(/4,4,4,4,4,4,4,4/); hhh(2,4,1:8)=(/1,2,3,4,5,6,7,8/)"
  write(ilun,format)"  ggg(3,1,1:8)=(/5,5,5,5,0,0,0,0/); hhh(3,1,1:8)=(/5,6,7,8,1,2,3,4/)"
  write(ilun,format)"  ggg(3,2,1:8)=(/0,0,0,0,6,6,6,6/); hhh(3,2,1:8)=(/5,6,7,8,1,2,3,4/)"
  write(ilun,format)"  ggg(3,3,1:8)=(/5,5,5,5,5,5,5,5/); hhh(3,3,1:8)=(/1,2,3,4,5,6,7,8/)"
  write(ilun,format)"  ggg(3,4,1:8)=(/6,6,6,6,6,6,6,6/); hhh(3,4,1:8)=(/1,2,3,4,5,6,7,8/)"
  write(ilun,format)""
  write(ilun,format)"  ! Gather neighboring grids"
  write(ilun,format)"  do i=1,ngrid"
  write(ilun,format)"     igridn(i,0)=ind_grid(i)"
  write(ilun,format)"  end do"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do i=1,ngrid"
  write(ilun,format)"        ind_left (i,idim)=nbor(ind_grid(i),2*idim-1)"
  write(ilun,format)"        ind_right(i,idim)=nbor(ind_grid(i),2*idim  )"
  write(ilun,format)"        igridn(i,2*idim-1)=son(ind_left (i,idim))"
  write(ilun,format)"        igridn(i,2*idim  )=son(ind_right(i,idim))"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Interpolate potential from upper level"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     call interpol_phi(ind_left (1,idim),phi_left (1,1,idim),ngrid,ilevel)"
  write(ilun,format)"     call interpol_phi(ind_right(1,idim),phi_right(1,1,idim),ngrid,ilevel)"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Loop over cells"
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"     do i=1,ngrid"
  write(ilun,format)"        ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     ! Loop over dimensions"
  write(ilun,format)"     do idim=1,ndim"
  write(ilun,format)""
  write(ilun,format)"        ! Loop over nodes"
  write(ilun,format)"        id1=hhh(idim,1,ind); ig1=ggg(idim,1,ind); ih1=ncoarse+(id1-1)*ngridmax"
  write(ilun,format)"        id2=hhh(idim,2,ind); ig2=ggg(idim,2,ind); ih2=ncoarse+(id2-1)*ngridmax"
  write(ilun,format)"        id3=hhh(idim,3,ind); ig3=ggg(idim,3,ind); ih3=ncoarse+(id3-1)*ngridmax"
  write(ilun,format)"        id4=hhh(idim,4,ind); ig4=ggg(idim,4,ind); ih4=ncoarse+(id4-1)*ngridmax"
  write(ilun,format)"        "
  write(ilun,format)"        ! Gather potential"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           if(igridn(i,ig1)>0)then"
  write(ilun,format)"              phi1(i)=phi(igridn(i,ig1)+ih1)"
  write(ilun,format)"           else"
  write(ilun,format)"              phi1(i)=phi_left(i,id1,idim)"
  write(ilun,format)"           end if"
  write(ilun,format)"        end do"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           if(igridn(i,ig2)>0)then"
  write(ilun,format)"              phi2(i)=phi(igridn(i,ig2)+ih2)"
  write(ilun,format)"           else"
  write(ilun,format)"              phi2(i)=phi_right(i,id2,idim)"
  write(ilun,format)"           end if"
  write(ilun,format)"        end do"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           if(igridn(i,ig3)>0)then"
  write(ilun,format)"              phi3(i)=phi(igridn(i,ig3)+ih3)"
  write(ilun,format)"           else"
  write(ilun,format)"              phi3(i)=phi_left(i,id3,idim)"
  write(ilun,format)"           end if"
  write(ilun,format)"        end do"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           if(igridn(i,ig4)>0)then"
  write(ilun,format)"              phi4(i)=phi(igridn(i,ig4)+ih4)"
  write(ilun,format)"           else"
  write(ilun,format)"              phi4(i)=phi_right(i,id4,idim)"
  write(ilun,format)"           end if"
  write(ilun,format)"        end do"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           f(ind_cell(i),idim)=a*(phi1(i)-phi2(i)) &"
  write(ilun,format)"                &             -b*(phi3(i)-phi4(i))"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"end subroutine gradient_phi"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"../patch/hydro/stratified_medium_fx_NSM/gravana.f90"
  write(ilun,format)"!#########################################################"
  write(ilun,format)"!#########################################################"
  write(ilun,format)"!#########################################################"
  write(ilun,format)"!#########################################################"
  write(ilun,format)"subroutine gravana(x,f,dx,ncell)"
  write(ilun,format)"  use amr_parameters"
  write(ilun,format)"  use poisson_parameters  "
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer ::ncell                         ! Size of input arrays"
  write(ilun,format)"  real(dp)::dx                            ! Cell size"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim)::f ! Gravitational acceleration"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim)::x ! Cell center position."
  write(ilun,format)"  !================================================================"
  write(ilun,format)"  ! This routine computes the acceleration using analytical models."
  write(ilun,format)"  ! x(i,1:ndim) are cell center position in [0,boxlen] (user units)."
  write(ilun,format)"  ! f(i,1:ndim) is the gravitational acceleration in user units."
  write(ilun,format)"  !================================================================"
  write(ilun,format)"  integer::idim,i"
  write(ilun,format)"  real(dp)::gmass,emass,xmass,ymass,zmass,rr,rx,ry,rz"
  write(ilun,format)""
  write(ilun,format)"  character(LEN=160)::infile"
  write(ilun,format)"  real(dp)::a1,a2,z0,fac,T0,rho0,sigma0"
  write(ilun,format)"  real(dp)::scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2"
  write(ilun,format)"  real(dp)::smoothing,smoothing_l"
  write(ilun,format)"  real(dp)::grav,potential_true,potential_lim,potential"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! Conversion factor from user units to cgs units"
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)""
  write(ilun,format)"  ! Constant vector"
  write(ilun,format)"  if(gravity_type==1)then "
  write(ilun,format)"     do idim=1,ndim"
  write(ilun,format)"        do i=1,ncell"
  write(ilun,format)"           f(i,idim)=gravity_params(idim)"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  ! Kuijen & Gilmore 1989 disc"
  write(ilun,format)"  if(gravity_type==2)then "
  write(ilun,format)" "
  write(ilun,format)"     ! Parameters of the model - convert to cgs"
  write(ilun,format)"     a1=gravity_params(1) ! disc component factor"
  write(ilun,format)"     a2=gravity_params(2) ! halo component factor"
  write(ilun,format)"     z0=gravity_params(3) ! scale height of the disc"
  write(ilun,format)"     T0=gravity_params(4) ! temperature in the mid-plane"
  write(ilun,format)"     rho0=gravity_params(5) ! gas surface density"
  write(ilun,format)"     a1=a1*3.08d21/(1d6*365.*24.*3600.)**2 ! cm/s2"
  write(ilun,format)"     a2=a2/(1d6*365.*24.*3600.)**2 ! s-2"
  write(ilun,format)"     z0=z0*3.08d21 ! cm"
  write(ilun,format)"       "
  write(ilun,format)"     do i=1,ncell"
  write(ilun,format)"        rx=0.0d0; ry=0.0d0; rz=0.0d0"
  write(ilun,format)"        rx=x(i,1)-xwind"
  write(ilun,format)"#if NDIM>1"
  write(ilun,format)"        ry=x(i,2)-ywind"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM>2"
  write(ilun,format)"        rz=(x(i,3)-zwind)*scale_l"
  write(ilun,format)"#endif"
  write(ilun,format)"        f(i,1)=0.0d0"
  write(ilun,format)"#if NDIM>1"
  write(ilun,format)"        f(i,2)=0.0d0"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM>2"
  write(ilun,format)"        smoothing_l=0.25*boxlen/2*scale_l"
  write(ilun,format)"        smoothing=1.0d0"
  write(ilun,format)"        f(i,3)=smoothing*(-a1*rz/sqrt(rz**2+z0**2)-a2*rz)*scale_t**2/scale_l"
  write(ilun,format)"#endif"
  write(ilun,format)"     end do"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"end subroutine gravana"
  write(ilun,format)"!#########################################################"
  write(ilun,format)"!#########################################################"
  write(ilun,format)"!#########################################################"
  write(ilun,format)"!#########################################################"
  write(ilun,format)"subroutine phi_ana(rr,pp,ngrid)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use poisson_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ngrid"
  write(ilun,format)"  real(dp),dimension(1:nvector)::rr,pp"
  write(ilun,format)"  ! -------------------------------------------------------------------"
  write(ilun,format)"  ! This routine set up boundary conditions for fine levels."
  write(ilun,format)"  ! -------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  integer :: i"
  write(ilun,format)"  real(dp):: fourpi"
  write(ilun,format)""
  write(ilun,format)"  fourpi=4.D0*ACOS(-1.0D0)"
  write(ilun,format)""
  write(ilun,format)"#if NDIM==1"
  write(ilun,format)"  do i=1,ngrid"
  write(ilun,format)"     pp(i)=multipole(1)*fourpi/2d0*rr(i)"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM==2"
  write(ilun,format)"  do i=1,ngrid"
  write(ilun,format)"     pp(i)=multipole(1)*2d0*log(rr(i))"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)"  do i=1,ngrid"
  write(ilun,format)"     pp(i)=-multipole(1)/rr(i)"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"end subroutine phi_ana"
  write(ilun,format)"../patch/hydro/stratified_medium_fx_NSM/hydro_boundary.f90"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine make_boundary_hydro(ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use poisson_parameters"
  write(ilun,format)"  use poisson_commons, ONLY: f"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)"  ! -------------------------------------------------------------------"
  write(ilun,format)"  ! This routine set up boundary conditions for fine levels."
  write(ilun,format)"  ! -------------------------------------------------------------------"
  write(ilun,format)"  integer::ibound,boundary_dir,idim,inbor"
  write(ilun,format)"  integer::i,ncache,ivar,igrid,ngrid,ind"
  write(ilun,format)"  integer::iskip,iskip_ref,gdim,nx_loc,ix,iy,iz"
  write(ilun,format)"  integer,dimension(1:8)::ind_ref,alt"
  write(ilun,format)"  integer,dimension(1:nvector),save::ind_grid,ind_grid_ref"
  write(ilun,format)"  integer,dimension(1:nvector),save::ind_cell,ind_cell_ref"
  write(ilun,format)""
  write(ilun,format)"  real(dp)::switch,dx,dx_loc,scale"
  write(ilun,format)"  real(dp),dimension(1:3)::gs,skip_loc"
  write(ilun,format)"  real(dp),dimension(1:twotondim,1:3)::xc"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim),save::xx"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim),save::xx_ref"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:nvar),save::uu"
  write(ilun,format)""
  write(ilun,format)"  if(.not. simple_boundary)return"
  write(ilun,format)"  if(verbose)write(*,111)ilevel"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh size at level ilevel"
  write(ilun,format)"  dx=0.5D0**ilevel"
  write(ilun,format)""
  write(ilun,format)"  ! Rescaling factors"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  skip_loc=(/0.0d0,0.0d0,0.0d0/)"
  write(ilun,format)"  if(ndim>0)skip_loc(1)=dble(icoarse_min)"
  write(ilun,format)"  if(ndim>1)skip_loc(2)=dble(jcoarse_min)"
  write(ilun,format)"  if(ndim>2)skip_loc(3)=dble(kcoarse_min)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)""
  write(ilun,format)"  ! Set position of cell centers relative to grid center"
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     iz=(ind-1)/4"
  write(ilun,format)"     iy=(ind-1-4*iz)/2"
  write(ilun,format)"     ix=(ind-1-2*iy-4*iz)"
  write(ilun,format)"     if(ndim>0)xc(ind,1)=(dble(ix)-0.5D0)*dx"
  write(ilun,format)"     if(ndim>1)xc(ind,2)=(dble(iy)-0.5D0)*dx"
  write(ilun,format)"     if(ndim>2)xc(ind,3)=(dble(iz)-0.5D0)*dx"
  write(ilun,format)"  end do"
  write(ilun,format)"  "
  write(ilun,format)"  ! Loop over boundaries"
  write(ilun,format)"  do ibound=1,nboundary"
  write(ilun,format)""
  write(ilun,format)"     ! Compute direction of reference neighbors"
  write(ilun,format)"     boundary_dir=boundary_type(ibound)-10*(boundary_type(ibound)/10)"
  write(ilun,format)"     if(boundary_dir==1)inbor=2"
  write(ilun,format)"     if(boundary_dir==2)inbor=1"
  write(ilun,format)"     if(boundary_dir==3)inbor=4"
  write(ilun,format)"     if(boundary_dir==4)inbor=3"
  write(ilun,format)"     if(boundary_dir==5)inbor=6"
  write(ilun,format)"     if(boundary_dir==6)inbor=5"
  write(ilun,format)""
  write(ilun,format)"     ! Compute index of reference cells"
  write(ilun,format)"     ! Reflexive boundary"
  write(ilun,format)"     if(boundary_type(ibound)== 1)ind_ref(1:8)=(/2,1,4,3,6,5,8,7/)"
  write(ilun,format)"     if(boundary_type(ibound)== 2)ind_ref(1:8)=(/2,1,4,3,6,5,8,7/)"
  write(ilun,format)"     if(boundary_type(ibound)== 3)ind_ref(1:8)=(/3,4,1,2,7,8,5,6/)"
  write(ilun,format)"     if(boundary_type(ibound)== 4)ind_ref(1:8)=(/3,4,1,2,7,8,5,6/)"
  write(ilun,format)"     if(boundary_type(ibound)== 5)ind_ref(1:8)=(/5,6,7,8,1,2,3,4/)"
  write(ilun,format)"     if(boundary_type(ibound)== 6)ind_ref(1:8)=(/5,6,7,8,1,2,3,4/)"
  write(ilun,format)"     ! Free boundary"
  write(ilun,format)"     if(boundary_type(ibound)==11)ind_ref(1:8)=(/1,1,3,3,5,5,7,7/)"
  write(ilun,format)"     if(boundary_type(ibound)==12)ind_ref(1:8)=(/2,2,4,4,6,6,8,8/)"
  write(ilun,format)"     if(boundary_type(ibound)==13)ind_ref(1:8)=(/1,2,1,2,5,6,5,6/)"
  write(ilun,format)"     if(boundary_type(ibound)==14)ind_ref(1:8)=(/3,4,3,4,7,8,7,8/)"
  write(ilun,format)"     if(boundary_type(ibound)==15)ind_ref(1:8)=(/1,2,3,4,1,2,3,4/)"
  write(ilun,format)"     if(boundary_type(ibound)==16)ind_ref(1:8)=(/5,6,7,8,5,6,7,8/)"
  write(ilun,format)"     ! Imposed boundary (used only for flag1)"
  write(ilun,format)"     if(boundary_type(ibound)==21)ind_ref(1:8)=(/1,1,3,3,5,5,7,7/)"
  write(ilun,format)"     if(boundary_type(ibound)==22)ind_ref(1:8)=(/2,2,4,4,6,6,8,8/)"
  write(ilun,format)"     if(boundary_type(ibound)==23)ind_ref(1:8)=(/1,2,1,2,5,6,5,6/)"
  write(ilun,format)"     if(boundary_type(ibound)==24)ind_ref(1:8)=(/3,4,3,4,7,8,7,8/)"
  write(ilun,format)"     if(boundary_type(ibound)==25)ind_ref(1:8)=(/1,2,3,4,1,2,3,4/)"
  write(ilun,format)"     if(boundary_type(ibound)==26)ind_ref(1:8)=(/5,6,7,8,5,6,7,8/)"
  write(ilun,format)""
  write(ilun,format)"     ! Velocity sign switch for reflexive boundary conditions"
  write(ilun,format)"     gs=(/1,1,1/)"
  write(ilun,format)"     if(boundary_type(ibound)==1.or.boundary_type(ibound)==2)gs(1)=-1"
  write(ilun,format)"     if(boundary_type(ibound)==3.or.boundary_type(ibound)==4)gs(2)=-1"
  write(ilun,format)"     if(boundary_type(ibound)==5.or.boundary_type(ibound)==6)gs(3)=-1"
  write(ilun,format)"     "
  write(ilun,format)"     ! Direction of gravity vector for hydrostatic equilibrium"
  write(ilun,format)"     if(boundary_dir==1.or.boundary_dir==2)gdim=1"
  write(ilun,format)"     if(boundary_dir==3.or.boundary_dir==4)gdim=2"
  write(ilun,format)"     if(boundary_dir==5.or.boundary_dir==6)gdim=3"
  write(ilun,format)""
  write(ilun,format)"     ! Altitude for hydrostatic equilibrium"
  write(ilun,format)"     ! Reflexive boundary"
  write(ilun,format)"     if(boundary_type(ibound)==1)alt(1:8)=-(/3,1,3,1,3,1,3,1/)"
  write(ilun,format)"     if(boundary_type(ibound)==2)alt(1:8)=+(/1,3,1,3,1,3,1,3/)"
  write(ilun,format)"     if(boundary_type(ibound)==3)alt(1:8)=-(/1,1,3,3,1,1,3,3/)"
  write(ilun,format)"     if(boundary_type(ibound)==4)alt(1:8)=+(/3,3,1,1,3,3,1,1/)"
  write(ilun,format)"     if(boundary_type(ibound)==5)alt(1:8)=-(/1,1,1,1,3,3,3,3/)"
  write(ilun,format)"     if(boundary_type(ibound)==6)alt(1:8)=+(/3,3,3,3,1,1,1,1/)"
  write(ilun,format)"     ! Free boundary"
  write(ilun,format)"     if(boundary_type(ibound)==11)alt(1:8)=-(/2,1,2,1,2,1,2,1/)"
  write(ilun,format)"     if(boundary_type(ibound)==12)alt(1:8)=+(/1,2,1,2,1,2,1,2/)"
  write(ilun,format)"     if(boundary_type(ibound)==13)alt(1:8)=-(/1,1,2,2,1,1,2,2/)"
  write(ilun,format)"     if(boundary_type(ibound)==14)alt(1:8)=+(/2,2,1,1,2,2,1,1/)"
  write(ilun,format)"     if(boundary_type(ibound)==15)alt(1:8)=-(/1,1,1,1,2,2,2,2/)"
  write(ilun,format)"     if(boundary_type(ibound)==16)alt(1:8)=+(/2,2,2,2,1,1,1,1/)"
  write(ilun,format)"     ! Custom boundary"
  write(ilun,format)"     if(boundary_type(ibound)==21)alt(1:8)=-(/2,1,2,1,2,1,2,1/)"
  write(ilun,format)"     if(boundary_type(ibound)==22)alt(1:8)=+(/1,2,1,2,1,2,1,2/)"
  write(ilun,format)"     if(boundary_type(ibound)==23)alt(1:8)=-(/1,1,2,2,1,1,2,2/)"
  write(ilun,format)"     if(boundary_type(ibound)==24)alt(1:8)=+(/2,2,1,1,2,2,1,1/)"
  write(ilun,format)"     if(boundary_type(ibound)==25)alt(1:8)=-(/1,1,1,1,2,2,2,2/)"
  write(ilun,format)"     if(boundary_type(ibound)==26)alt(1:8)=+(/2,2,2,2,1,1,1,1/)"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"     ! Loop over grids by vector sweeps"
  write(ilun,format)"     ncache=boundary(ibound,ilevel)%ngrid"
  write(ilun,format)"     do igrid=1,ncache,nvector"
  write(ilun,format)"        ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_grid(i)=boundary(ibound,ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"        end do"
  write(ilun,format)"        "
  write(ilun,format)"        ! Gather neighboring reference grid"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_grid_ref(i)=son(nbor(ind_grid(i),inbor))"
  write(ilun,format)"        end do"
  write(ilun,format)""
  write(ilun,format)"        ! Loop over cells"
  write(ilun,format)"        do ind=1,twotondim"
  write(ilun,format)"           iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"           end do"
  write(ilun,format)"              "
  write(ilun,format)"           ! Gather neighboring reference cell"
  write(ilun,format)"           iskip_ref=ncoarse+(ind_ref(ind)-1)*ngridmax"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              ind_cell_ref(i)=iskip_ref+ind_grid_ref(i)"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"           ! Wall and free boundary conditions"
  write(ilun,format)"           if((boundary_type(ibound)/10).ne.2)then"
  write(ilun,format)"              "
  write(ilun,format)"              ! Gather reference hydro variables"
  write(ilun,format)"              do ivar=1,nvar"
  write(ilun,format)"                 do i=1,ngrid"
  write(ilun,format)"                    uu(i,ivar)=uold(ind_cell_ref(i),ivar)"
  write(ilun,format)"                 end do"
  write(ilun,format)"              end do"
  write(ilun,format)"              ! Scatter to boundary region"
  write(ilun,format)"              do ivar=1,nvar"
  write(ilun,format)"                 switch=1"
  write(ilun,format)"                 if(ivar>1.and.ivar<ndim+2)switch=gs(ivar-1)"
  write(ilun,format)"                 do i=1,ngrid"
  write(ilun,format)"                    uold(ind_cell(i),ivar)=uu(i,ivar)*switch"
  write(ilun,format)"                 end do"
  write(ilun,format)"              end do"
  write(ilun,format)"              ! Enforce hydrostatic equilibrium"
  write(ilun,format)"              ! for constant gravity vector only"
  write(ilun,format)"              if(poisson.and.gravity_type==1)then"
  write(ilun,format)"                 ivar=ndim+2"
  write(ilun,format)"                 do i=1,ngrid"
  write(ilun,format)"                    uu(i,ivar)=uold(ind_cell_ref(i),ivar)"
  write(ilun,format)"                 end do"
  write(ilun,format)"                 do i=1,ngrid"
  write(ilun,format)"                    uold(ind_cell(i),ivar)=uu(i,ivar)+ &"
  write(ilun,format)"                         & uold(ind_cell_ref(i),1)*gravity_params(gdim)* &"
  write(ilun,format)"                         & dx_loc*alt(ind)/(gamma-1.0d0)"
  write(ilun,format)"                 end do"
  write(ilun,format)"              end if"
  write(ilun,format)"              "
  write(ilun,format)"              ! Imposed boundary conditions"
  write(ilun,format)"           else"
  write(ilun,format)"              "
  write(ilun,format)"              ! Compute cell center in code units"
  write(ilun,format)"              do idim=1,ndim"
  write(ilun,format)"                 do i=1,ngrid"
  write(ilun,format)"                    xx(i,idim)=xg(ind_grid(i),idim)+xc(ind,idim)"
  write(ilun,format)"                    xx_ref(i,idim)=xg(ind_grid_ref(i),idim)+xc(ind_ref(ind),idim)"
  write(ilun,format)"                 end do"
  write(ilun,format)"              end do"
  write(ilun,format)"              "
  write(ilun,format)"              ! Rescale position from code units to user units"
  write(ilun,format)"              do idim=1,ndim"
  write(ilun,format)"                 do i=1,ngrid"
  write(ilun,format)"                    xx(i,idim)=(xx(i,idim)-skip_loc(idim))*scale"
  write(ilun,format)"                    xx_ref(i,idim)=(xx_ref(i,idim)-skip_loc(idim))*scale"
  write(ilun,format)"                 end do"
  write(ilun,format)"              end do"
  write(ilun,format)"              "
  write(ilun,format)"              call boundana(xx,uu,ind_cell,xx_ref,ind_cell_ref,dx_loc,ibound,ngrid)"
  write(ilun,format)"              "
  write(ilun,format)"              ! Scatter variables"
  write(ilun,format)"              do ivar=1,nvar"
  write(ilun,format)"                 do i=1,ngrid"
  write(ilun,format)"                    uold(ind_cell(i),ivar)=uu(i,ivar)"
  write(ilun,format)"                 end do"
  write(ilun,format)"              end do"
  write(ilun,format)"              "
  write(ilun,format)"              ! Enforce hydrostatic equilibrium"
  write(ilun,format)"              !if(poisson.and.gravity_type==2)then"
  write(ilun,format)"              !   ivar=ndim+2"
  write(ilun,format)"              !   do i=1,ngrid"
  write(ilun,format)"              !      uu(i,ivar)=uold(ind_cell_ref(i),ivar)"
  write(ilun,format)"              !   end do"
  write(ilun,format)"              !   do i=1,ngrid"
  write(ilun,format)"              !      uold(ind_cell(i),ivar)=uu(i,ivar)+ &"
  write(ilun,format)"              !           & uold(ind_cell_ref(i),1)*f(ind_cell_ref(i),3)* &"
  write(ilun,format)"              !           & dx_loc*alt(ind)/(gamma-1.0d0)"
  write(ilun,format)"              !   end do"
  write(ilun,format)"              !end if"
  write(ilun,format)"   "
  write(ilun,format)"           end if"
  write(ilun,format)"              "
  write(ilun,format)"        end do"
  write(ilun,format)"        ! End loop over cells"
  write(ilun,format)""
  write(ilun,format)"     end do"
  write(ilun,format)"     ! End loop over grids"
  write(ilun,format)""
  write(ilun,format)"  end do"
  write(ilun,format)"  ! End loop over boundaries"
  write(ilun,format)""
  write(ilun,format)"111 format('   Entering make_boundary_hydro for level ',I2)"
  write(ilun,format)""
  write(ilun,format)"end subroutine make_boundary_hydro"
  write(ilun,format)"../patch/hydro/stratified_medium_fx_NSM/hydro_parameters.f90"
  write(ilun,format)"module hydro_parameters"
  write(ilun,format)"  use amr_parameters"
  write(ilun,format)""
  write(ilun,format)"  ! Number of independant variables"
  write(ilun,format)"#ifndef NENER"
  write(ilun,format)"  integer,parameter::nener=0"
  write(ilun,format)"#else"
  write(ilun,format)"  integer,parameter::nener=NENER"
  write(ilun,format)"#endif"
  write(ilun,format)"#ifndef NVAR"
  write(ilun,format)"  integer,parameter::nvar=ndim+2+nener"
  write(ilun,format)"#else"
  write(ilun,format)"  integer,parameter::nvar=NVAR"
  write(ilun,format)"#endif"
  write(ilun,format)"  ! Size of hydro kernel"
  write(ilun,format)"  integer,parameter::iu1=-1"
  write(ilun,format)"  integer,parameter::iu2=+4"
  write(ilun,format)"  integer,parameter::ju1=(1-ndim/2)-1*(ndim/2)"
  write(ilun,format)"  integer,parameter::ju2=(1-ndim/2)+4*(ndim/2)"
  write(ilun,format)"  integer,parameter::ku1=(1-ndim/3)-1*(ndim/3)"
  write(ilun,format)"  integer,parameter::ku2=(1-ndim/3)+4*(ndim/3)"
  write(ilun,format)"  integer,parameter::if1=1"
  write(ilun,format)"  integer,parameter::if2=3"
  write(ilun,format)"  integer,parameter::jf1=1"
  write(ilun,format)"  integer,parameter::jf2=(1-ndim/2)+3*(ndim/2)"
  write(ilun,format)"  integer,parameter::kf1=1"
  write(ilun,format)"  integer,parameter::kf2=(1-ndim/3)+3*(ndim/3)"
  write(ilun,format)""
  write(ilun,format)"  ! Imposed boundary condition variables"
  write(ilun,format)"  real(dp),dimension(1:MAXBOUND,1:nvar)::boundary_var"
  write(ilun,format)"  real(dp),dimension(1:MAXBOUND)::d_bound=0.0d0"
  write(ilun,format)"  real(dp),dimension(1:MAXBOUND)::p_bound=0.0d0"
  write(ilun,format)"  real(dp),dimension(1:MAXBOUND)::u_bound=0.0d0"
  write(ilun,format)"  real(dp),dimension(1:MAXBOUND)::v_bound=0.0d0"
  write(ilun,format)"  real(dp),dimension(1:MAXBOUND)::w_bound=0.0d0"
  write(ilun,format)"#if NENER>0"
  write(ilun,format)"  real(dp),dimension(1:MAXBOUND,1:NENER)::prad_bound=0.0"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NVAR>NDIM+2+NENER"
  write(ilun,format)"  real(dp),dimension(1:MAXBOUND,1:NVAR-NDIM-2-NENER)::var_bound=0.0"
  write(ilun,format)"#endif"
  write(ilun,format)"  ! Refinement parameters for hydro"
  write(ilun,format)"  real(dp)::err_grad_d=-1.0  ! Density gradient"
  write(ilun,format)"  real(dp)::err_grad_u=-1.0  ! Velocity gradient"
  write(ilun,format)"  real(dp)::err_grad_p=-1.0  ! Pressure gradient"
  write(ilun,format)"  real(dp)::floor_d=1.d-10   ! Density floor"
  write(ilun,format)"  real(dp)::floor_u=1.d-10   ! Velocity floor"
  write(ilun,format)"  real(dp)::floor_p=1.d-10   ! Pressure floor"
  write(ilun,format)"  real(dp)::mass_sph=0.0D0   ! mass_sph"
  write(ilun,format)"#if NENER>0"
  write(ilun,format)"  real(dp),dimension(1:NENER)::err_grad_prad=-1.0"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NVAR>NDIM+2+NENER"
  write(ilun,format)"  real(dp),dimension(1:NVAR-NDIM-2)::err_grad_var=-1.0"
  write(ilun,format)"#endif"
  write(ilun,format)"  real(dp),dimension(1:MAXLEVEL)::jeans_refine=-1.0"
  write(ilun,format)""
  write(ilun,format)"  ! Initial conditions hydro variables"
  write(ilun,format)"  real(dp),dimension(1:MAXREGION)::d_region=0."
  write(ilun,format)"  real(dp),dimension(1:MAXREGION)::u_region=0."
  write(ilun,format)"  real(dp),dimension(1:MAXREGION)::v_region=0."
  write(ilun,format)"  real(dp),dimension(1:MAXREGION)::w_region=0."
  write(ilun,format)"  real(dp),dimension(1:MAXREGION)::p_region=0."
  write(ilun,format)"#if NENER>0"
  write(ilun,format)"  real(dp),dimension(1:MAXREGION,1:NENER)::prad_region=0.0"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NVAR>NDIM+2+NENER"
  write(ilun,format)"  real(dp),dimension(1:MAXREGION,1:NVAR-NDIM-2-NENER)::var_region=0.0"
  write(ilun,format)"#endif"
  write(ilun,format)"  ! Hydro solver parameters"
  write(ilun,format)"  integer ::niter_riemann=10"
  write(ilun,format)"  integer ::slope_type=1"
  write(ilun,format)"  real(dp)::slope_theta=1.5d0"
  write(ilun,format)"  real(dp)::gamma=1.4d0"
  write(ilun,format)"  real(dp),dimension(1:512)::gamma_rad=1.33333333334d0"
  write(ilun,format)"  real(dp)::courant_factor=0.5d0"
  write(ilun,format)"  real(dp)::difmag=0.0d0"
  write(ilun,format)"  real(dp)::smallc=1.d-10"
  write(ilun,format)"  real(dp)::smallr=1.d-10"
  write(ilun,format)"  character(LEN=10)::scheme='muscl'"
  write(ilun,format)"  character(LEN=10)::riemann='llf'"
  write(ilun,format)""
  write(ilun,format)"  ! Interpolation parameters"
  write(ilun,format)"  integer ::interpol_var=0"
  write(ilun,format)"  integer ::interpol_type=1"
  write(ilun,format)""
  write(ilun,format)"  ! Passive variables index"
  write(ilun,format)"  integer::imetal=6"
  write(ilun,format)"  integer::idelay=6"
  write(ilun,format)"  integer::ixion=6"
  write(ilun,format)"  integer::ichem=6"
  write(ilun,format)"  integer::ivirial1=6"
  write(ilun,format)"  integer::ivirial2=6"
  write(ilun,format)"  integer::inener=6"
  write(ilun,format)""
  write(ilun,format)"  ! Maximum temperature limit"
  write(ilun,format)"  real(dp)::T_limit=1.0d12"
  write(ilun,format)""
  write(ilun,format)"end module hydro_parameters"
  write(ilun,format)"../patch/hydro/stratified_medium_fx_NSM/init_flow_fine.f90"
  write(ilun,format)"! set NX_LN as preprocessor variable: need to also set in condinit.f90"
  write(ilun,format)"#define NX_LN 512"
  write(ilun,format)""
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine init_flow  "
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons, ONLY: nvar, uold"
  write(ilun,format)"  implicit none"
  write(ilun,format)""
  write(ilun,format)"  integer::ilevel,ivar"
  write(ilun,format)"  "
  write(ilun,format)"  if(verbose)write(*,*)'Entering init_flow'"
  write(ilun,format)"  do ilevel=nlevelmax,1,-1"
  write(ilun,format)"     if(ilevel>=levelmin)call init_flow_fine(ilevel)"
  write(ilun,format)"     call upload_fine(ilevel)"
  write(ilun,format)"     do ivar=1,nvar"
  write(ilun,format)"        call make_virtual_fine_dp(uold(1,ivar),ilevel)"
  write(ilun,format)"     end do"
  write(ilun,format)"     if(simple_boundary)call make_boundary_hydro(ilevel)"
  write(ilun,format)"  end do"
  write(ilun,format)"  if(verbose)write(*,*)'Complete init_flow'"
  write(ilun,format)""
  write(ilun,format)"end subroutine init_flow"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine init_flow_fine(ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use cooling_module"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)"  "
  write(ilun,format)"  integer::i,icell,igrid,ncache,iskip,ngrid,ilun"
  write(ilun,format)"  integer::ind,idim,ivar,ix,iy,iz,nx_loc"
  write(ilun,format)"  integer::i1,i2,i3,i1_min,i1_max,i2_min,i2_max,i3_min,i3_max"
  write(ilun,format)"  integer::buf_count,info,nvar_in"
  write(ilun,format)"  integer ,dimension(1:nvector),save::ind_grid,ind_cell"
  write(ilun,format)""
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v"
  write(ilun,format)"  real(dp)::dx,rr,vx,vy,vz,ek,ei,pp,xx1,xx2,xx3,dx_loc,scale,xval"
  write(ilun,format)"  real(dp),dimension(1:3)::skip_loc"
  write(ilun,format)"  real(dp),dimension(1:twotondim,1:3)::xc"
  write(ilun,format)"  real(dp),dimension(1:nvector)       ,save::vv"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim),save::xx"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:nvar),save::uu"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  real(dp),allocatable,dimension(:,:,:)::init_array"
  write(ilun,format)"  real(kind=4),allocatable,dimension(:,:)  ::init_plane"
  write(ilun,format)"  real*4,dimension(1:NX_LN**3)::ln_d !  hard coding ln_d size"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  logical::error,ok_file1,ok_file2,ok_file3,ok_file"
  write(ilun,format)"  character(LEN=160)::filename, infile"
  write(ilun,format)"  character(LEN=5)::nchar,ncharvar"
  write(ilun,format)""
  write(ilun,format)"  if(numbtot(1,ilevel)==0)return"
  write(ilun,format)"  if(verbose)write(*,111)ilevel"
  write(ilun,format)""
  write(ilun,format)"  ! Conversion factor from user units to cgs units"
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh size at level ilevel in coarse cell units"
  write(ilun,format)"  dx=0.5D0**ilevel"
  write(ilun,format)"  "
  write(ilun,format)"  ! Set position of cell centers relative to grid center"
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     iz=(ind-1)/4"
  write(ilun,format)"     iy=(ind-1-4*iz)/2"
  write(ilun,format)"     ix=(ind-1-2*iy-4*iz)"
  write(ilun,format)"     if(ndim>0)xc(ind,1)=(dble(ix)-0.5D0)*dx"
  write(ilun,format)"     if(ndim>1)xc(ind,2)=(dble(iy)-0.5D0)*dx"
  write(ilun,format)"     if(ndim>2)xc(ind,3)=(dble(iz)-0.5D0)*dx"
  write(ilun,format)"  end do"
  write(ilun,format)"  "
  write(ilun,format)"  ! Local constants"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  skip_loc=(/0.0d0,0.0d0,0.0d0/)"
  write(ilun,format)"  if(ndim>0)skip_loc(1)=dble(icoarse_min)"
  write(ilun,format)"  if(ndim>1)skip_loc(2)=dble(jcoarse_min)"
  write(ilun,format)"  if(ndim>2)skip_loc(3)=dble(kcoarse_min)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)"  ncache=active(ilevel)%ngrid"
  write(ilun,format)""
  write(ilun,format)"  !--------------------------------------"
  write(ilun,format)"  ! Compute initial conditions from files"
  write(ilun,format)"  !--------------------------------------"
  write(ilun,format)"  filename=TRIM(initfile(ilevel))//'/ic_d'"
  write(ilun,format)"  INQUIRE(file=filename,exist=ok_file1)"
  write(ilun,format)"  if(multiple)then"
  write(ilun,format)"     filename=TRIM(initfile(ilevel))//'/dir_deltab/ic_deltab.00001'"
  write(ilun,format)"     INQUIRE(file=filename,exist=ok_file2)"
  write(ilun,format)"  else"
  write(ilun,format)"     filename=TRIM(initfile(ilevel))//'/ic_deltab'"
  write(ilun,format)"     INQUIRE(file=filename,exist=ok_file2)"
  write(ilun,format)"  endif"
  write(ilun,format)"  ok_file = ok_file1 .or. ok_file2"
  write(ilun,format)"  if(ok_file)then"
  write(ilun,format)""
  write(ilun,format)"     !-------------------------------------------------------------------------"
  write(ilun,format)"     ! First step: compute level boundaries in terms of initial condition array"
  write(ilun,format)"     !-------------------------------------------------------------------------"
  write(ilun,format)"     if(ncache>0)then"
  write(ilun,format)"     i1_min=n1(ilevel)+1; i1_max=0"
  write(ilun,format)"     i2_min=n2(ilevel)+1; i2_max=0"
  write(ilun,format)"     i3_min=n3(ilevel)+1; i3_max=0"
  write(ilun,format)"     do ind=1,twotondim           "
  write(ilun,format)"        do i=1,ncache"
  write(ilun,format)"           igrid=active(ilevel)%igrid(i)"
  write(ilun,format)"           xx1=xg(igrid,1)+xc(ind,1)-skip_loc(1)"
  write(ilun,format)"           xx1=(xx1*(dxini(ilevel)/dx)-xoff1(ilevel))/dxini(ilevel)"
  write(ilun,format)"           xx2=xg(igrid,2)+xc(ind,2)-skip_loc(2)"
  write(ilun,format)"           xx2=(xx2*(dxini(ilevel)/dx)-xoff2(ilevel))/dxini(ilevel)"
  write(ilun,format)"           xx3=xg(igrid,3)+xc(ind,3)-skip_loc(3)"
  write(ilun,format)"           xx3=(xx3*(dxini(ilevel)/dx)-xoff3(ilevel))/dxini(ilevel)"
  write(ilun,format)"           i1_min=MIN(i1_min,int(xx1)+1)"
  write(ilun,format)"           i1_max=MAX(i1_max,int(xx1)+1)"
  write(ilun,format)"           i2_min=MIN(i2_min,int(xx2)+1)"
  write(ilun,format)"           i2_max=MAX(i2_max,int(xx2)+1)"
  write(ilun,format)"           i3_min=MIN(i3_min,int(xx3)+1)"
  write(ilun,format)"           i3_max=MAX(i3_max,int(xx3)+1)"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     error=.false."
  write(ilun,format)"     if(i1_min<1.or.i1_max>n1(ilevel))error=.true."
  write(ilun,format)"     if(i2_min<1.or.i2_max>n2(ilevel))error=.true."
  write(ilun,format)"     if(i3_min<1.or.i3_max>n3(ilevel))error=.true."
  write(ilun,format)"     if(error) then"
  write(ilun,format)"        write(*,*)'Some grid are outside initial conditions sub-volume'"
  write(ilun,format)"        write(*,*)'for ilevel=',ilevel"
  write(ilun,format)"        write(*,*)i1_min,i1_max"
  write(ilun,format)"        write(*,*)i2_min,i2_max"
  write(ilun,format)"        write(*,*)i3_min,i3_max"
  write(ilun,format)"        write(*,*)n1(ilevel),n2(ilevel),n3(ilevel)"
  write(ilun,format)"        call clean_stop"
  write(ilun,format)"     end if"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     !-----------------------------------------"
  write(ilun,format)"     ! Second step: read initial condition file"
  write(ilun,format)"     !-----------------------------------------"
  write(ilun,format)"     ! Allocate initial conditions array"
  write(ilun,format)"     if(ncache>0)allocate(init_array(i1_min:i1_max,i2_min:i2_max,i3_min:i3_max))"
  write(ilun,format)"     allocate(init_plane(1:n1(ilevel),1:n2(ilevel)))"
  write(ilun,format)"     ! Loop over input variables"
  write(ilun,format)"     do ivar=1,nvar"
  write(ilun,format)"        if(cosmo)then"
  write(ilun,format)"           ! Read baryons initial overdensity and displacement at a=aexp"
  write(ilun,format)"           if(multiple)then"
  write(ilun,format)"              call title(myid,nchar)"
  write(ilun,format)"              if(ivar==1)filename=TRIM(initfile(ilevel))//'/dir_deltab/ic_deltab.'//TRIM(nchar)"
  write(ilun,format)"              if(ivar==2)filename=TRIM(initfile(ilevel))//'/dir_velcx/ic_velcx.'//TRIM(nchar)"
  write(ilun,format)"              if(ivar==3)filename=TRIM(initfile(ilevel))//'/dir_velcy/ic_velcy.'//TRIM(nchar)"
  write(ilun,format)"              if(ivar==4)filename=TRIM(initfile(ilevel))//'/dir_velcz/ic_velcz.'//TRIM(nchar)"
  write(ilun,format)"              if(ivar==5)filename=TRIM(initfile(ilevel))//'/dir_tempb/ic_tempb.'//TRIM(nchar)"
  write(ilun,format)"           else"
  write(ilun,format)"              if(ivar==1)filename=TRIM(initfile(ilevel))//'/ic_deltab'"
  write(ilun,format)"              if(ivar==2)filename=TRIM(initfile(ilevel))//'/ic_velcx'"
  write(ilun,format)"              if(ivar==3)filename=TRIM(initfile(ilevel))//'/ic_velcy'"
  write(ilun,format)"              if(ivar==4)filename=TRIM(initfile(ilevel))//'/ic_velcz'"
  write(ilun,format)"              if(ivar==5)filename=TRIM(initfile(ilevel))//'/ic_tempb'"
  write(ilun,format)"           endif"
  write(ilun,format)"        else"
  write(ilun,format)"           ! Read primitive variables"
  write(ilun,format)"           if(ivar==1)filename=TRIM(initfile(ilevel))//'/ic_d'"
  write(ilun,format)"           if(ivar==2)filename=TRIM(initfile(ilevel))//'/ic_u'"
  write(ilun,format)"           if(ivar==3)filename=TRIM(initfile(ilevel))//'/ic_v'"
  write(ilun,format)"           if(ivar==4)filename=TRIM(initfile(ilevel))//'/ic_w'"
  write(ilun,format)"           if(ivar==5)filename=TRIM(initfile(ilevel))//'/ic_p'"
  write(ilun,format)"        endif"
  write(ilun,format)"        call title(ivar,ncharvar)"
  write(ilun,format)"        if(ivar>5)then"
  write(ilun,format)"           call title(ivar-5,ncharvar)"
  write(ilun,format)"           filename=TRIM(initfile(ilevel))//'/ic_pvar_'//TRIM(ncharvar)"
  write(ilun,format)"        endif"
  write(ilun,format)""
  write(ilun,format)"        INQUIRE(file=filename,exist=ok_file3)"
  write(ilun,format)"        if(ok_file3)then"
  write(ilun,format)"           ! Reading the existing file   "
  write(ilun,format)"           if(myid==1)write(*,*)'Reading file '//TRIM(filename)"
  write(ilun,format)"           if(multiple)then"
  write(ilun,format)"              ilun=ncpu+myid+10"
  write(ilun,format)"              open(ilun,file=filename,form='unformatted')"
  write(ilun,format)"              rewind ilun"
  write(ilun,format)"              read(ilun) ! skip first line"
  write(ilun,format)"              do i3=1,n3(ilevel)"
  write(ilun,format)"                 read(ilun) ((init_plane(i1,i2),i1=1,n1(ilevel)),i2=1,n2(ilevel))"
  write(ilun,format)"                 if(i3.ge.i3_min.and.i3.le.i3_max)then"
  write(ilun,format)"                    init_array(i1_min:i1_max,i2_min:i2_max,i3) = &"
  write(ilun,format)"                         & init_plane(i1_min:i1_max,i2_min:i2_max)"
  write(ilun,format)"                 end if"
  write(ilun,format)"              end do"
  write(ilun,format)"              close(ilun)"
  write(ilun,format)"           else"
  write(ilun,format)"              if(myid==1)then"
  write(ilun,format)"                 open(10,file=filename,form='unformatted')"
  write(ilun,format)"                 rewind 10"
  write(ilun,format)"                 read(10) ! skip first line"
  write(ilun,format)"              endif"
  write(ilun,format)"              do i3=1,n3(ilevel)"
  write(ilun,format)"                 if(myid==1)then"
  write(ilun,format)"                    read(10) ((init_plane(i1,i2),i1=1,n1(ilevel)),i2=1,n2(ilevel))"
  write(ilun,format)"                 else"
  write(ilun,format)"                    init_plane=0.0"
  write(ilun,format)"                 endif"
  write(ilun,format)"                 buf_count=n1(ilevel)*n2(ilevel)"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"                 call MPI_BCAST(init_plane,buf_count,MPI_REAL,0,MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"                 if(ncache>0)then"
  write(ilun,format)"                    if(i3.ge.i3_min.and.i3.le.i3_max)then"
  write(ilun,format)"                       init_array(i1_min:i1_max,i2_min:i2_max,i3) = &"
  write(ilun,format)"                            & init_plane(i1_min:i1_max,i2_min:i2_max)"
  write(ilun,format)"                    end if"
  write(ilun,format)"                 endif"
  write(ilun,format)"              end do"
  write(ilun,format)"              if(myid==1)close(10)"
  write(ilun,format)"           endif"
  write(ilun,format)"        else"
  write(ilun,format)"           ! If file doesn't exist, initialize variable to default value "
  write(ilun,format)"           ! In most cases, this is zero (you can change that if necessary)"
  write(ilun,format)"           if(myid==1)write(*,*)'File '//TRIM(filename)//' not found'"
  write(ilun,format)"           if(myid==1)write(*,*)'Initialize corresponding variable to default value'"
  write(ilun,format)"           init_array=0d0"
  write(ilun,format)"           ! Default value for metals"
  write(ilun,format)"           if(cosmo.and.ivar==imetal.and.metal)init_array=z_ave*0.02 ! from solar units"
  write(ilun,format)"           ! Default value for ionization fraction"
  write(ilun,format)"           xval=sqrt(omega_m)/(h0/100.*omega_b) ! From the book of Peebles p. 173"
  write(ilun,format)"           if(cosmo.and.ivar==ixion.and.aton)init_array=1.2d-5*xval"
  write(ilun,format)"        endif"
  write(ilun,format)""
  write(ilun,format)"        if(ncache>0)then"
  write(ilun,format)""
  write(ilun,format)"        ! For cosmo runs, rescale initial conditions to code units"
  write(ilun,format)"        if(cosmo)then"
  write(ilun,format)"           ! Compute approximate average temperature in K"
  write(ilun,format)"           if(.not. cooling)T2_start=1.356d-2/aexp**2"
  write(ilun,format)"           if(ivar==1)init_array=(1.0+dfact(ilevel)*init_array)*omega_b/omega_m"
  write(ilun,format)"           if(ivar==2)init_array=dfact(ilevel)*vfact(1)*dx_loc/dxini(ilevel)*init_array/vfact(ilevel)"
  write(ilun,format)"           if(ivar==3)init_array=dfact(ilevel)*vfact(1)*dx_loc/dxini(ilevel)*init_array/vfact(ilevel)"
  write(ilun,format)"           if(ivar==4)init_array=dfact(ilevel)*vfact(1)*dx_loc/dxini(ilevel)*init_array/vfact(ilevel)"
  write(ilun,format)"           if(ivar==ndim+2)init_array=(1.0+init_array)*T2_start/scale_T2"
  write(ilun,format)"        endif"
  write(ilun,format)""
  write(ilun,format)"        ! Loop over cells"
  write(ilun,format)"        do ind=1,twotondim"
  write(ilun,format)"           iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"           do i=1,ncache"
  write(ilun,format)"              igrid=active(ilevel)%igrid(i)"
  write(ilun,format)"              icell=igrid+iskip"
  write(ilun,format)"              xx1=xg(igrid,1)+xc(ind,1)-skip_loc(1)"
  write(ilun,format)"              xx1=(xx1*(dxini(ilevel)/dx)-xoff1(ilevel))/dxini(ilevel)"
  write(ilun,format)"              xx2=xg(igrid,2)+xc(ind,2)-skip_loc(2)"
  write(ilun,format)"              xx2=(xx2*(dxini(ilevel)/dx)-xoff2(ilevel))/dxini(ilevel)"
  write(ilun,format)"              xx3=xg(igrid,3)+xc(ind,3)-skip_loc(3)"
  write(ilun,format)"              xx3=(xx3*(dxini(ilevel)/dx)-xoff3(ilevel))/dxini(ilevel)"
  write(ilun,format)"              i1=int(xx1)+1"
  write(ilun,format)"              i1=int(xx1)+1"
  write(ilun,format)"              i2=int(xx2)+1"
  write(ilun,format)"              i2=int(xx2)+1"
  write(ilun,format)"              i3=int(xx3)+1"
  write(ilun,format)"              i3=int(xx3)+1"
  write(ilun,format)"              ! Scatter to corresponding primitive variable"
  write(ilun,format)"              uold(icell,ivar)=init_array(i1,i2,i3)"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"        ! End loop over cells"
  write(ilun,format)"        endif"
  write(ilun,format)"     end do"
  write(ilun,format)"     ! End loop over input variables"
  write(ilun,format)""
  write(ilun,format)"     ! Deallocate initial conditions array"
  write(ilun,format)"     if(ncache>0)deallocate(init_array)"
  write(ilun,format)"     deallocate(init_plane) "
  write(ilun,format)""
  write(ilun,format)"     !----------------------------------------------------------------"
  write(ilun,format)"     ! For cosmology runs: compute pressure, prevent negative density"
  write(ilun,format)"     !----------------------------------------------------------------"
  write(ilun,format)"     if(cosmo)then"
  write(ilun,format)"        ! Loop over grids by vector sweeps"
  write(ilun,format)"        do igrid=1,ncache,nvector"
  write(ilun,format)"           ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              ind_grid(i)=active(ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! Loop over cells"
  write(ilun,format)"           do ind=1,twotondim"
  write(ilun,format)"              ! Gather cell indices"
  write(ilun,format)"              iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"              end do"
  write(ilun,format)"              ! Prevent negative density"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 rr=max(uold(ind_cell(i),1),0.1*omega_b/omega_m)"
  write(ilun,format)"                 uold(ind_cell(i),1)=rr"
  write(ilun,format)"              end do"
  write(ilun,format)"              ! Compute pressure from temperature and density"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 uold(ind_cell(i),ndim+2)=uold(ind_cell(i),1)*uold(ind_cell(i),ndim+2)"
  write(ilun,format)"              end do"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! End loop over cells"
  write(ilun,format)"        end do"
  write(ilun,format)"        ! End loop over grids"
  write(ilun,format)"     end if"
  write(ilun,format)""
  write(ilun,format)"     !---------------------------------------------------"
  write(ilun,format)"     ! Third step: compute initial conservative variables"
  write(ilun,format)"     !---------------------------------------------------"
  write(ilun,format)"     ! Loop over grids by vector sweeps"
  write(ilun,format)"     do igrid=1,ncache,nvector"
  write(ilun,format)"        ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_grid(i)=active(ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"        end do"
  write(ilun,format)"        vy=0.0"
  write(ilun,format)"        vz=0.0"
  write(ilun,format)"        ! Loop over cells"
  write(ilun,format)"        do ind=1,twotondim"
  write(ilun,format)"           ! Gather cell indices"
  write(ilun,format)"           iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! Compute total energy density"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              rr=uold(ind_cell(i),1)"
  write(ilun,format)"              vx=uold(ind_cell(i),2)"
  write(ilun,format)"#if NDIM>1"
  write(ilun,format)"              vy=uold(ind_cell(i),3)"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM>2"
  write(ilun,format)"              vz=uold(ind_cell(i),4)"
  write(ilun,format)"#endif"
  write(ilun,format)"              pp=uold(ind_cell(i),ndim+2)"
  write(ilun,format)"              ek=0.5d0*(vx**2+vy**2+vz**2)"
  write(ilun,format)"              ei=pp/(gamma-1.0)"
  write(ilun,format)"              vv(i)=ei+rr*ek"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! Scatter to corresponding conservative variable"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              uold(ind_cell(i),ndim+2)=vv(i)"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! Compute momentum density"
  write(ilun,format)"           do ivar=1,ndim"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 rr=uold(ind_cell(i),1)"
  write(ilun,format)"                 vx=uold(ind_cell(i),ivar+1)"
  write(ilun,format)"                 vv(i)=rr*vx"
  write(ilun,format)"              end do"
  write(ilun,format)"              ! Scatter to corresponding conservative variable"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 uold(ind_cell(i),ivar+1)=vv(i)"
  write(ilun,format)"              end do"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! Compute passive variable density"
  write(ilun,format)"           do ivar=ndim+3,nvar"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 rr=uold(ind_cell(i),1)"
  write(ilun,format)"                 uold(ind_cell(i),ivar)=rr*uold(ind_cell(i),ivar)"
  write(ilun,format)"              end do"
  write(ilun,format)"           enddo"
  write(ilun,format)"        end do"
  write(ilun,format)"        ! End loop over cells"
  write(ilun,format)"        "
  write(ilun,format)"     end do"
  write(ilun,format)"     ! End loop over grids"
  write(ilun,format)""
  write(ilun,format)"  !-------------------------------------------------------"
  write(ilun,format)"  ! Compute initial conditions from subroutine condinit"
  write(ilun,format)"  !"
  write(ilun,format)"  !  If reading ICs from a file, condinit is not used! "
  write(ilun,format)"  !-------------------------------------------------------"
  write(ilun,format)"  else"
  write(ilun,format)"     !  if I can make array accessible in condinit, then "
  write(ilun,format)"     ! I could read in lognormal density field here, just once."
  write(ilun,format)"    "
  write(ilun,format)"     if (medium_type=='fractal' .or. medium_type=='disk_fractal') then"
  write(ilun,format)"       ! fractal cloud assumes 3D"
  write(ilun,format)""
  write(ilun,format)"       ! Read pre-computed density field."
  write(ilun,format)"       !write(*,*) grid_file"
  write(ilun,format)""
  write(ilun,format)"       open(unit=1,file=grid_file,form='unformatted',access='stream')"
  write(ilun,format)"       "
  write(ilun,format)"       !write(*,*) 'after opening grid_file'"
  write(ilun,format)"       "
  write(ilun,format)"       do i=1,(NX_LN**3) !  hard coding nx_ln"
  write(ilun,format)"         read(1) ln_d(i)"
  write(ilun,format)"       "
  write(ilun,format)"          !write(*,*) i"
  write(ilun,format)"       end do"
  write(ilun,format)""
  write(ilun,format)"       !write(*,*) 'just before close statement'"
  write(ilun,format)""
  write(ilun,format)"       close(1)"
  write(ilun,format)""
  write(ilun,format)"       !write(*,*) 'after ln_d loop'"
  write(ilun,format)""
  write(ilun,format)"       ! Want to pass ln_d to condinit"
  write(ilun,format)""
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     open(unit=1,file=random_file,status='old')"
  write(ilun,format)"     do i=1,nrandom"
  write(ilun,format)"        read(1,*)random_expl(i),x_expl(i),y_expl(i),z_expl(i),random_NSM(i), random_Ia(i)"
  write(ilun,format)"     end do"
  write(ilun,format)"     close(1)"
  write(ilun,format)""
  write(ilun,format)"     !write(*,*) 'after medium_type condition!!!!!!!!!!!!!' "
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"     ! Loop over grids by vector sweeps"
  write(ilun,format)"     do igrid=1,ncache,nvector"
  write(ilun,format)"        ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_grid(i)=active(ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"        end do"
  write(ilun,format)"        ! Loop over cells"
  write(ilun,format)"        do ind=1,twotondim"
  write(ilun,format)"           ! Gather cell indices"
  write(ilun,format)"           iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! Gather cell centre positions"
  write(ilun,format)"           do idim=1,ndim"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 xx(i,idim)=xg(ind_grid(i),idim)+xc(ind,idim)"
  write(ilun,format)"              end do"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! Rescale position from code units to user units"
  write(ilun,format)"           do idim=1,ndim"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 xx(i,idim)=(xx(i,idim)-skip_loc(idim))*scale"
  write(ilun,format)"              end do"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! Call initial condition routine"
  write(ilun,format)"           "
  write(ilun,format)"	   !  pass ln_d to condinit"
  write(ilun,format)"	   call condinit(xx,uu,dx_loc,ngrid,ln_d)"
  write(ilun,format)""
  write(ilun,format)"           ! Scatter variables"
  write(ilun,format)"           do ivar=1,nvar"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 uold(ind_cell(i),ivar)=uu(i,ivar)"
  write(ilun,format)"              end do"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"        ! End loop over cells"
  write(ilun,format)"     end do"
  write(ilun,format)"     ! End loop over grids"
  write(ilun,format)""
  write(ilun,format)"  end if"
  write(ilun,format)"  "
  write(ilun,format)"111 format('   Entering init_flow_fine for level ',I2)"
  write(ilun,format)""
  write(ilun,format)"end subroutine init_flow_fine"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine region_condinit(x,q,dx,nn)"
  write(ilun,format)"  use amr_parameters"
  write(ilun,format)"  use hydro_parameters"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer ::nn"
  write(ilun,format)"  real(dp)::dx"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:nvar)::q"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim)::x"
  write(ilun,format)""
  write(ilun,format)"  integer::i,ivar,k"
  write(ilun,format)"  real(dp)::vol,r,xn,yn,zn,en"
  write(ilun,format)""
  write(ilun,format)"  ! Set some (tiny) default values in case n_region=0"
  write(ilun,format)"  q(1:nn,1)=smallr"
  write(ilun,format)"  q(1:nn,2)=0.0d0"
  write(ilun,format)"#if NDIM>1"
  write(ilun,format)"  q(1:nn,3)=0.0d0"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM>2"
  write(ilun,format)"  q(1:nn,4)=0.0d0"
  write(ilun,format)"#endif"
  write(ilun,format)"  q(1:nn,ndim+2)=smallr*smallc**2/gamma"
  write(ilun,format)"  do ivar=ndim+3,nvar"
  write(ilun,format)"     q(1:nn,ivar)=0.0d0"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Loop over initial conditions regions"
  write(ilun,format)"  do k=1,nregion"
  write(ilun,format)"     "
  write(ilun,format)"     ! For 'square' regions only:"
  write(ilun,format)"     if(region_type(k) .eq. 'square')then"
  write(ilun,format)"        ! Exponent of choosen norm"
  write(ilun,format)"        en=exp_region(k)"
  write(ilun,format)"        do i=1,nn"
  write(ilun,format)"           ! Compute position in normalized coordinates"
  write(ilun,format)"           xn=0.0d0; yn=0.0d0; zn=0.0d0"
  write(ilun,format)"           xn=2.0d0*abs(x(i,1)-x_center(k))/length_x(k)"
  write(ilun,format)"#if NDIM>1"
  write(ilun,format)"           yn=2.0d0*abs(x(i,2)-y_center(k))/length_y(k)"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM>2"
  write(ilun,format)"           zn=2.0d0*abs(x(i,3)-z_center(k))/length_z(k)"
  write(ilun,format)"#endif"
  write(ilun,format)"           ! Compute cell 'radius' relative to region center"
  write(ilun,format)"           if(exp_region(k)<10)then"
  write(ilun,format)"              r=(xn**en+yn**en+zn**en)**(1.0/en)"
  write(ilun,format)"           else"
  write(ilun,format)"              r=max(xn,yn,zn)"
  write(ilun,format)"           end if"
  write(ilun,format)"           ! If cell lies within region,"
  write(ilun,format)"           ! REPLACE primitive variables by region values"
  write(ilun,format)"           if(r<1.0)then"
  write(ilun,format)"              q(i,1)=d_region(k)"
  write(ilun,format)"              q(i,2)=u_region(k)"
  write(ilun,format)"#if NDIM>1"
  write(ilun,format)"              q(i,3)=v_region(k)"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM>2"
  write(ilun,format)"              q(i,4)=w_region(k)"
  write(ilun,format)"#endif"
  write(ilun,format)"              q(i,ndim+2)=p_region(k)"
  write(ilun,format)"           end if"
  write(ilun,format)"        end do"
  write(ilun,format)"     end if"
  write(ilun,format)"     "
  write(ilun,format)"     ! For 'point' regions only:"
  write(ilun,format)"     if(region_type(k) .eq. 'point')then"
  write(ilun,format)"        ! Volume elements"
  write(ilun,format)"        vol=dx**ndim"
  write(ilun,format)"        ! Compute CIC weights relative to region center"
  write(ilun,format)"        do i=1,nn"
  write(ilun,format)"           xn=1.0; yn=1.0; zn=1.0"
  write(ilun,format)"           xn=max(1.0-abs(x(i,1)-x_center(k))/dx,0.0_dp)"
  write(ilun,format)"#if NDIM>1"
  write(ilun,format)"           yn=max(1.0-abs(x(i,2)-y_center(k))/dx,0.0_dp)"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM>2"
  write(ilun,format)"           zn=max(1.0-abs(x(i,3)-z_center(k))/dx,0.0_dp)"
  write(ilun,format)"#endif"
  write(ilun,format)"           r=xn*yn*zn"
  write(ilun,format)"           ! If cell lies within CIC cloud, "
  write(ilun,format)"           ! ADD to primitive variables the region values"
  write(ilun,format)"           q(i,1)=q(i,1)+d_region(k)*r/vol"
  write(ilun,format)"           q(i,2)=q(i,2)+u_region(k)*r"
  write(ilun,format)"#if NDIM>1"
  write(ilun,format)"           q(i,3)=q(i,3)+v_region(k)*r"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM>2"
  write(ilun,format)"           q(i,4)=q(i,4)+w_region(k)*r"
  write(ilun,format)"#endif"
  write(ilun,format)"           q(i,ndim+2)=q(i,ndim+2)+p_region(k)*r/vol"
  write(ilun,format)"        end do"
  write(ilun,format)"     end if"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  return"
  write(ilun,format)"end subroutine region_condinit"
  write(ilun,format)"../patch/hydro/stratified_medium_fx_NSM/newdt_fine.f90"
  write(ilun,format)"subroutine newdt_fine(ilevel)"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use poisson_commons, ONLY: gravity_type"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)"  !-----------------------------------------------------------"
  write(ilun,format)"  ! This routine compute the time step using 3 constraints:"
  write(ilun,format)"  ! 1- a Courant-type condition using particle velocity"
  write(ilun,format)"  ! 2- the gravity free-fall time"
  write(ilun,format)"  ! 3- 10% maximum variation for aexp "
  write(ilun,format)"  ! 4- maximum step time for ATON"
  write(ilun,format)"  ! This routine also compute the particle kinetic energy."
  write(ilun,format)"  !-----------------------------------------------------------"
  write(ilun,format)"  "
  write(ilun,format)"  integer::igrid,jgrid,ipart,jpart"
  write(ilun,format)"  integer::npart1,ip,info"
  write(ilun,format)"  integer,dimension(1:nvector),save::ind_part"
  write(ilun,format)"  real(kind=8)::dt_loc,dt_all,ekin_loc,ekin_all"
  write(ilun,format)"  real(dp)::tff,fourpi,threepi2"
  write(ilun,format)"  real(dp)::aton_time_step,dt_aton"
  write(ilun,format)""
  write(ilun,format)"  if(numbtot(1,ilevel)==0)return"
  write(ilun,format)"  if(verbose)write(*,111)ilevel"
  write(ilun,format)""
  write(ilun,format)"  ! Save old time step"
  write(ilun,format)"  dtold(ilevel)=dtnew(ilevel)"
  write(ilun,format)""
  write(ilun,format)"  ! Maximum time step"
  write(ilun,format)"  dtnew(ilevel)=boxlen/smallc"
  write(ilun,format)"  if(poisson.and.gravity_type<=0)then"
  write(ilun,format)"     fourpi=4.0d0*ACOS(-1.0d0)"
  write(ilun,format)"     threepi2=3.0d0*ACOS(-1.0d0)**2"
  write(ilun,format)"     if(cosmo)fourpi=1.5d0*omega_m*aexp"
  write(ilun,format)"     tff=sqrt(threepi2/8./fourpi/rho_max(ilevel))"
  write(ilun,format)"     dtnew(ilevel)=MIN(dtnew(ilevel),courant_factor*tff)"
  write(ilun,format)"  end if"
  write(ilun,format)"  if(cosmo)then"
  write(ilun,format)"     dtnew(ilevel)=MIN(dtnew(ilevel),0.1/hexp)"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"#ifdef ATON"
  write(ilun,format)"  ! Maximum time step for ATON"
  write(ilun,format)"  if(aton)then"
  write(ilun,format)"     dt_aton = aton_time_step()"
  write(ilun,format)"     if(dt_aton>0d0)then"
  write(ilun,format)"        dtnew(ilevel)=MIN(dtnew(ilevel),dt_aton)"
  write(ilun,format)"     end if"
  write(ilun,format)"  end if"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  if(pic) then"
  write(ilun,format)""
  write(ilun,format)"  dt_all=dtnew(ilevel); dt_loc=dt_all"
  write(ilun,format)"  ekin_all=0.0; ekin_loc=0.0"
  write(ilun,format)""
  write(ilun,format)"  ! Compute maximum time step on active region"
  write(ilun,format)"  if(numbl(myid,ilevel)>0)then"
  write(ilun,format)"     ! Loop over grids"
  write(ilun,format)"     ip=0"
  write(ilun,format)"     igrid=headl(myid,ilevel)"
  write(ilun,format)"     do jgrid=1,numbl(myid,ilevel)"
  write(ilun,format)"        npart1=numbp(igrid)   ! Number of particles in the grid"
  write(ilun,format)"        if(npart1>0)then"
  write(ilun,format)"           ! Loop over particles"
  write(ilun,format)"           ipart=headp(igrid)"
  write(ilun,format)"           do jpart=1,npart1"
  write(ilun,format)"              ip=ip+1"
  write(ilun,format)"              ind_part(ip)=ipart"
  write(ilun,format)"              if(ip==nvector)then"
  write(ilun,format)"                 call newdt2(ind_part,dt_loc,ekin_loc,ip,ilevel)"
  write(ilun,format)"                 ip=0"
  write(ilun,format)"              end if"
  write(ilun,format)"              ipart=nextp(ipart)    ! Go to next particle"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! End loop over particles"
  write(ilun,format)"        end if"
  write(ilun,format)"        igrid=next(igrid)   ! Go to next grid"
  write(ilun,format)"     end do"
  write(ilun,format)"     ! End loop over grids"
  write(ilun,format)"     if(ip>0)call newdt2(ind_part,dt_loc,ekin_loc,ip,ilevel)"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  ! Minimize time step over all cpus"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  call MPI_ALLREDUCE(dt_loc,dt_all,1,MPI_DOUBLE_PRECISION,MPI_MIN,&"
  write(ilun,format)"       & MPI_COMM_WORLD,info)"
  write(ilun,format)"  call MPI_ALLREDUCE(ekin_loc,ekin_all,1,MPI_DOUBLE_PRECISION,MPI_SUM,&"
  write(ilun,format)"       & MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"#ifdef WITHOUTMPI"
  write(ilun,format)"  dt_all=dt_loc"
  write(ilun,format)"  ekin_all=ekin_loc"
  write(ilun,format)"#endif"
  write(ilun,format)"  ekin_tot=ekin_tot+ekin_all"
  write(ilun,format)"  dtnew(ilevel)=MIN(dtnew(ilevel),dt_all)"
  write(ilun,format)""
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  if(hydro)call courant_fine(ilevel)"
  write(ilun,format)""
  write(ilun,format)"111 format('   Entering newdt_fine for level ',I2)"
  write(ilun,format)""
  write(ilun,format)"end subroutine newdt_fine"
  write(ilun,format)"!#####################################################################"
  write(ilun,format)"!#####################################################################"
  write(ilun,format)"!#####################################################################"
  write(ilun,format)"!#####################################################################"
  write(ilun,format)"subroutine newdt2(ind_part,dt_loc,ekin_loc,nn,ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  real(kind=8)::dt_loc,ekin_loc"
  write(ilun,format)"  integer::nn,ilevel"
  write(ilun,format)"  integer,dimension(1:nvector)::ind_part"
  write(ilun,format)""
  write(ilun,format)"  integer::i,idim,nx_loc"
  write(ilun,format)"  real(dp)::dx,dx_loc,scale,dtpart"
  write(ilun,format)"  real(dp),dimension(1:nvector),save::v2"
  write(ilun,format)""
  write(ilun,format)"  ! Compute time step"
  write(ilun,format)"  dx=0.5D0**ilevel"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)""
  write(ilun,format)"  v2(1:nn)=0.0D0"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do i=1,nn"
  write(ilun,format)"        v2(i)=MAX(v2(i),vp(ind_part(i),idim)**2)"
  write(ilun,format)"!        v2(i)=v2(i)+vp(ind_part(i),idim)**2"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  do i=1,nn"
  write(ilun,format)"     if(v2(i)>0.0D0)then"
  write(ilun,format)"        dtpart=courant_factor*dx_loc/sqrt(v2(i))"
  write(ilun,format)"        dt_loc=MIN(dt_loc,dtpart)"
  write(ilun,format)"     end if"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Compute kinetic energy"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do i=1,nn"
  write(ilun,format)"        ekin_loc=ekin_loc+0.5D0*mp(ind_part(i))*vp(ind_part(i),idim)**2"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"    "
  write(ilun,format)"end subroutine newdt2"
  write(ilun,format)"../patch/hydro/stratified_medium_fx_NSM/output_amr.f90"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"subroutine dump_all"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use cooling_module"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"#if ! defined (WITHOUTMPI) || defined (NOSYSTEM)"
  write(ilun,format)"  integer::info"
  write(ilun,format)"#endif"
  write(ilun,format)"  character::nml_char"
  write(ilun,format)"  character(LEN=5)::nchar,ncharcpu"
  write(ilun,format)"  character(LEN=80)::filename,filename_desc,filedir"
  write(ilun,format)"  integer::ierr"
  write(ilun,format)""
  write(ilun,format)"  if(nstep_coarse==nstep_coarse_old.and.nstep_coarse>0)return"
  write(ilun,format)"  if(nstep_coarse==0.and.nrestart>0)return"
  write(ilun,format)"  if(verbose)write(*,*)'Entering dump_all'"
  write(ilun,format)""
  write(ilun,format)"  call write_screen"
  write(ilun,format)"  call title(ifout,nchar)"
  write(ilun,format)"  ifout=ifout+1"
  write(ilun,format)"  if(t>=tout(iout).or.aexp>=aout(iout))iout=iout+1"
  write(ilun,format)"  output_done=.true."
  write(ilun,format)""
  write(ilun,format)"  if(IOGROUPSIZEREP>0)call title(((myid-1)/IOGROUPSIZEREP)+1,ncharcpu)"
  write(ilun,format)""
  write(ilun,format)"  if(ndim>1)then"
  write(ilun,format)""
  write(ilun,format)"     if(IOGROUPSIZEREP>0) then"
  write(ilun,format)"        filedir='output_'//TRIM(nchar)//'/group_'//TRIM(ncharcpu)//'/'"
  write(ilun,format)"     else"
  write(ilun,format)"        filedir='output_'//TRIM(nchar)//'/'"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     call create_output_dirs(filedir)"
  write(ilun,format)""
  write(ilun,format)"     if(myid==1.and.print_when_io) write(*,*)'Start backup header'"
  write(ilun,format)"     ! Output header: must be called by each process !"
  write(ilun,format)"     filename=TRIM(filedir)//'header_'//TRIM(nchar)//'.txt'"
  write(ilun,format)"     call output_header(filename)"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     if(synchro_when_io) call MPI_BARRIER(MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"     if(myid==1.and.print_when_io) write(*,*)'End backup header'"
  write(ilun,format)""
  write(ilun,format)"     if(myid==1.and.print_when_io) write(*,*)'Start backup info etc.'"
  write(ilun,format)"     ! Only master process"
  write(ilun,format)"     if(myid==1)then"
  write(ilun,format)"        filename=TRIM(filedir)//'info_'//TRIM(nchar)//'.txt'"
  write(ilun,format)"        call output_info(filename)"
  write(ilun,format)"        filename=TRIM(filedir)//'makefile.txt'"
  write(ilun,format)"        call output_makefile(filename)"
  write(ilun,format)"        filename=TRIM(filedir)//'patches.txt'"
  write(ilun,format)"        call output_patch(filename)"
  write(ilun,format)"        if(cooling .and. .not. neq_chem)then"
  write(ilun,format)"           filename=TRIM(filedir)//'cooling_'//TRIM(nchar)//'.out'"
  write(ilun,format)"           call output_cool(filename)"
  write(ilun,format)"        end if"
  write(ilun,format)"        if(sink)then"
  write(ilun,format)"           filename=TRIM(filedir)//'sink_'//TRIM(nchar)//'.info'"
  write(ilun,format)"           call output_sink(filename)"
  write(ilun,format)"           filename=TRIM(filedir)//'sink_'//TRIM(nchar)//'.csv'"
  write(ilun,format)"           call output_sink_csv(filename)"
  write(ilun,format)"        endif"
  write(ilun,format)"        ! Copy namelist file to output directory"
  write(ilun,format)"        filename=TRIM(filedir)//'namelist.txt'"
  write(ilun,format)"        OPEN(10, FILE=namelist_file, ACCESS='STREAM', ACTION='READ')"
  write(ilun,format)"        OPEN(11, FILE=filename,      ACCESS='STREAM', ACTION='WRITE')"
  write(ilun,format)"        DO"
  write(ilun,format)"           READ(10, IOSTAT=IERR)nml_char"
  write(ilun,format)"           IF (IERR.NE.0) EXIT"
  write(ilun,format)"           WRITE(11)nml_char"
  write(ilun,format)"        END DO"
  write(ilun,format)"        CLOSE(11)"
  write(ilun,format)"        CLOSE(10)"
  write(ilun,format)"        ! Copy compilation details to output directory"
  write(ilun,format)"        filename=TRIM(filedir)//'compilation.txt'"
  write(ilun,format)"        OPEN(UNIT=11, FILE=filename, FORM='formatted')"
  write(ilun,format)"        write(11,'(' compile date = ',A)')TRIM(builddate)"
  write(ilun,format)"        write(11,'(' patch dir    = ',A)')TRIM(patchdir)"
  write(ilun,format)"        write(11,'(' remote repo  = ',A)')TRIM(gitrepo)"
  write(ilun,format)"        write(11,'(' local branch = ',A)')TRIM(gitbranch)"
  write(ilun,format)"        write(11,'(' last commit  = ',A)')TRIM(githash)"
  write(ilun,format)"        CLOSE(11)"
  write(ilun,format)"     endif"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     if(synchro_when_io) call MPI_BARRIER(MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"     if(myid==1.and.print_when_io) write(*,*)'End backup info etc.'"
  write(ilun,format)""
  write(ilun,format)"     if(myid==1.and.print_when_io) write(*,*)'Start backup amr'"
  write(ilun,format)"     filename=TRIM(filedir)//'amr_'//TRIM(nchar)//'.out'"
  write(ilun,format)"     call backup_amr(filename)"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     if(synchro_when_io) call MPI_BARRIER(MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"     if(myid==1.and.print_when_io) write(*,*)'End backup amr'"
  write(ilun,format)""
  write(ilun,format)"     if(hydro)then"
  write(ilun,format)"        if(myid==1.and.print_when_io) write(*,*)'Start backup hydro'"
  write(ilun,format)"        filename=TRIM(filedir)//'hydro_'//TRIM(nchar)//'.out'"
  write(ilun,format)"        filename_desc = trim(filedir)//'hydro_file_descriptor.txt'"
  write(ilun,format)"        call backup_hydro(filename, filename_desc)"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"        if(synchro_when_io) call MPI_BARRIER(MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"        if(myid==1.and.print_when_io) write(*,*)'End backup hydro'"
  write(ilun,format)"     end if"
  write(ilun,format)""
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"     if(rt.or.neq_chem)then"
  write(ilun,format)"        if(myid==1.and.print_when_io) write(*,*)'Start backup rt'"
  write(ilun,format)"        filename=TRIM(filedir)//'rt_'//TRIM(nchar)//'.out'"
  write(ilun,format)"        filename_desc = trim(filedir) // 'rt_file_descriptor.txt'"
  write(ilun,format)"        call rt_backup_hydro(filename, filename_desc)"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"        if(synchro_when_io) call MPI_BARRIER(MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"        if(myid==1.and.print_when_io) write(*,*)'End backup rt'"
  write(ilun,format)"     endif"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"     if(pic)then"
  write(ilun,format)"        if(myid==1.and.print_when_io) write(*,*)'Start backup part'"
  write(ilun,format)"        filename=trim(filedir)//'part_'//trim(nchar)//'.out'"
  write(ilun,format)"        filename_desc=TRIM(filedir)//'part_file_descriptor.txt'"
  write(ilun,format)"        call backup_part(filename, filename_desc)"
  write(ilun,format)"        if(sink)then"
  write(ilun,format)"           filename=TRIM(filedir)//'sink_'//TRIM(nchar)//'.out'"
  write(ilun,format)"           call backup_sink(filename)"
  write(ilun,format)"        end if"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"        if(synchro_when_io) call MPI_BARRIER(MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"        if(myid==1.and.print_when_io) write(*,*)'End backup part'"
  write(ilun,format)"     end if"
  write(ilun,format)""
  write(ilun,format)"     if(poisson)then"
  write(ilun,format)"        if(myid==1.and.print_when_io) write(*,*)'Start backup poisson'"
  write(ilun,format)"        filename=TRIM(filedir)//'grav_'//TRIM(nchar)//'.out'"
  write(ilun,format)"        call backup_poisson(filename)"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"        if(synchro_when_io) call MPI_BARRIER(MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"        if(myid==1.and.print_when_io) write(*,*)'End backup poisson'"
  write(ilun,format)"     end if"
  write(ilun,format)"#ifdef ATON"
  write(ilun,format)"     if(aton)then"
  write(ilun,format)"        if(myid==1.and.print_when_io) write(*,*)'Start backup rad'"
  write(ilun,format)"        filename=TRIM(filedir)//'rad_'//TRIM(nchar)//'.out'"
  write(ilun,format)"        call backup_radiation(filename)"
  write(ilun,format)"        filename=TRIM(filedir)//'radgpu_'//TRIM(nchar)//'.out'"
  write(ilun,format)"        call store_radiation(filename)"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"        if(synchro_when_io) call MPI_BARRIER(MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"        if(myid==1.and.print_when_io) write(*,*)'End backup rad'"
  write(ilun,format)"     end if"
  write(ilun,format)"#endif"
  write(ilun,format)"     if (gadget_output) then"
  write(ilun,format)"        if(myid==1.and.print_when_io) write(*,*)'Start backup gadget format'"
  write(ilun,format)"        filename=TRIM(filedir)//'gsnapshot_'//TRIM(nchar)"
  write(ilun,format)"        call savegadget(filename)"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"        if(synchro_when_io) call MPI_BARRIER(MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"        if(myid==1.and.print_when_io) write(*,*)'End backup gadget format'"
  write(ilun,format)"     end if"
  write(ilun,format)""
  write(ilun,format)"     if(myid==1.and.print_when_io) write(*,*)'Start timer'"
  write(ilun,format)"     ! Output timer: must be called by each process !"
  write(ilun,format)"     filename=TRIM(filedir)//'timer_'//TRIM(nchar)//'.txt'"
  write(ilun,format)"     call output_timer(.true., filename)"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     if(synchro_when_io) call MPI_BARRIER(MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"     if(myid==1.and.print_when_io) write(*,*)'End output timer'"
  write(ilun,format)""
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"end subroutine dump_all"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"subroutine backup_amr(filename)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"  integer::dummy_io,info2"
  write(ilun,format)"#endif"
  write(ilun,format)"  character(LEN=80)::filename"
  write(ilun,format)""
  write(ilun,format)"  integer::nx_loc,ny_loc,nz_loc,ilun"
  write(ilun,format)"  integer::ilevel,ibound,ncache,istart,i,igrid,idim,ind,iskip"
  write(ilun,format)"  integer,allocatable,dimension(:)::ind_grid,iig"
  write(ilun,format)"  real(dp),allocatable,dimension(:)::xdp"
  write(ilun,format)"  real(dp),dimension(1:3)::skip_loc"
  write(ilun,format)"  character(LEN=80)::fileloc"
  write(ilun,format)"  character(LEN=5)::nchar"
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v"
  write(ilun,format)"  real(dp)::scale"
  write(ilun,format)"  integer,parameter::tag=1120"
  write(ilun,format)""
  write(ilun,format)"  if(verbose)write(*,*)'Entering backup_amr'"
  write(ilun,format)""
  write(ilun,format)"  ! Conversion factor from user units to cgs units"
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)""
  write(ilun,format)"  ! Local constants"
  write(ilun,format)"  nx_loc=nx; ny_loc=ny; nz_loc=nz"
  write(ilun,format)"  if(ndim>0)nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  if(ndim>1)ny_loc=(jcoarse_max-jcoarse_min+1)"
  write(ilun,format)"  if(ndim>2)nz_loc=(kcoarse_max-kcoarse_min+1)"
  write(ilun,format)"  skip_loc=(/0.0d0,0.0d0,0.0d0/)"
  write(ilun,format)"  if(ndim>0)skip_loc(1)=dble(icoarse_min)"
  write(ilun,format)"  if(ndim>1)skip_loc(2)=dble(jcoarse_min)"
  write(ilun,format)"  if(ndim>2)skip_loc(3)=dble(kcoarse_min)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)""
  write(ilun,format)"  !-----------------------------------"
  write(ilun,format)"  ! Output amr grid in file"
  write(ilun,format)"  !-----------------------------------"
  write(ilun,format)"  ilun=myid+10"
  write(ilun,format)"  call title(myid,nchar)"
  write(ilun,format)"  fileloc=TRIM(filename)//TRIM(nchar)"
  write(ilun,format)""
  write(ilun,format)"   ! Wait for the token"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     if(IOGROUPSIZE>0) then"
  write(ilun,format)"        if (mod(myid-1,IOGROUPSIZE)/=0) then"
  write(ilun,format)"           call MPI_RECV(dummy_io,1,MPI_INTEGER,myid-1-1,tag,&"
  write(ilun,format)"                & MPI_COMM_WORLD,MPI_STATUS_IGNORE,info2)"
  write(ilun,format)"        end if"
  write(ilun,format)"     endif"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  open(unit=ilun,file=fileloc,form='unformatted')"
  write(ilun,format)"  ! Write grid variables"
  write(ilun,format)"  write(ilun)ncpu"
  write(ilun,format)"  write(ilun)ndim"
  write(ilun,format)"  write(ilun)nx,ny,nz"
  write(ilun,format)"  write(ilun)nlevelmax"
  write(ilun,format)"  write(ilun)ngridmax"
  write(ilun,format)"  write(ilun)nboundary"
  write(ilun,format)"  write(ilun)ngrid_current"
  write(ilun,format)"  write(ilun)boxlen"
  write(ilun,format)"  ! Write time variables"
  write(ilun,format)"  write(ilun)noutput,iout,ifout"
  write(ilun,format)"  write(ilun)tout(1:noutput)"
  write(ilun,format)"  write(ilun)aout(1:noutput)"
  write(ilun,format)"  write(ilun)t"
  write(ilun,format)"  write(ilun)dtold(1:nlevelmax)"
  write(ilun,format)"  write(ilun)dtnew(1:nlevelmax)"
  write(ilun,format)"  write(ilun)nstep,nstep_coarse"
  write(ilun,format)"  write(ilun)einit,mass_tot_0,rho_tot"
  write(ilun,format)"  write(ilun)omega_m,omega_l,omega_k,omega_b,h0,aexp_ini,boxlen_ini"
  write(ilun,format)"  write(ilun)aexp,hexp,aexp_old,epot_tot_int,epot_tot_old"
  write(ilun,format)"  write(ilun)mass_sph"
  write(ilun,format)"  ! Write levels variables"
  write(ilun,format)"  write(ilun)headl(1:ncpu,1:nlevelmax)"
  write(ilun,format)"  write(ilun)taill(1:ncpu,1:nlevelmax)"
  write(ilun,format)"  write(ilun)numbl(1:ncpu,1:nlevelmax)"
  write(ilun,format)"  write(ilun)numbtot(1:10,1:nlevelmax)"
  write(ilun,format)"  ! Read boundary linked list"
  write(ilun,format)"  if(simple_boundary)then"
  write(ilun,format)"     write(ilun)headb(1:nboundary,1:nlevelmax)"
  write(ilun,format)"     write(ilun)tailb(1:nboundary,1:nlevelmax)"
  write(ilun,format)"     write(ilun)numbb(1:nboundary,1:nlevelmax)"
  write(ilun,format)"  end if"
  write(ilun,format)"  ! Write free memory"
  write(ilun,format)"  write(ilun)headf,tailf,numbf,used_mem,used_mem_tot"
  write(ilun,format)"  ! Write cpu boundaries"
  write(ilun,format)"  write(ilun)ordering"
  write(ilun,format)"  if(ordering=='bisection') then"
  write(ilun,format)"     write(ilun)bisec_wall(1:nbinodes)"
  write(ilun,format)"     write(ilun)bisec_next(1:nbinodes,1:2)"
  write(ilun,format)"     write(ilun)bisec_indx(1:nbinodes)"
  write(ilun,format)"     write(ilun)bisec_cpubox_min(1:ncpu,1:ndim)"
  write(ilun,format)"     write(ilun)bisec_cpubox_max(1:ncpu,1:ndim)"
  write(ilun,format)"  else"
  write(ilun,format)"     write(ilun)bound_key(0:ndomain)"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  ! Write coarse level"
  write(ilun,format)"  write(ilun)son(1:ncoarse)"
  write(ilun,format)"  write(ilun)flag1(1:ncoarse)"
  write(ilun,format)"  write(ilun)cpu_map(1:ncoarse)"
  write(ilun,format)"  ! Write fine levels"
  write(ilun,format)"  do ilevel=1,nlevelmax"
  write(ilun,format)"     do ibound=1,nboundary+ncpu"
  write(ilun,format)"        if(ibound<=ncpu)then"
  write(ilun,format)"           ncache=numbl(ibound,ilevel)"
  write(ilun,format)"           istart=headl(ibound,ilevel)"
  write(ilun,format)"        else"
  write(ilun,format)"           ncache=numbb(ibound-ncpu,ilevel)"
  write(ilun,format)"           istart=headb(ibound-ncpu,ilevel)"
  write(ilun,format)"        end if"
  write(ilun,format)"        if(ncache>0)then"
  write(ilun,format)"           allocate(ind_grid(1:ncache),xdp(1:ncache),iig(1:ncache))"
  write(ilun,format)"           ! Write grid index"
  write(ilun,format)"           igrid=istart"
  write(ilun,format)"           do i=1,ncache"
  write(ilun,format)"              ind_grid(i)=igrid"
  write(ilun,format)"              igrid=next(igrid)"
  write(ilun,format)"           end do"
  write(ilun,format)"           write(ilun)ind_grid"
  write(ilun,format)"           ! Write next index"
  write(ilun,format)"           do i=1,ncache"
  write(ilun,format)"              iig(i)=next(ind_grid(i))"
  write(ilun,format)"           end do"
  write(ilun,format)"           write(ilun)iig"
  write(ilun,format)"           ! Write prev index"
  write(ilun,format)"           do i=1,ncache"
  write(ilun,format)"              iig(i)=prev(ind_grid(i))"
  write(ilun,format)"           end do"
  write(ilun,format)"           write(ilun)iig"
  write(ilun,format)"           ! Write grid center"
  write(ilun,format)"           do idim=1,ndim"
  write(ilun,format)"              do i=1,ncache"
  write(ilun,format)"                 xdp(i)=xg(ind_grid(i),idim)"
  write(ilun,format)"              end do"
  write(ilun,format)"              write(ilun)xdp"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! Write father index"
  write(ilun,format)"           do i=1,ncache"
  write(ilun,format)"              iig(i)=father(ind_grid(i))"
  write(ilun,format)"           end do"
  write(ilun,format)"           write(ilun)iig"
  write(ilun,format)"           ! Write nbor index"
  write(ilun,format)"           do ind=1,twondim"
  write(ilun,format)"              do i=1,ncache"
  write(ilun,format)"                 iig(i)=nbor(ind_grid(i),ind)"
  write(ilun,format)"              end do"
  write(ilun,format)"              write(ilun)iig"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! Write son index"
  write(ilun,format)"           do ind=1,twotondim"
  write(ilun,format)"              iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"              do i=1,ncache"
  write(ilun,format)"                 iig(i)=son(ind_grid(i)+iskip)"
  write(ilun,format)"              end do"
  write(ilun,format)"              write(ilun)iig"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! Write cpu map"
  write(ilun,format)"           do ind=1,twotondim"
  write(ilun,format)"              iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"              do i=1,ncache"
  write(ilun,format)"                 iig(i)=cpu_map(ind_grid(i)+iskip)"
  write(ilun,format)"              end do"
  write(ilun,format)"              write(ilun)iig"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! Write refinement map"
  write(ilun,format)"           do ind=1,twotondim"
  write(ilun,format)"              iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"              do i=1,ncache"
  write(ilun,format)"                 iig(i)=flag1(ind_grid(i)+iskip)"
  write(ilun,format)"              end do"
  write(ilun,format)"              write(ilun)iig"
  write(ilun,format)"           end do"
  write(ilun,format)"           deallocate(xdp,iig,ind_grid)"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  close(ilun)"
  write(ilun,format)""
  write(ilun,format)"  ! Send the token"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  if(IOGROUPSIZE>0) then"
  write(ilun,format)"     if(mod(myid,IOGROUPSIZE)/=0 .and.(myid.lt.ncpu))then"
  write(ilun,format)"        dummy_io=1"
  write(ilun,format)"        call MPI_SEND(dummy_io,1,MPI_INTEGER,myid-1+1,tag, &"
  write(ilun,format)"             & MPI_COMM_WORLD,info2)"
  write(ilun,format)"     end if"
  write(ilun,format)"  endif"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"end subroutine backup_amr"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"subroutine output_info(filename)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  character(LEN=80)::filename"
  write(ilun,format)""
  write(ilun,format)"  integer::nx_loc,ny_loc,nz_loc,ilun,icpu,idom,ierr"
  write(ilun,format)"  real(dp)::scale"
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v"
  write(ilun,format)"  character(LEN=80)::fileloc"
  write(ilun,format)""
  write(ilun,format)"  if(verbose)write(*,*)'Entering output_info'"
  write(ilun,format)""
  write(ilun,format)"  ilun=11"
  write(ilun,format)""
  write(ilun,format)"  ! Conversion factor from user units to cgs units"
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)""
  write(ilun,format)"  ! Local constants"
  write(ilun,format)"  nx_loc=nx; ny_loc=ny; nz_loc=nz"
  write(ilun,format)"  if(ndim>0)nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  if(ndim>1)ny_loc=(jcoarse_max-jcoarse_min+1)"
  write(ilun,format)"  if(ndim>2)nz_loc=(kcoarse_max-kcoarse_min+1)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)""
  write(ilun,format)"  ! Open file"
  write(ilun,format)"  fileloc=TRIM(filename)"
  write(ilun,format)"  open(unit=ilun,file=fileloc,form='formatted',iostat=ierr)"
  write(ilun,format)"  if(ierr .ne. 0)then"
  write(ilun,format)"     write(*,*) 'Error - Could not write ',fileloc"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     call MPI_ABORT(MPI_COMM_WORLD,1,ierr)"
  write(ilun,format)"#else"
  write(ilun,format)"     stop"
  write(ilun,format)"#endif"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  ! Write run parameters"
  write(ilun,format)"  write(ilun,'('ncpu        =',I11)')ncpu"
  write(ilun,format)"  write(ilun,'('ndim        =',I11)')ndim"
  write(ilun,format)"  write(ilun,'('levelmin    =',I11)')levelmin"
  write(ilun,format)"  write(ilun,'('levelmax    =',I11)')nlevelmax"
  write(ilun,format)"  write(ilun,'('ngridmax    =',I11)')ngridmax"
  write(ilun,format)"  write(ilun,'('nstep_coarse=',I11)')nstep_coarse"
  write(ilun,format)"  write(ilun,*)"
  write(ilun,format)""
  write(ilun,format)"  ! Write physical parameters"
  write(ilun,format)"  write(ilun,'('boxlen      =',E23.15)')scale"
  write(ilun,format)"  write(ilun,'('time        =',E23.15)')t"
  write(ilun,format)"  write(ilun,'('aexp        =',E23.15)')aexp"
  write(ilun,format)"  write(ilun,'('H0          =',E23.15)')h0"
  write(ilun,format)"  write(ilun,'('omega_m     =',E23.15)')omega_m"
  write(ilun,format)"  write(ilun,'('omega_l     =',E23.15)')omega_l"
  write(ilun,format)"  write(ilun,'('omega_k     =',E23.15)')omega_k"
  write(ilun,format)"  write(ilun,'('omega_b     =',E23.15)')omega_b"
  write(ilun,format)"  write(ilun,'('unit_l      =',E23.15)')scale_l"
  write(ilun,format)"  write(ilun,'('unit_d      =',E23.15)')scale_d"
  write(ilun,format)"  write(ilun,'('unit_t      =',E23.15)')scale_t"
  write(ilun,format)"  write(ilun,*)"
  write(ilun,format)""
  write(ilun,format)"  ! Write ordering information"
  write(ilun,format)"  write(ilun,'('ordering type=',A80)')ordering"
  write(ilun,format)"  if(ordering=='bisection') then"
  write(ilun,format)"     do icpu=1,ncpu"
  write(ilun,format)"        ! write 2*ndim floats for cpu bound box"
  write(ilun,format)"        write(ilun,'(E23.15)')bisec_cpubox_min(icpu,:),bisec_cpubox_max(icpu,:)"
  write(ilun,format)"        ! write 1 float for cpu load"
  write(ilun,format)"        write(ilun,'(E23.15)')dble(bisec_cpu_load(icpu))"
  write(ilun,format)"     end do"
  write(ilun,format)"  else"
  write(ilun,format)"     write(ilun,'('   DOMAIN   ind_min                 ind_max')')"
  write(ilun,format)"     do idom=1,ndomain"
  write(ilun,format)"        write(ilun,'(I8,1X,E23.15,1X,E23.15)')idom,bound_key(idom-1),bound_key(idom)"
  write(ilun,format)"     end do"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  close(ilun)"
  write(ilun,format)""
  write(ilun,format)"end subroutine output_info"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"subroutine output_header(filename)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"  integer::info"
  write(ilun,format)"#endif"
  write(ilun,format)"  character(LEN=80)::filename"
  write(ilun,format)""
  write(ilun,format)"  integer::ilun"
  write(ilun,format)"  character(LEN=80)::fileloc"
  write(ilun,format)"#ifdef LONGINT"
  write(ilun,format)"  integer(i8b)::npart_family_loc(-5:5), npart_family(-5:5), npart_all_loc, npart_all"
  write(ilun,format)"#else"
  write(ilun,format)"  integer::npart_family_loc(-5:5), npart_family(-5:5), npart_all_loc, npart_all"
  write(ilun,format)"#endif"
  write(ilun,format)"  integer :: ifam, ipart"
  write(ilun,format)""
  write(ilun,format)"  if(verbose)write(*,*)'Entering output_header'"
  write(ilun,format)"  if(myid==1)then"
  write(ilun,format)"     ! Open file"
  write(ilun,format)"     fileloc=TRIM(filename)"
  write(ilun,format)"     open(newunit=ilun,file=fileloc,form='formatted')"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  ! Compute total number of particles"
  write(ilun,format)"  ! Count number of particles"
  write(ilun,format)"  npart_family_loc = 0; npart_all_loc = 0"
  write(ilun,format)"  do ipart = 1, npartmax"
  write(ilun,format)"     ! Only used particles have a levelp > 0"
  write(ilun,format)"     if (levelp(ipart) > 0) then"
  write(ilun,format)"        npart_all_loc = npart_all_loc + 1"
  write(ilun,format)"        do ifam = -5, 5"
  write(ilun,format)"           if (typep(ipart)%family == ifam) then"
  write(ilun,format)"              npart_family_loc(ifam) = npart_family_loc(ifam) + 1"
  write(ilun,format)"           end if"
  write(ilun,format)"        end do"
  write(ilun,format)"     end if"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"#ifdef LONGINT"
  write(ilun,format)"  call MPI_ALLREDUCE(npart_family_loc,npart_family,11,MPI_INTEGER8,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"  call MPI_ALLREDUCE(npart_all_loc,npart_all,1,MPI_INTEGER8,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"#else"
  write(ilun,format)"  call MPI_ALLREDUCE(npart_family_loc,npart_family,11,MPI_INTEGER,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"  call MPI_ALLREDUCE(npart_all_loc,npart_all,1,MPI_INTEGER,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"#else"
  write(ilun,format)"  npart_family = npart_family_loc"
  write(ilun,format)"  npart_all = npart_all_loc"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  if (myid == 1) then"
  write(ilun,format)"     write(ilun, '(a1,a12,a10)') '#', 'Family', 'Count'"
  write(ilun,format)"     do ifam = -NFAMILIES, NFAMILIES"
  write(ilun,format)"        write(ilun, '(a13, i10)') &"
  write(ilun,format)"             trim(particle_family_keys(ifam)), npart_family(ifam)"
  write(ilun,format)"     end do"
  write(ilun,format)"     write(ilun, '(a13, i10)') &"
  write(ilun,format)"          'undefined', npart_all - sum(npart_family)"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  if (myid == 1) then"
  write(ilun,format)"     ! Keep track of what particle fields are present"
  write(ilun,format)"     write(ilun,*)'Particle fields'"
  write(ilun,format)"     write(ilun,'(a)',advance='no')'pos vel mass iord level family tag '"
  write(ilun,format)"#ifdef OUTPUT_PARTICLE_POTENTIAL"
  write(ilun,format)"     write(ilun,'(a)',advance='no')'phi '"
  write(ilun,format)"#endif"
  write(ilun,format)"     if(star.or.sink) then"
  write(ilun,format)"        write(ilun,'(a)',advance='no')'tform '"
  write(ilun,format)"        if(metal) then"
  write(ilun,format)"           write(ilun,'(a)',advance='no')'metal '"
  write(ilun,format)"        endif"
  write(ilun,format)"     endif"
  write(ilun,format)"     close(ilun)"
  write(ilun,format)""
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"end subroutine output_header"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"subroutine savegadget(filename)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use gadgetreadfilemod"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"  integer::info"
  write(ilun,format)"  integer(i8b)::npart_loc"
  write(ilun,format)"#endif"
  write(ilun,format)"  character(LEN=80)::filename"
  write(ilun,format)"  TYPE(gadgetheadertype)::header"
  write(ilun,format)"  real,allocatable,dimension(:,:)::pos,vel"
  write(ilun,format)"  integer(i8b),allocatable,dimension(:)::ids"
  write(ilun,format)"  integer::i,idim,ipart"
  write(ilun,format)"  real(dp)::gadgetvfact"
  write(ilun,format)"  integer(i8b)::npart_tot"
  write(ilun,format)"  real(dp),parameter::RHOcrit=2.7755d11"
  write(ilun,format)""
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  npart_loc=npart"
  write(ilun,format)"#ifndef LONGINT"
  write(ilun,format)"  call MPI_ALLREDUCE(npart_loc,npart_tot,1,MPI_INTEGER,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"#else"
  write(ilun,format)"  call MPI_ALLREDUCE(npart_loc,npart_tot,1,MPI_INTEGER8,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"#else"
  write(ilun,format)"  npart_tot=npart"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  allocate(pos(ndim, npart), vel(ndim, npart), ids(npart))"
  write(ilun,format)"  gadgetvfact = 100.0 * boxlen_ini / aexp / SQRT(aexp)"
  write(ilun,format)""
  write(ilun,format)"  header%npart = 0"
  write(ilun,format)"  header%npart(2) = npart"
  write(ilun,format)"  header%mass = 0"
  write(ilun,format)"  header%mass(2) = omega_m*RHOcrit*(boxlen_ini)**3/npart_tot/1.d10"
  write(ilun,format)"  header%time = aexp"
  write(ilun,format)"  header%redshift = 1.d0/aexp-1.d0"
  write(ilun,format)"  header%flag_sfr = 0"
  write(ilun,format)"  header%nparttotal = 0"
  write(ilun,format)"#ifndef LONGINT"
  write(ilun,format)"  header%nparttotal(2) = npart_tot"
  write(ilun,format)"#else"
  write(ilun,format)"  header%nparttotal(2) = MOD(npart_tot,4294967296_i8b)"
  write(ilun,format)"#endif"
  write(ilun,format)"  header%flag_cooling = 0"
  write(ilun,format)"  header%numfiles = ncpu"
  write(ilun,format)"  header%boxsize = boxlen_ini"
  write(ilun,format)"  header%omega0 = omega_m"
  write(ilun,format)"  header%omegalambda = omega_l"
  write(ilun,format)"  header%hubbleparam = h0/100.0"
  write(ilun,format)"  header%flag_stellarage = 0"
  write(ilun,format)"  header%flag_metals = 0"
  write(ilun,format)"  header%totalhighword = 0"
  write(ilun,format)"#ifndef LONGINT"
  write(ilun,format)"  header%totalhighword(2) = 0"
  write(ilun,format)"#else"
  write(ilun,format)"  header%totalhighword(2) = npart_tot/4294967296_i8b"
  write(ilun,format)"#endif"
  write(ilun,format)"  header%flag_entropy_instead_u = 0"
  write(ilun,format)"  header%flag_doubleprecision = 0"
  write(ilun,format)"  header%flag_ic_info = 0"
  write(ilun,format)"  header%lpt_scalingfactor = 0"
  write(ilun,format)"  header%unused = ' '"
  write(ilun,format)""
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     ipart=0"
  write(ilun,format)"     do i=1,npartmax"
  write(ilun,format)"        if(levelp(i)>0)then"
  write(ilun,format)"           ipart=ipart+1"
  write(ilun,format)"           if (ipart .gt. npart) then"
  write(ilun,format)"                write(*,*) myid, 'Ipart=',ipart, 'exceeds', npart"
  write(ilun,format)"                call clean_stop"
  write(ilun,format)"           endif"
  write(ilun,format)"           pos(idim, ipart)=real(xp(i,idim) * boxlen_ini , kind=4)"
  write(ilun,format)"           vel(idim, ipart)=real(vp(i,idim) * gadgetvfact , kind=4)"
  write(ilun,format)"           if (idim.eq.1) ids(ipart) = idp(i)"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  call gadgetwritefile(filename, myid-1, header, pos, vel, ids)"
  write(ilun,format)"  deallocate(pos, vel, ids)"
  write(ilun,format)""
  write(ilun,format)"end subroutine savegadget"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"subroutine create_output_dirs(filedir)"
  write(ilun,format)""
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  character(LEN=80), intent(in):: filedir"
  write(ilun,format)"  integer :: ierr"
  write(ilun,format)"  character(LEN=80)::filecmd"
  write(ilun,format)"#ifdef NOSYSTEM"
  write(ilun,format)"  character(LEN=80)::filedirini"
  write(ilun,format)"#endif"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"  integer :: info"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  filecmd='mkdir -p '//TRIM(filedir)"
  write(ilun,format)""
  write(ilun,format)"  if (.not.withoutmkdir) then"
  write(ilun,format)"#ifdef NOSYSTEM"
  write(ilun,format)"    filedirini = filedir(1:13)"
  write(ilun,format)"    call PXFMKDIR(TRIM(filedirini),LEN(TRIM(filedirini)),O'755',info)"
  write(ilun,format)"    call PXFMKDIR(TRIM(filedir),LEN(TRIM(filedir)),O'755',info)"
  write(ilun,format)"#else"
  write(ilun,format)"    call EXECUTE_COMMAND_LINE(filecmd,exitstat=ierr,wait=.true.)"
  write(ilun,format)"    if(ierr.ne.0 .and. ierr.ne.127)then"
  write(ilun,format)"      write(*,*) 'Error - Could not create ',trim(filedir),' error code=',ierr"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"      call MPI_ABORT(MPI_COMM_WORLD,1,info)"
  write(ilun,format)"#else"
  write(ilun,format)"      stop"
  write(ilun,format)"#endif"
  write(ilun,format)"    endif"
  write(ilun,format)"#endif"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  call MPI_BARRIER(MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"end subroutine create_output_dirs"
  write(ilun,format)"../patch/hydro/stratified_medium_fx_NSM/read_hydro_params.f90"
  write(ilun,format)"subroutine read_hydro_params(nml_ok)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  logical::nml_ok"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  ! Local variables  "
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  integer::i,idim,nboundary_true=0"
  write(ilun,format)"  integer ,dimension(1:MAXBOUND)::bound_type"
  write(ilun,format)"  real(dp)::scale,ek_bound"
  write(ilun,format)""
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  ! Namelist definitions"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  namelist/init_params/filetype,initfile,multiple,nregion,region_type &"
  write(ilun,format)"       & ,x_center,y_center,z_center,aexp_ini &"
  write(ilun,format)"       & ,length_x,length_y,length_z,exp_region &"
  write(ilun,format)"#if NENER>0"
  write(ilun,format)"       & ,prad_region &"
  write(ilun,format)"#endif"
  write(ilun,format)"       & ,d_region,u_region,v_region,w_region,p_region"
  write(ilun,format)"  namelist/hydro_params/gamma,courant_factor,smallr,smallc &"
  write(ilun,format)"       & ,niter_riemann,slope_type,difmag,T_limit &"
  write(ilun,format)"#if NENER>0"
  write(ilun,format)"       & ,gamma_rad &"
  write(ilun,format)"#endif"
  write(ilun,format)"       & ,pressure_fix,beta_fix,scheme,riemann"
  write(ilun,format)"  namelist/refine_params/x_refine,y_refine,z_refine,r_refine &"
  write(ilun,format)"       & ,a_refine,b_refine,exp_refine,jeans_refine,mass_cut_refine &"
  write(ilun,format)"       & ,m_refine,mass_sph,err_grad_d,err_grad_p,err_grad_u &"
  write(ilun,format)"       & ,floor_d,floor_u,floor_p,ivar_refine,var_cut_refine &"
  write(ilun,format)"       & ,interpol_var,interpol_type,sink_refine"
  write(ilun,format)"  namelist/boundary_params/nboundary,bound_type &"
  write(ilun,format)"       & ,ibound_min,ibound_max,jbound_min,jbound_max &"
  write(ilun,format)"       & ,kbound_min,kbound_max &"
  write(ilun,format)"       & ,d_bound,u_bound,v_bound,w_bound,p_bound,no_inflow"
  write(ilun,format)"  namelist/physics_params/cooling,haardt_madau,metal,isothermal &"
  write(ilun,format)"       & ,m_star,t_star,n_star,T2_star,g_star,del_star,eps_star,jeans_ncells &"
  write(ilun,format)"       & ,eta_sn,yield,yield_Ia_Fe, yield_cc_Fe, yield_NSM_Fe, yield_Ia_alpha, yield_cc_alpha, yield_NSM_alpha, yield_Ia_rp, yield_cc_rp, yield_NSM_rp,rbubble,f_ek,ndebris,f_w,mass_gmc,kappa_IR &"
  write(ilun,format)"       & ,J21,a_spec,z_ave,z_ave_alpha, z_ave_rp ,z_reion,ind_rsink,delayed_cooling &"
  write(ilun,format)"       & ,self_shielding,smbh,agn &"
  write(ilun,format)"       & ,units_density,units_time,units_length,neq_chem,ir_feedback,ir_eff,t_diss,t_sne"
  write(ilun,format)""
  write(ilun,format)"  ! Read namelist file"
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"  read(1,NML=init_params,END=101)"
  write(ilun,format)"  goto 102"
  write(ilun,format)"101 write(*,*)' You need to set up namelist &INIT_PARAMS in parameter file'"
  write(ilun,format)"  call clean_stop"
  write(ilun,format)"102 rewind(1)"
  write(ilun,format)"  if(nlevelmax>levelmin)read(1,NML=refine_params)"
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"  if(hydro)read(1,NML=hydro_params)"
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"  read(1,NML=boundary_params,END=103)"
  write(ilun,format)"  simple_boundary=.true."
  write(ilun,format)"  goto 104"
  write(ilun,format)"103 simple_boundary=.false."
  write(ilun,format)"104 if(nboundary>MAXBOUND)then"
  write(ilun,format)"    write(*,*) 'Error: nboundary>MAXBOUND'"
  write(ilun,format)"    call clean_stop"
  write(ilun,format)"  end if"
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"  read(1,NML=physics_params,END=105)"
  write(ilun,format)"105 continue"
  write(ilun,format)"#ifdef ATON"
  write(ilun,format)"  if(aton)call read_radiation_params(1)"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  ! Check for star formation"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  if(t_star>0)then"
  write(ilun,format)"     star=.true."
  write(ilun,format)"     pic=.true."
  write(ilun,format)"  else if(eps_star>0)then"
  write(ilun,format)"     t_star=0.1635449*(n_star/0.1)**(-0.5)/eps_star"
  write(ilun,format)"     star=.true."
  write(ilun,format)"     pic=.true."
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  ! Check for metal"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  if(metal.and.nvar<(ndim+4))then"
  write(ilun,format)"     if(myid==1)write(*,*)'Error: metals need nvar >= ndim+4'"
  write(ilun,format)"     if(myid==1)write(*,*)'Modify hydro_parameters.f90 and recompile'"
  write(ilun,format)"     nml_ok=.false."
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  ! Check for non-thermal energies"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"#if NENER>0"
  write(ilun,format)"  if(nvar<(ndim+2+nener))then"
  write(ilun,format)"     if(myid==1)write(*,*)'Error: non-thermal energy need nvar >= ndim+2+nener'"
  write(ilun,format)"     if(myid==1)write(*,*)'Modify NENER and recompile'"
  write(ilun,format)"     nml_ok=.false."
  write(ilun,format)"  endif"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  ! Check ind_rsink"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  if(ind_rsink<=0.0d0)then"
  write(ilun,format)"     if(myid==1)write(*,*)'Error in the namelist'"
  write(ilun,format)"     if(myid==1)write(*,*)'Check ind_rsink'"
  write(ilun,format)"     nml_ok=.false."
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  !-------------------------------------------------"
  write(ilun,format)"  ! This section deals with hydro boundary conditions"
  write(ilun,format)"  !-------------------------------------------------"
  write(ilun,format)"  if(simple_boundary.and.nboundary==0)then"
  write(ilun,format)"     simple_boundary=.false."
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  if (simple_boundary)then"
  write(ilun,format)""
  write(ilun,format)"     ! Compute new coarse grid boundaries"
  write(ilun,format)"     do i=1,nboundary"
  write(ilun,format)"        if(ibound_min(i)*ibound_max(i)==1.and.ndim>0.and.bound_type(i)>0)then"
  write(ilun,format)"           nx=nx+1"
  write(ilun,format)"           if(ibound_min(i)==-1)then"
  write(ilun,format)"              icoarse_min=icoarse_min+1"
  write(ilun,format)"              icoarse_max=icoarse_max+1"
  write(ilun,format)"           end if"
  write(ilun,format)"           nboundary_true=nboundary_true+1"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"     do i=1,nboundary"
  write(ilun,format)"        if(jbound_min(i)*jbound_max(i)==1.and.ndim>1.and.bound_type(i)>0)then"
  write(ilun,format)"           ny=ny+1"
  write(ilun,format)"           if(jbound_min(i)==-1)then"
  write(ilun,format)"              jcoarse_min=jcoarse_min+1"
  write(ilun,format)"              jcoarse_max=jcoarse_max+1"
  write(ilun,format)"           end if"
  write(ilun,format)"           nboundary_true=nboundary_true+1"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"     do i=1,nboundary"
  write(ilun,format)"        if(kbound_min(i)*kbound_max(i)==1.and.ndim>2.and.bound_type(i)>0)then"
  write(ilun,format)"           nz=nz+1"
  write(ilun,format)"           if(kbound_min(i)==-1)then"
  write(ilun,format)"              kcoarse_min=kcoarse_min+1"
  write(ilun,format)"              kcoarse_max=kcoarse_max+1"
  write(ilun,format)"           end if"
  write(ilun,format)"           nboundary_true=nboundary_true+1"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     ! Compute boundary geometry"
  write(ilun,format)"     do i=1,nboundary"
  write(ilun,format)"        if(ibound_min(i)*ibound_max(i)==1.and.ndim>0.and.bound_type(i)>0)then"
  write(ilun,format)"           if(ibound_min(i)==-1)then"
  write(ilun,format)"              ibound_min(i)=icoarse_min+ibound_min(i)"
  write(ilun,format)"              ibound_max(i)=icoarse_min+ibound_max(i)"
  write(ilun,format)"              if(bound_type(i)==1)boundary_type(i)=1"
  write(ilun,format)"              if(bound_type(i)==2)boundary_type(i)=11"
  write(ilun,format)"              if(bound_type(i)==3)boundary_type(i)=21"
  write(ilun,format)"           else"
  write(ilun,format)"              ibound_min(i)=icoarse_max+ibound_min(i)"
  write(ilun,format)"              ibound_max(i)=icoarse_max+ibound_max(i)"
  write(ilun,format)"              if(bound_type(i)==1)boundary_type(i)=2"
  write(ilun,format)"              if(bound_type(i)==2)boundary_type(i)=12"
  write(ilun,format)"              if(bound_type(i)==3)boundary_type(i)=22"
  write(ilun,format)"           end if"
  write(ilun,format)"           if(ndim>1)jbound_min(i)=jcoarse_min+jbound_min(i)"
  write(ilun,format)"           if(ndim>1)jbound_max(i)=jcoarse_max+jbound_max(i)"
  write(ilun,format)"           if(ndim>2)kbound_min(i)=kcoarse_min+kbound_min(i)"
  write(ilun,format)"           if(ndim>2)kbound_max(i)=kcoarse_max+kbound_max(i)"
  write(ilun,format)"        else if(jbound_min(i)*jbound_max(i)==1.and.ndim>1.and.bound_type(i)>0)then"
  write(ilun,format)"           ibound_min(i)=icoarse_min+ibound_min(i)"
  write(ilun,format)"           ibound_max(i)=icoarse_max+ibound_max(i)"
  write(ilun,format)"           if(jbound_min(i)==-1)then"
  write(ilun,format)"              jbound_min(i)=jcoarse_min+jbound_min(i)"
  write(ilun,format)"              jbound_max(i)=jcoarse_min+jbound_max(i)"
  write(ilun,format)"              if(bound_type(i)==1)boundary_type(i)=3"
  write(ilun,format)"              if(bound_type(i)==2)boundary_type(i)=13"
  write(ilun,format)"              if(bound_type(i)==3)boundary_type(i)=23"
  write(ilun,format)"           else"
  write(ilun,format)"              jbound_min(i)=jcoarse_max+jbound_min(i)"
  write(ilun,format)"              jbound_max(i)=jcoarse_max+jbound_max(i)"
  write(ilun,format)"              if(bound_type(i)==1)boundary_type(i)=4"
  write(ilun,format)"              if(bound_type(i)==2)boundary_type(i)=14"
  write(ilun,format)"              if(bound_type(i)==3)boundary_type(i)=24"
  write(ilun,format)"           end if"
  write(ilun,format)"           if(ndim>2)kbound_min(i)=kcoarse_min+kbound_min(i)"
  write(ilun,format)"           if(ndim>2)kbound_max(i)=kcoarse_max+kbound_max(i)"
  write(ilun,format)"        else if(kbound_min(i)*kbound_max(i)==1.and.ndim>2.and.bound_type(i)>0)then"
  write(ilun,format)"           ibound_min(i)=icoarse_min+ibound_min(i)"
  write(ilun,format)"           ibound_max(i)=icoarse_max+ibound_max(i)"
  write(ilun,format)"           jbound_min(i)=jcoarse_min+jbound_min(i)"
  write(ilun,format)"           jbound_max(i)=jcoarse_max+jbound_max(i)"
  write(ilun,format)"           if(kbound_min(i)==-1)then"
  write(ilun,format)"              kbound_min(i)=kcoarse_min+kbound_min(i)"
  write(ilun,format)"              kbound_max(i)=kcoarse_min+kbound_max(i)"
  write(ilun,format)"              if(bound_type(i)==1)boundary_type(i)=5"
  write(ilun,format)"              if(bound_type(i)==2)boundary_type(i)=15"
  write(ilun,format)"              if(bound_type(i)==3)boundary_type(i)=25"
  write(ilun,format)"           else"
  write(ilun,format)"              kbound_min(i)=kcoarse_max+kbound_min(i)"
  write(ilun,format)"              kbound_max(i)=kcoarse_max+kbound_max(i)"
  write(ilun,format)"              if(bound_type(i)==1)boundary_type(i)=6"
  write(ilun,format)"              if(bound_type(i)==2)boundary_type(i)=16"
  write(ilun,format)"              if(bound_type(i)==3)boundary_type(i)=26"
  write(ilun,format)"           end if"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"     do i=1,nboundary"
  write(ilun,format)"        ! Check for errors"
  write(ilun,format)"        if( (ibound_min(i)<0.or.ibound_max(i)>(nx-1)) .and. (ndim>0) .and.bound_type(i)>0 )then"
  write(ilun,format)"           if(myid==1)write(*,*)'Error in the namelist'"
  write(ilun,format)"           if(myid==1)write(*,*)'Check boundary conditions along X direction',i"
  write(ilun,format)"           nml_ok=.false."
  write(ilun,format)"        end if"
  write(ilun,format)"        if( (jbound_min(i)<0.or.jbound_max(i)>(ny-1)) .and. (ndim>1) .and.bound_type(i)>0)then"
  write(ilun,format)"           if(myid==1)write(*,*)'Error in the namelist'"
  write(ilun,format)"           if(myid==1)write(*,*)'Check boundary conditions along Y direction',i"
  write(ilun,format)"           nml_ok=.false."
  write(ilun,format)"        end if"
  write(ilun,format)"        if( (kbound_min(i)<0.or.kbound_max(i)>(nz-1)) .and. (ndim>2) .and.bound_type(i)>0)then"
  write(ilun,format)"           if(myid==1)write(*,*)'Error in the namelist'"
  write(ilun,format)"           if(myid==1)write(*,*)'Check boundary conditions along Z direction',i"
  write(ilun,format)"           nml_ok=.false."
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  end if"
  write(ilun,format)"  nboundary=nboundary_true"
  write(ilun,format)"  if(simple_boundary.and.nboundary==0)then"
  write(ilun,format)"     simple_boundary=.false."
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  ! Compute boundary conservative variables"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  do i=1,nboundary"
  write(ilun,format)"     boundary_var(i,1)=MAX(d_bound(i),smallr)"
  write(ilun,format)"     boundary_var(i,2)=d_bound(i)*u_bound(i)"
  write(ilun,format)"#if NDIM>1"
  write(ilun,format)"     boundary_var(i,3)=d_bound(i)*v_bound(i)"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM>2"
  write(ilun,format)"     boundary_var(i,4)=d_bound(i)*w_bound(i)"
  write(ilun,format)"#endif"
  write(ilun,format)"     ek_bound=0.0d0"
  write(ilun,format)"     do idim=1,ndim"
  write(ilun,format)"        ek_bound=ek_bound+0.5d0*boundary_var(i,idim+1)**2/boundary_var(i,1)"
  write(ilun,format)"     end do"
  write(ilun,format)"     boundary_var(i,ndim+2)=ek_bound+P_bound(i)/(gamma-1.0d0)"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  !-----------------------------------"
  write(ilun,format)"  ! Rearrange level dependent arrays"
  write(ilun,format)"  !-----------------------------------"
  write(ilun,format)"  do i=nlevelmax,levelmin,-1"
  write(ilun,format)"     jeans_refine(i)=jeans_refine(i-levelmin+1)"
  write(ilun,format)"  end do"
  write(ilun,format)"  do i=1,levelmin-1"
  write(ilun,format)"     jeans_refine(i)=-1.0"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  !-----------------------------------"
  write(ilun,format)"  ! Sort out passive variable indices"
  write(ilun,format)"  !-----------------------------------"
  write(ilun,format)"  imetal=nener+ndim+3"
  write(ilun,format)"  idelay=imetal"
  write(ilun,format)"  if(metal)idelay=imetal+1"
  write(ilun,format)"  ixion=idelay"
  write(ilun,format)"  if(delayed_cooling)ixion=idelay+1"
  write(ilun,format)"  ichem=ixion"
  write(ilun,format)"  if(aton)ichem=ixion+1"
  write(ilun,format)"  ! Last variable is ichem"
  write(ilun,format)""
  write(ilun,format)"end subroutine read_hydro_params"
  write(ilun,format)""
  write(ilun,format)"../patch/hydro/stratified_medium_fx_NSM/read_params.f90"
  write(ilun,format)"subroutine read_params"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_parameters"
  write(ilun,format)"  use poisson_parameters"
  write(ilun,format)"  use hydro_parameters"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  ! Local variables"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  integer::i,narg,iargc,ierr,levelmax"
  write(ilun,format)"  character(LEN=80)::infile"
  write(ilun,format)"  character(LEN=80)::cmdarg"
  write(ilun,format)"  integer(kind=8)::ngridtot=0"
  write(ilun,format)"  integer(kind=8)::nparttot=0"
  write(ilun,format)"  real(kind=8)::delta_tout=0,tend=0"
  write(ilun,format)"  real(kind=8)::delta_aout=0,aend=0"
  write(ilun,format)"  logical::nml_ok"
  write(ilun,format)"  integer,parameter::tag=1134"
  write(ilun,format)"  integer::dummy_io,info2"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  ! Namelist definitions"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  namelist/run_params/clumpfind,cosmo,pic,sink,lightcone,poisson,hydro,rt,verbose,debug &"
  write(ilun,format)"       & ,nrestart,ncontrol,nstepmax,nsubcycle,nremap,ordering &"
  write(ilun,format)"       & ,bisec_tol,static,geom,overload,cost_weighting,aton"
  write(ilun,format)"  namelist/output_params/noutput,foutput,aout,tout,output_mode &"
  write(ilun,format)"       & ,tend,delta_tout,aend,delta_aout,gadget_output"
  write(ilun,format)"  namelist/amr_params/levelmin,levelmax,ngridmax,ngridtot &"
  write(ilun,format)"       & ,npartmax,nparttot,nexpand,boxlen"
  write(ilun,format)"  namelist/poisson_params/epsilon,gravity_type,gravity_params &"
  write(ilun,format)"       & ,cg_levelmin,cic_levelmax"
  write(ilun,format)"  namelist/lightcone_params/thetay_cone,thetaz_cone,zmax_cone"
  write(ilun,format)"  namelist/movie_params/levelmax_frame,nw_frame,nh_frame,ivar_frame &"
  write(ilun,format)"       & ,xcentre_frame,ycentre_frame,zcentre_frame &"
  write(ilun,format)"       & ,deltax_frame,deltay_frame,deltaz_frame,movie &"
  write(ilun,format)"       & ,imovout,imov,tendmov,aendmov,proj_axis,movie_vars,movie_vars_txt"
  write(ilun,format)"  namelist/cc_params/medium_type,grid_file,random_file,rc,xwind,ywind,zwind & "
  write(ilun,format)"       & ,rhocool,Pc,vin,Mdot_in,Tin_K,logLAGN,alph,r0,h,gam,E_SN_th &"
  write(ilun,format)"       & ,P_SN_rad,E_SN_kin,sn_rate,nblast_current, Ia_vs_NSM, conversion_NSM, conversion_Ia, t_delay_NSM, t_delay_Ia, H_NSM, H_Ia"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! MPI initialization"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  call MPI_INIT(ierr)"
  write(ilun,format)"  call MPI_COMM_RANK(MPI_COMM_WORLD,myid,ierr)"
  write(ilun,format)"  call MPI_COMM_SIZE(MPI_COMM_WORLD,ncpu,ierr)"
  write(ilun,format)"  myid=myid+1 ! Careful with this..."
  write(ilun,format)"#endif"
  write(ilun,format)"#ifdef WITHOUTMPI"
  write(ilun,format)"  ncpu=1"
  write(ilun,format)"  myid=1"
  write(ilun,format)"#endif"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  ! Advertise RAMSES"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  if(myid==1)then"
  write(ilun,format)"  write(*,*)'_/_/_/       _/_/     _/    _/    _/_/_/   _/_/_/_/    _/_/_/  '"
  write(ilun,format)"  write(*,*)'_/    _/    _/  _/    _/_/_/_/   _/    _/  _/         _/    _/ '"
  write(ilun,format)"  write(*,*)'_/    _/   _/    _/   _/ _/ _/   _/        _/         _/       '"
  write(ilun,format)"  write(*,*)'_/_/_/     _/_/_/_/   _/    _/     _/_/    _/_/_/       _/_/   '"
  write(ilun,format)"  write(*,*)'_/    _/   _/    _/   _/    _/         _/  _/               _/ '"
  write(ilun,format)"  write(*,*)'_/    _/   _/    _/   _/    _/   _/    _/  _/         _/    _/ '"
  write(ilun,format)"  write(*,*)'_/    _/   _/    _/   _/    _/    _/_/_/   _/_/_/_/    _/_/_/  '"
  write(ilun,format)"  write(*,*)'                        Version 3.0                            '"
  write(ilun,format)"  write(*,*)'       written by Romain Teyssier (University of Zurich)       '"
  write(ilun,format)"  write(*,*)'               (c) CEA 1999-2007, UZH 2008-2014                '"
  write(ilun,format)"  write(*,*)' '"
  write(ilun,format)"  write(*,'(' Working with nproc = ',I4,' for ndim = ',I1)')ncpu,ndim"
  write(ilun,format)"  ! Check nvar is not too small"
  write(ilun,format)"#ifdef SOLVERhydro"
  write(ilun,format)"  write(*,'(' Using solver = hydro with nvar = ',I2)')nvar"
  write(ilun,format)"  if(nvar<ndim+2)then"
  write(ilun,format)"     write(*,*)'You should have: nvar>=ndim+2'"
  write(ilun,format)"     write(*,'(' Please recompile with -DNVAR=',I2)')ndim+2"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  endif"
  write(ilun,format)"#endif"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"  write(*,'(' Using solver = mhd with nvar = ',I2)')nvar"
  write(ilun,format)"  if(nvar<8)then"
  write(ilun,format)"     write(*,*)'You should have: nvar>=8'"
  write(ilun,format)"     write(*,'(' Please recompile with -DNVAR=8')')"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  endif"
  write(ilun,format)"#endif"
  write(ilun,format)"  "
  write(ilun,format)"  !Write I/O group size information"
  write(ilun,format)"  if(IOGROUPSIZE>0.or.IOGROUPSIZECONE>0.or.IOGROUPSIZEREP>0)write(*,*)' '"
  write(ilun,format)"  if(IOGROUPSIZE>0) write(*,*)'IOGROUPSIZE=',IOGROUPSIZE"
  write(ilun,format)"  if(IOGROUPSIZECONE>0) write(*,*)'IOGROUPSIZECONE=',IOGROUPSIZECONE"
  write(ilun,format)"  if(IOGROUPSIZEREP>0) write(*,*)'IOGROUPSIZEREP=',IOGROUPSIZEREP"
  write(ilun,format)"  if(IOGROUPSIZE>0.or.IOGROUPSIZECONE>0.or.IOGROUPSIZEREP>0)write(*,*)' '"
  write(ilun,format)""
  write(ilun,format)"  ! Write information about git version"
  write(ilun,format)"  call write_gitinfo"
  write(ilun,format)""
  write(ilun,format)"  ! Read namelist filename from command line argument"
  write(ilun,format)"  narg = iargc()"
  write(ilun,format)"  IF(narg .LT. 1)THEN"
  write(ilun,format)"     write(*,*)'You should type: ramses3d input.nml [nrestart]'"
  write(ilun,format)"     write(*,*)'File input.nml should contain a parameter namelist'"
  write(ilun,format)"     write(*,*)'nrestart is optional'"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  END IF"
  write(ilun,format)"  CALL getarg(1,infile)"
  write(ilun,format)"  endif"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  call MPI_BCAST(infile,80,MPI_CHARACTER,0,MPI_COMM_WORLD,ierr)"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  !-------------------------------------------------"
  write(ilun,format)"  ! Read the namelist"
  write(ilun,format)"  !-------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  ! Wait for the token                                                                                                                                                                                "
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     if(IOGROUPSIZE>0) then"
  write(ilun,format)"        if (mod(myid-1,IOGROUPSIZE)/=0) then"
  write(ilun,format)"           call MPI_RECV(dummy_io,1,MPI_INTEGER,myid-1-1,tag,&"
  write(ilun,format)"                & MPI_COMM_WORLD,MPI_STATUS_IGNORE,info2)"
  write(ilun,format)"        end if"
  write(ilun,format)"     endif"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  namelist_file=TRIM(infile)"
  write(ilun,format)"  INQUIRE(file=infile,exist=nml_ok)"
  write(ilun,format)"  if(.not. nml_ok)then"
  write(ilun,format)"     if(myid==1)then"
  write(ilun,format)"        write(*,*)'File '//TRIM(infile)//' does not exist'"
  write(ilun,format)"     endif"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  open(1,file=infile)"
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"  read(1,NML=run_params)"
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"  read(1,NML=output_params)"
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"  read(1,NML=amr_params)"
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"  read(1,NML=lightcone_params,END=83)"
  write(ilun,format)"83 continue"
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"  read(1,NML=movie_params,END=82)"
  write(ilun,format)"82 continue"
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"  read(1,NML=poisson_params,END=81)"
  write(ilun,format)"81 continue"
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"  read(1,NML=cc_params,END=80)"
  write(ilun,format)"80 continue"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  !-------------------------------------------------"
  write(ilun,format)"  ! Read optional nrestart command-line argument"
  write(ilun,format)"  !-------------------------------------------------"
  write(ilun,format)"  if (myid==1 .and. narg == 2) then"
  write(ilun,format)"     CALL getarg(2,cmdarg)"
  write(ilun,format)"     read(cmdarg,*) nrestart"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  call MPI_BCAST(nrestart,1,MPI_INTEGER,0,MPI_COMM_WORLD,ierr)"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  !-------------------------------------------------"
  write(ilun,format)"  ! Compute time step for outputs"
  write(ilun,format)"  !-------------------------------------------------"
  write(ilun,format)"  if(tend>0)then"
  write(ilun,format)"     if(delta_tout==0)delta_tout=tend"
  write(ilun,format)"     noutput=MIN(int(tend/delta_tout),MAXOUT)"
  write(ilun,format)"     do i=1,noutput"
  write(ilun,format)"        tout(i)=dble(i)*delta_tout"
  write(ilun,format)"     end do"
  write(ilun,format)"  else if(aend>0)then"
  write(ilun,format)"     if(delta_aout==0)delta_aout=aend"
  write(ilun,format)"     noutput=MIN(int(aend/delta_aout),MAXOUT)"
  write(ilun,format)"     do i=1,noutput"
  write(ilun,format)"        aout(i)=dble(i)*delta_aout"
  write(ilun,format)"     end do"
  write(ilun,format)"  endif"
  write(ilun,format)"  noutput=MIN(noutput,MAXOUT)"
  write(ilun,format)"  if(imovout>0) then"
  write(ilun,format)"     allocate(tmovout(1:imovout))"
  write(ilun,format)"     allocate(amovout(1:imovout))"
  write(ilun,format)"     tmovout=1d100"
  write(ilun,format)"     amovout=1d100"
  write(ilun,format)"     if(tendmov>0)then"
  write(ilun,format)"        do i=1,imovout"
  write(ilun,format)"           tmovout(i)=tendmov*dble(i)/dble(imovout)"
  write(ilun,format)"        enddo"
  write(ilun,format)"     endif"
  write(ilun,format)"     if(aendmov>0)then"
  write(ilun,format)"        do i=1,imovout"
  write(ilun,format)"           amovout(i)=aendmov*dble(i)/dble(imovout)"
  write(ilun,format)"        enddo"
  write(ilun,format)"     endif"
  write(ilun,format)"     if(tendmov==0.and.aendmov==0)movie=.false."
  write(ilun,format)"  endif"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  ! Check for errors in the namelist so far"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  levelmin=MAX(levelmin,1)"
  write(ilun,format)"  nlevelmax=levelmax"
  write(ilun,format)"  nml_ok=.true."
  write(ilun,format)"  if(levelmin<1)then"
  write(ilun,format)"     if(myid==1)write(*,*)'Error in the namelist:'"
  write(ilun,format)"     if(myid==1)write(*,*)'levelmin should not be lower than 1 !!!'"
  write(ilun,format)"     nml_ok=.false."
  write(ilun,format)"  end if"
  write(ilun,format)"  if(nlevelmax<levelmin)then"
  write(ilun,format)"     if(myid==1)write(*,*)'Error in the namelist:'"
  write(ilun,format)"     if(myid==1)write(*,*)'levelmax should not be lower than levelmin'"
  write(ilun,format)"     nml_ok=.false."
  write(ilun,format)"  end if"
  write(ilun,format)"  if(ngridmax==0)then"
  write(ilun,format)"     if(ngridtot==0)then"
  write(ilun,format)"        if(myid==1)write(*,*)'Error in the namelist:'"
  write(ilun,format)"        if(myid==1)write(*,*)'Allocate some space for refinements !!!'"
  write(ilun,format)"        nml_ok=.false."
  write(ilun,format)"     else"
  write(ilun,format)"        ngridmax=ngridtot/int(ncpu,kind=8)"
  write(ilun,format)"     endif"
  write(ilun,format)"  end if"
  write(ilun,format)"  if(npartmax==0)then"
  write(ilun,format)"     npartmax=nparttot/int(ncpu,kind=8)"
  write(ilun,format)"  endif"
  write(ilun,format)"  if(myid>1)verbose=.false."
  write(ilun,format)"  if(sink.and.(.not.pic))then"
  write(ilun,format)"     pic=.true."
  write(ilun,format)"  endif"
  write(ilun,format)"  if(clumpfind.and.(.not.pic))then"
  write(ilun,format)"     pic=.true."
  write(ilun,format)"  endif"
  write(ilun,format)"  !if(pic.and.(.not.poisson))then"
  write(ilun,format)"  !   poisson=.true."
  write(ilun,format)"  !endif"
  write(ilun,format)""
  write(ilun,format)"  call read_hydro_params(nml_ok)"
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"  call rt_read_hydro_params(nml_ok)"
  write(ilun,format)"#endif"
  write(ilun,format)"  if (sink)call read_sink_params"
  write(ilun,format)"  if (clumpfind .or. sink)call read_clumpfind_params"
  write(ilun,format)"  if (movie)call set_movie_vars"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  close(1)"
  write(ilun,format)""
  write(ilun,format)"  ! Send the token"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  if(IOGROUPSIZE>0) then"
  write(ilun,format)"     if(mod(myid,IOGROUPSIZE)/=0 .and.(myid.lt.ncpu))then"
  write(ilun,format)"        dummy_io=1"
  write(ilun,format)"        call MPI_SEND(dummy_io,1,MPI_INTEGER,myid-1+1,tag, &"
  write(ilun,format)"             & MPI_COMM_WORLD,info2)"
  write(ilun,format)"     end if"
  write(ilun,format)"  endif"
  write(ilun,format)"#endif"
  write(ilun,format)"  "
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  !-----------------"
  write(ilun,format)"  ! Max size checks"
  write(ilun,format)"  !-----------------"
  write(ilun,format)"  if(nlevelmax>MAXLEVEL)then"
  write(ilun,format)"     write(*,*) 'Error: nlevelmax>MAXLEVEL'"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  end if"
  write(ilun,format)"  if(nregion>MAXREGION)then"
  write(ilun,format)"     write(*,*) 'Error: nregion>MAXREGION'"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  end if"
  write(ilun,format)"  "
  write(ilun,format)"  !-----------------------------------"
  write(ilun,format)"  ! Rearrange level dependent arrays"
  write(ilun,format)"  !-----------------------------------"
  write(ilun,format)"  do i=nlevelmax,levelmin,-1"
  write(ilun,format)"     nexpand   (i)=nexpand   (i-levelmin+1)"
  write(ilun,format)"     nsubcycle (i)=nsubcycle (i-levelmin+1)"
  write(ilun,format)"     r_refine  (i)=r_refine  (i-levelmin+1)"
  write(ilun,format)"     a_refine  (i)=a_refine  (i-levelmin+1)"
  write(ilun,format)"     b_refine  (i)=b_refine  (i-levelmin+1)"
  write(ilun,format)"     x_refine  (i)=x_refine  (i-levelmin+1)"
  write(ilun,format)"     y_refine  (i)=y_refine  (i-levelmin+1)"
  write(ilun,format)"     z_refine  (i)=z_refine  (i-levelmin+1)"
  write(ilun,format)"     m_refine  (i)=m_refine  (i-levelmin+1)"
  write(ilun,format)"     exp_refine(i)=exp_refine(i-levelmin+1)"
  write(ilun,format)"     initfile  (i)=initfile  (i-levelmin+1)"
  write(ilun,format)"  end do"
  write(ilun,format)"  do i=1,levelmin-1"
  write(ilun,format)"     nexpand   (i)= 1"
  write(ilun,format)"     nsubcycle (i)= 1"
  write(ilun,format)"     r_refine  (i)=-1.0"
  write(ilun,format)"     a_refine  (i)= 1.0"
  write(ilun,format)"     b_refine  (i)= 1.0"
  write(ilun,format)"     x_refine  (i)= 0.0"
  write(ilun,format)"     y_refine  (i)= 0.0"
  write(ilun,format)"     z_refine  (i)= 0.0"
  write(ilun,format)"     m_refine  (i)=-1.0"
  write(ilun,format)"     exp_refine(i)= 2.0"
  write(ilun,format)"     initfile  (i)= ' '"
  write(ilun,format)"  end do"
  write(ilun,format)"     "
  write(ilun,format)"  if(.not. nml_ok)then"
  write(ilun,format)"     if(myid==1)write(*,*)'Too many errors in the namelist'"
  write(ilun,format)"     if(myid==1)write(*,*)'Aborting...'"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  call MPI_BARRIER(MPI_COMM_WORLD,ierr)"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"end subroutine read_params"
  write(ilun,format)""
  write(ilun,format)"../patch/hydro/stratified_medium_fx_NSM/rho_ana.f90"
  write(ilun,format)"!#########################################################"
  write(ilun,format)"!#########################################################"
  write(ilun,format)"!#########################################################"
  write(ilun,format)"!#########################################################"
  write(ilun,format)"subroutine rho_ana(x,d,dx,ncell)"
  write(ilun,format)"  use amr_parameters"
  write(ilun,format)"  use hydro_parameters"
  write(ilun,format)"  use poisson_parameters"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer ::ncell                         ! Number of cells"
  write(ilun,format)"  real(dp)::dx                            ! Cell size"
  write(ilun,format)"  real(dp),dimension(1:nvector)       ::d ! Density"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim)::x ! Cell center position."
  write(ilun,format)"  !================================================================"
  write(ilun,format)"  ! This routine generates analytical Poisson source term."
  write(ilun,format)"  ! Positions are in user units:"
  write(ilun,format)"  ! x(i,1:3) are in [0,boxlen]**ndim."
  write(ilun,format)"  ! d(i) is the density field in user units."
  write(ilun,format)"  !================================================================"
  write(ilun,format)"  integer::i"
  write(ilun,format)"  character(LEN=160)::infile"
  write(ilun,format)"  real(dp)::a1,a2,z0,f,T0,rho0,sigma0"
  write(ilun,format)"  real(dp)::rx,ry,rz,rr"
  write(ilun,format)"  real(dp)::scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! Conversion factor from user units to cgs units "
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! Parameters of the model - convert to cgs"
  write(ilun,format)"  a1=gravity_params(1) ! disc component factor"
  write(ilun,format)"  a2=gravity_params(2) ! halo component factor"
  write(ilun,format)"  z0=gravity_params(3) ! scale height of the disc"
  write(ilun,format)"  T0=gravity_params(4) ! temperature in the mid-plane"
  write(ilun,format)"  sigma0=gravity_params(5) ! gas surface density"
  write(ilun,format)"  a1=a1*3.08d21/(1d6*365.*24.*3600.)**2 ! cm/s2"
  write(ilun,format)"  a2=a2/(1d6*365.*24.*3600.)**2 ! s-2"
  write(ilun,format)"  z0=z0*3.08d21 ! cm"
  write(ilun,format)"  T0=T0 ! K"
  write(ilun,format)"  f=0.6*1.66d-24/1.38d-16/T0 ! s2/cm2"
  write(ilun,format)"  sigma0=sigma0*2d33/(3.08d21)**2 ! g/cm2"
  write(ilun,format)"  rho0=sigma0/1.32171d21 ! g/cm3"
  write(ilun,format)""
  write(ilun,format)"  do i=1,ncell"
  write(ilun,format)"     rz=(x(i,3)-zwind)*scale_l"
  write(ilun,format)"     d(i)=rho0*exp(-(a1*f*(sqrt(rz**2+z0**2)-z0)+a2*f*(rz**2)/2))/scale_d"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"end subroutine rho_ana"
  write(ilun,format)"../patch/hydro/stratified_medium_fx_NSM/units.f90"
  write(ilun,format)"subroutine units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use cooling_module"
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_t,scale_v,scale_d,scale_l"
  write(ilun,format)"  !-----------------------------------------------------------------------"
  write(ilun,format)"  ! Conversion factors from user units into cgs units"
  write(ilun,format)"  ! For gravity runs, make sure that G=1 in user units."
  write(ilun,format)"  !-----------------------------------------------------------------------"
  write(ilun,format)"  real(dp)::mu=0.6"
  write(ilun,format)""
  write(ilun,format)"  ! length=1 pc"
  write(ilun,format)"  ! time=10000 yr"
  write(ilun,format)""
  write(ilun,format)"  ! scale_d converts mass density from user units into g/cc"
  write(ilun,format)"  scale_d = mH/X"
  write(ilun,format)"  if(cosmo) scale_d = omega_m * rhoc *(h0/100.)**2 / aexp**3"
  write(ilun,format)""
  write(ilun,format)"  ! scale_t converts time from user units into seconds"
  write(ilun,format)"  scale_t = 315360000000.0"
  write(ilun,format)"  if(cosmo) scale_t = aexp**2 / (h0*1d5/3.08d24)"
  write(ilun,format)""
  write(ilun,format)"  ! scale_l converts distance from user units into cm. 1 user units = 1 pc."
  write(ilun,format)"  scale_l = 3.08568025d18"
  write(ilun,format)"  if(cosmo) scale_l = aexp * boxlen_ini * 3.08d24 / (h0/100)"
  write(ilun,format)""
  write(ilun,format)"  ! scale_v convert velocity in user units into cm/s"
  write(ilun,format)"  scale_v = scale_l / scale_t"
  write(ilun,format)""
  write(ilun,format)"  ! scale_T2 converts (P/rho) in user unit into (T/mu) in Kelvin"
  write(ilun,format)"  scale_T2 = mH/kB * scale_v**2"
  write(ilun,format)""
  write(ilun,format)"  ! scale_nH converts rho in user units into nH in H/cc"
  write(ilun,format)"  scale_nH = X/mH * scale_d"
  write(ilun,format)"  "
  write(ilun,format)"end subroutine units"
  close(ilun)
end subroutine output_patch
